'------------------------------------------------------------------------------
' Low/full speed Minimal USBHost with Keyboard/Mouse "boot protocol" support.
' garryj 5/2018
' TABs as space, width: 8.
' Serial terminal: Parallax Serial Terminal
' Prop123-A9 FPGA Board, P2v32 image:
'   PB0 = 54 (hardware reset)
'   PB1 = 55
'   PB2 = 56
'   PB3 = 57
'   P32..P47 are connected to the green LEDs (LED0..LED15)
'------------------------------------------------------------------------------
' Generic loader for the USB host/driver cog pair:
'  The host and driver cogs use LUT sharing, so they must be started as an
'  adjacent even/odd pair. The usb_start subroutine will attempt to locate and
'  start a free cog pair.
' Integration of the USB boot mouse/keyboard code into your own program should
'  be relatively simple.
'  1 - Adapt the HubExec "usb_start" subroutine call into your startup code.
'  2 - Copy USB code and append to your program.
'  3 - Fix up any constant/label name collisions.
'  4 - Adapt your program to read the mouse/keyboard data from the (Boot
'      Protocol Mouse/Keyboard Hub Interface) region, which is located at the
'      label mouse_count.
'------------------------------------------------------------------------------
dat
                org
loader_entry
                hubset  #$ff                            ' P2v26+ always need to initialize fast clock
                call    #usb_start                      ' Hub-based subroutine that attempts to locate a free even/odd cog pair
                tjz     pa, #.continue                  ' PA will be zero if free cogs found
                or      dirb, #$ff                      ' Host/driver cogs not started, show error on LED7..LED0 of P123-A9
                or      outb, #$ff
.error
                jmp     #.error
.continue
                cogid   pa
                cogstop pa
'------------------------------------------------------------------------------
' vvvvvvvvvvvvvvvvvvvvvvvv Copy code from below to EOF vvvvvvvvvvvvvvvvvvvvvvvv
'------------------------------------------------------------------------------
' #region (Basics of P2 USB SmartPins)
{
  USB References:
  Universal Serial Bus Specification, Revision 2.0
    www.usb.org/developers/docs/usb20_docs/
  Device Class Definition for Human Interface Devices (HID), Version 1.11
    www.usb.org/developers/hidpage/

Smart pin configuration bits:
  D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0

USB smart pin modes:
  %11000 = USB host, low-speed
  %11001 = USB host, full-speed
  %11010 = USB device, low-speed
  %11011 = USB device, full-speed

These modes require that two adjacent pins be configured together to form a USB pair, whose OUTs
will be overridden to control their output states. These pins must be an even/odd pair, having
only the LSB of their pin numbers different. For example: pins 0 and 1, pins 2 and 3, pins 4
and 5, etc., can form USB pairs. They can be configured via WRPIN with identical D data of
%1_110xx_0. Using D data of %0_110xx_0 will disable output drive and effectively create a USB
'sniffer'. A new WRPIN can be done to effect such a change without resetting the smart pin.

NOTE: in the current FPGA, there are no built-in 1.5k and 15k resistors, which the final silicon
smart pins will contain, so it is up to you to insert these yourself on the DP and DM lines.

The upper (odd) pin is the DP pin. This pin's IN is raised whenever the output buffer empties,
signalling that a new output byte can be written via WYPIN to the lower (even) pin. No
WXPIN/WYPIN instructions are used for this pin.

The lower (even) pin is the DM pin. This pin's IN is raised whenever a change of status occurs in
the receiver, at which point a RDPIN can be used on this pin to read the 16-bit status word.
WXPIN is used on this pin to set the NCO baud rate.

These DP/DM electrical designations can actually be switched by swapping low-speed and full-speed
modes, due to USB's mirrored line signalling.

To start USB, clear the DIR bits of the intended two pins and configure them each via WRPIN. Use
WXPIN on the lower pin to set the baud rate, which is a 16-bit fraction of the system clock. For
example, if the main clock is 80MHz and you want a 12MHz baud rate (full-speed), use
12,000,000 / 80,000,000 * $10000 = 9830. Then, set the pins' DIR bits. You are now ready to read
the receiver status via RDPIN and set output states and send packets via WYPIN, both on the
lower pin.

To affect the line states or send a packet, use WYPIN on the lower pin. Here are its D values:
 0 = output IDLE        - default state, float pins, except possible resistor(s) to 3.3V or GND
 1 = output SE0         - drive both DP and DM low
 2 = output K           - drive K state onto DP and DM (opposite)
 3 = output J           - drive J state onto DP and DM (opposite), like IDLE, but driven
 4 = output EOP         - output end-of-packet: SE0, SE0, J, then IDLE
 $80 = SOP              - output start-of-packet, then bytes, automatic EOP when buffer runs out

To send a packet, first do a 'WYPIN #$80, lowerpin'. Then, after each IN rise on the upper pin,
do a 'AKPIN upperpin', followed by a 'WYPIN byte,lowerpin' to buffer the next byte. Bits 31..8
of your data bytes are ignored, but by keeping those upper bits clear, WYPIN will be able to do
the fastest transfer to the smart pin, which takes only 4 clocks. The transmitter will automatically
send an EOP when you stop giving it bytes. To keep the output buffer from overflowing, you should
always verify that the upper pin's IN was raised after each WYPIN, before issuing another
WYPIN, even if you are just setting a state. The reason for this is that all output activity is
timed to the baud generator and even state changes must wait for the next bit period before being
implemented, at which time the output buffer empties.

There are separate state machines for transmitting and receiving. Only the baud generator is common
between them. The transmitter was just described above. Below, the receiver is detailed. Note that
the receiver receives not just input from another host/device, but all local output, as well.

At any time, a RDPIN can be executed on the lower pin to read the current 16-bit status of the
receiver. The lower pin's IN will be raised whenever a change occurs in the receiver's status. This
will necessitate a 'AKPIN lowerpin' before IN can be raised again, to alert of the next change in
status.

NOTE that after an AKPIN, it will take five clocks for IN to drop, before it can be polled again:
    AKPIN    pin                   ' Acknowledge smart pin, releases IN from high
    WAITX    #3                    ' Elapse at least 5 clocks (WAITX takes 2 + 3)
    TESTB    INA, pin    WC        ' IN  can now be polled again

The receiver's status bits are as follows:
 [31:16] <unused>                - $0000
 [15:8]  byte                    - last byte received
 [7]     byte toggle             - cleared on SOP, toggled on each byte received
 [6]     error                   - cleared on SOP, set on bit-unstuff error, EOP SE0 > 3 bits, or SE1
 [5]     EOP in                  - cleared on SOP or 7+ bits of J or K, set on EOP
 [4]     SOP in                  - cleared on EOP or 7+ bits of J or K, set on SOP
 [3]     steady-state indicator  - cleared on line change, set on 7+ bits of no line change
 [2]     SE0 in         (RESET)  - cleared on !SE0, set on 1+ bits of SE0
 [1]     K in           (RESUME) - cleared on !K, set on 1+ bits of K
 [0]     J in           (IDLE)   - cleared on !J, set on 1+ bits of J
The result of a RDPIN can be bit-tested for events of interest. It can also be shifted right by 8
bits to LSB-justify the last byte received and get the byte toggle bit into C, in order to determine
if you have a new byte.
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
' Universal Serial Bus (USB) HID Usage Tables, Version 1.12
'   www.usb.org/developers/hidpage/Hut1_12v2.pdf
'------------------------------------------------------------------------------
}
' #endregion (Basics of P2 USB SmartPins)
' #region CON (USB Host)
con
' /* Constants specific to the development environment and P2 clock speed
' Prop123-A9 development board USER_LED*s on OUTB pins
        #32, LED0, LED1, LED2, LED3, LED4, LED5, LED6, LED7
        LED8, LED9, LED10, LED11, LED12, LED13, LED14, LED15
        #54, PB0_RESET, PB1, PB2, PB3
' USER_LEDs to show host feedback:
        HOST_WAIT_LED     = LED8                ' Blinks while waiting for device connect, stays lit while device connected
        HOST_ACTIVITY_LED = LED9                ' Blinks while in the host's main processing loop
        HOST_DEBUG_LED    = LED10               ' Host debug feedback LED
' USER_LEDs to show driver feedback:
        DRIVER_WAIT_LED   = LED12               ' Blinks while waiting for device connect, stays lit while device connected
        DRIVER_MOUSE_LED  = LED13               ' Pulses during mouse activity
        DRIVER_KBD_LED    = LED14               ' Pulses during keyboard activity
        DRIVER_DBG_LED    = LED15               ' Driver debug feedback LED
' The v11+ P2 FPGA image introduced new pin-based DIR/OUT/IN instructions that
' make pin assignment changes much easier. You should be able to use any
' adjacent even/odd pin pair for the USB data signals by changing just the
' DM/DP pin assignments.
' Smart pin pair used for the USB transceiver (Rayman's USB/uSD/Hyperram/Flash board for P123)
        DM           = 32                       ' DM is "The Brain"
        DP           = 33                       ' DP is passive
'        DM           = 0                        ' DM is "The Brain"
'        DP           = 1                        ' DP is passive
' Time units converted to clock cycles for the given P2 Mhz clock speed
'        SYSCLOCK     = 60_000_000.0
        SYSCLOCK     = 80_000_000.0
'        SYSCLOCK     = 120_000_000.0
        _12Mbps      = round((12_000_000.0 / SYSCLOCK) * 65536.0) ' = 6557 NCO @ 120Mhz, 9830 @ 80Mhz
        _1_5Mbps     = round((1_500_000.0 / SYSCLOCK) * 65536.0)  ' = 819 NCO @ 120Mhz, 1229 @ 80Mhz
        _1ms         = round(SYSCLOCK / 1_000.0)
        _1us         = round(float(_1ms) / 1_000.0)
        _100ns       = round(float(_1us) / 1_000.0 * 100.0)
        LSBTns       = 667.0                    ' Low-Speed bit period, in nanoseconds
        FSBTns       = 83.0                     ' Full-Speed bit period, in nanoseconds
        _1LSBT       = round(SYSCLOCK / 1_000_000_000.0 * LSBTns)' = 53 clocks @ 80Mhz, 80 clocks @ 120Mhz
        _1FSBT       = round(SYSCLOCK / 1_000_000_000.0 * FSBTns)' = 7 clocks @ 80Mhz, 10 clocks @ 120Mhz
' */
' /* Time delays and intervals
' Useful USB constants and wait intervals:
        CONNECT_WAIT    = _1ms * 250            ' Connect/disconnect verification delay
        RESET_HOLD      = _1ms * 15             ' Host reset state hold time
        XFER_RETRIES    = 6                     ' Maximum retries before retiring a transfer
        TXN_RETRIES     = 6                     ' Maximum retries before retiring a transaction
        NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
        IN_NAK_RETRIES  = 3000                  ' Control transfer IN-NAK retry limit (0 = unlimited)
        OUT_NAK_RETRIES = 3000                  ' Control transfer OUT-NAK retry limit (0 = unlimited)
        XFER_WAIT       = _1ms * 5              ' Transfer retry wait timespan
' Standard Device request maximum timeout periods:
        TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
        TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
        TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
        TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
        TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
'------------------------------------------------------------------------------
' Low-Speed inter-packet delay, in bit periods (Section 7.1.18). For the host,
' the range is a minimum of two bit periods and a maximum of 7.5 bit periods:
'------------------------------------------------------------------------------
        IP_DELAY_LS  = round(3.5 * LSBTns * float(_1us) / 1000.0) ' Range @80MHz: 106.7 to 400.2 clocks (1.334us to 5.003us)
        IP_DELAY_FS  = round(3.5 * FSBTns * float(_1us) / 1000.0) ' Range @80MHz: 13.3 to 49.8 clocks (0.166us to 0.623us)
'------------------------------------------------------------------------------
' End-to-end signal delay, in bit periods (Section 7.1.19), measured at the
' data pins of the device from the SE0-to-J transition at the end of the EOP.
' For example, when a device transmits the data for an IN transaction, it will
' wait at least 16 bit periods for the host handshake response, but no more
' than 18 bit periods:
'   Low-Speed:  10.672us..12.006us (@80MHz: 853.8 to 960.5 clocks).
'   Full-Speed: 1.238us..1.494us (@80MHz: 106.2 to 119.5 clocks).
' When the host transmits data e.g. an OUT transaction, it must wait at least
' 18 bit periods before it will timeout the response and start a new transaction.
'------------------------------------------------------------------------------
        TAT_WAIT_LS  = round(30.0 * LSBTns * float(_1us) / 1000.0)
        TAT_WAIT_FS  = round(100.0 * FSBTns * float(_1us) / 1000.0)
'------------------------------------------------------------------------------
' Interrupt service routine timespans for 1ms interval frame generation.
' Target resolution is 1.00ms +/- 0.0005ms. At full-speed, a numbered
' start-of-frame packet is issued. At low-speed, a single EOP is issued as a
' "keep-alive" strobe to prevent a device from entering suspend mode.
'------------------------------------------------------------------------------
        TXN_OK_ZONE  = _1us * 667               ' All USB transactions must be started within this timespan
        NO_TXN_ZONE  = _1us * 333               ' Buffer timespan zone to guarantee an in-progress transaction can complete
' Non-USB related time intervals:
        PULSE_TIME   = _1ms * 500               ' LED-blinking heartbeat interval
' */
' /* PID tokens
'------------------------------------------------------------------------------
' Token packet format.
'------------------------------------------------------------------------------
'                       CRC5  ENDP ADDRESS PID
        CRC_MASK     = %11111_0000_0000000_00000000
        EP_MASK      = %00000_1111_0000000_00000000
        ADDR_MASK    = %00000_0000_1111111_00000000
        EP_ADDR_MASK = %00000_1111_1111111_11111111
        EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
'------------------------------------------------------------------------------
' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' identical for each group.
'------------------------------------------------------------------------------
' Token:
        PID_OUT   = %1110_0001                  ' $e1
        PID_IN    = %0110_1001                  ' $69
        PID_SOF   = %1010_0101                  ' $a5
        PID_SETUP = %0010_1101                  ' $2d

' Data:
        PID_DATA0 = %1100_0011                  ' $c3
        PID_DATA1 = %0100_1011                  ' $4b
        PID_DATA2 = %1000_0111                  ' $87
        PID_MDATA = %0000_1111                  ' $0f

' Handshake:
        PID_ACK   = %1101_0010                  ' $d2
        PID_NAK   = %0101_1010                  ' $5a
        PID_STALL = %0001_1110                  ' $1e
        PID_NYET  = %1001_0110                  ' $96
' Special:
        PID_PRE   = %0011_1100                  ' $3c
        PID_ERR   = %0011_1100                  ' $3c
        PID_SPLIT = %0111_1000                  ' $78
        PID_PING  = %1011_0100                  ' $b4
        PID_RESVD = %1111_0000                  ' $f0
' */
' /* Tx, rx and host related constants
' USB transmitter WYPIN D line state options:
        OUT_IDLE = 0
        OUT_SE0  = 1
        OUT_K    = 2
        OUT_J    = 3
        OUT_EOP  = 4
        OUT_SOP  = $80
' USB receiver RDPIN status bit positions:
        #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, RXERRB, BYTE_TGLB
' USB receiver RDPIN status bitflags:
        J_IDLEF    = |< J_IDLEB
        K_RESUMEF  = |< K_RESUMEB
        SE0_RESETF = |< SE0_RESETB
        SE1_BADF   = |< SE1_BADB
        SOPF       = |< SOPB
        EOPF       = |< EOPB
        RXERRF     = |< RXERRB
        BYTE_TGLF  = |< BYTE_TGLB
' USB CRC constants:
        USB5_POLY      = %0_0101 >< 5           ' USB5 polynomial is reflected when calculating CRC
        USB5_RESIDUAL  = %0_1100 >< 5           ' Expected CRC5 residual value when checking received data
        USB16_POLY     = $8005 >< 16            ' USB16 polynomial is reflected when calculating CRC
        USB16_RESIDUAL = $800d >< 16            ' Expected CRC16 residual value when checking received data
' Host->class driver USB connect speed:
        #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
' Protocol error codes:
        #0, ERR_NONE, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY, ERR_XFER_RETRY
        ERR_NAK, ERR_ACK_RETRY, ERR_EMPTY_PKT, ERR_CRC, ERR_END
' Debug stuff:
        DBG_FEEDBEEF = $efbeedfe                ' Handy byte sequence for hex search in .obj files
        DBG_DEADC0DE = $dec0adde                ' End of code/data marker
' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
        #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB, TXN_LIMITB '[2], ERRORB
' Host status bitflags. Unless otherwise noted, bit states are active high:
        IDLEF      = |< IDLEB                   ' Set when USB in idle state
        CONNECTEDF = |< CONNECTEDB              ' USB device connected
        LOW_SPEEDF = |< LOW_SPEEDB              ' Low-speed device connected, clear if full-speed
        DATAx_TGLF = |< DATAx_TGLB              ' Cleared if sending DATA0 packet, set if sending DATA1 packet
        TXN_LIMITF = |< TXN_LIMITB              ' No-go area to prevent transactions from spanning frame boundary
'       EOPF       = |< EOPB                    ' Same bit position as the USB receiver RDPIN constant defined above
'       RXERRF     = |< RXERRB                  ' Same bit position as the USB receiver RDPIN constant defined above
'       BYTE_TGLF  = |< BYTE_TGLB               ' Same bit position as the USB receiver RDPIN constant defined above
' */
' /* LUT allocation:
'------------------------------------------------------------------------------
' LUT sharing between the host cog and the class driver cog is enabled. There
' is no address partitioning, so both cogs must be aware of all LUT address
' ranges that are in use. The host cog and class driver cogIDs must be an
' adjacent even/odd pair.
'------------------------------------------------------------------------------
' Host cog LUT locations shared with the class driver cog:
        LSHARE_BASE = H_EVENT - 6       ' Base LUT location for command/request processing via LUT sharing
        #LSHARE_BASE                    ' Locate shared LUT cells at the top of the LUT space
        H_PAR1, H_PAR2, H_PAR3
        D_PAR1, D_PAR2, D_PAR3
'------------------------------------------------------------------------------
' LUT locations tied to selectable-events (changed in P2v11+).
'------------------------------------------------------------------------------
        H_EVENT       = $1fc            ' Class driver cog writes to this host LUT address
        H_EVENT_WR1FC = %000_00_1100    ' Setup bits for host POLLSE1/WAITSE1 selectable-event
        D_EVENT       = $1fd            ' Host driver cog writes to this class driver LUT address
        D_EVENT_WR1FD = %000_00_1101    ' Setup bits for class driver POLLSE1/WAITSE1 selectable-event
' Bits used in SETWRL/SETRDL setup:
        LSHARE_READ   = 0               ' The other cog can read this LUT
        LSHARE_WRITE  = 1               ' The other cog can write this LUT
' LUT locations < 256 are available to the class driver, if needed.
'------------------------------------------------------------------------------
' USB I/O request events from the class driver that are recognized by the host
' cog. At this time there is no event queueing, so the class driver must
' poll/wait until for the host driver to post H_READY before it can post a new
' event. The event mechanism is asynchronous. It works, but the implementation
' in its current form is somewhat clumsy. For both cogs, a POLLSE1 event is
' triggered when its odd/even partner posts an eventID to its assigned LUT
' location.
'
' When the class driver posts a USB I/O request to the host's eventID LUT
' location, the transaction is not considered to be complete until the host
' posts a DTXN_RESULT event to the class driver. The event parameters contain
' the transaction type executed and its result code. Since all event postings
' are asynchronous, the class driver assigns the address of a routine that
' understands the context of the posted IRP, making a fairly simple callback
' mechanism to handle the IRP result.
'------------------------------------------------------------------------------
'       Class Driver->Host        H_PAR1        H_PAR2          H_PAR3          Description
        #0, H_READY             ' n/a           n/a             n/a             Host ready to process event
        HCTRL_READ              ' ctrlep/addr   SETUP addr      IN data addr    ControlRead()
        HCTRL_WRITE             ' ctrlep/addr   SETUP addr      OUT data addr   ControlWrite()
        HINT_IN                 ' epN/addr      IN data addr    max_pkt|DATAx   InterruptIN(), word1 max_pkt, word0 DATAx to expect
        HINT_OUT                ' epN/addr      OUT data addr   pkt_len|DATAx   InterruptOUT(), word1 pkt_len, word0 DATAx to tx
' Last event in the jump table, useful when testing/debugging:
        H_END = HINT_IN
'------------------------------------------------------------------------------
' Events recognized by the class driver cog. At this time there is no event
' queueing, The host must poll/wait for the class driver to post D_READY before
' it can post a new event. These events don't require a post-event response to
' the host, so they are implemented as a jump table.
'------------------------------------------------------------------------------
'       Host->Class Driver        D_PAR1        D_PAR2          D_PAR3          Description
        #0, D_READY             ' n/a           n/a             n/a             Driver ready to process event
        DREQ_ASCIIZ             ' ASCIIZ addr   n/a             n/a             Output zero-terminated string at addr
        DREQ_BREAK              ' debug long    n/a             n/a             Debug breakpoint (host and driver halt)
        DREQ_DBG_DATA           ' debug long    n/a             n/a             Arbitrary debug value (host and driver continue)
        DREQ_HEXDUMP            ' buff addr     data len        n/a             Data hexdump
        DINF_CONNECT            ' speed         n/a             n/a             Device connected, not yet configured, at given speed
        DINF_DISCONNECT         ' ctrlep/addr   n/a             n/a             Device at ep0/addr disconnected
        DINF_DEV_DESC           ' ctrlep/addr   buff addr       n/a             Device descriptor available at buff_addr
        DINF_CON_DESC           ' ctrlep/addr   buff addr       n/a             Configuration descriptor available at buff addr
'------------------------------------------------------------------------------
' The below event is posted by the host to notify the class driver that the
' USB I/O request event that had been previously posted by the class driver has
' completed. If the result is an error that the class driver cannot recover
' from, it should put itself into an idle state.
'------------------------------------------------------------------------------
        DTXN_RESULT
' Control transfer result:      ' CRC/ep/addr   overall result  context result
' IN transaction result:        ' CRC/ep/addr   result code     rxBytes
'------------------------------------------------------------------------------
' The below event is a mechanism the host cog can use to notify the class
' driver (or end user) that the host has completed a USB I/O action that was
' NOT requested by the class driver. In general, if the result code is not
' "ACK", it is likely that the host has encountered an error that it could not
' recover from, and it has entered an idle state. Given this, the class driver
' routine that processes this event will send the result details to the
' terminal and put itself into an idle state also.
'
' NOTE: once the class driver has configured the device and is issueing USB
' I/O requests, this event should no longer be used, as the host reports I/O
' results through the above DTXN_RESULT event.
'------------------------------------------------------------------------------
        DTXN_HRESULT            ' ASCIIZ addr   result code     n/a             Addr of result description string, ACK/NAK/STALL result code
'------------------------------------------------------------------------------
' Last event in the jump table, useful when testing/debugging:
        D_END = DTXN_HRESULT
' */
' #endregion CON (USB Host)
' #region DAT (Host Cog)
'------------------------------------------------------------------------------
' USB host cog.
'------------------------------------------------------------------------------
dat
                orgh
                alignl
                org
usb_host
                cogid   hr0                             ' Get this cogID
                testb   hr0, #0                 wc      ' Find whether we're the even or odd cogID of the pair
        if_c    coginit hr0, ##@hid_driver              ' C = 1 is the odd cog, so load the USB driver code and restart ourself
                ' C = 0, so we are the host cog and fall through
' /* usb_host_start
'------------------------------------------------------------------------------
' The USB host cog.
'------------------------------------------------------------------------------
usb_host_start
                drvh    #LED2
'                call    #load_host_lut                  ' Host & driver LUT space is shared. The driver cog owns cells 0..255, the host owns cells 256..511
                waitx   ##_1ms * 5000                   ' Delay to allow time for the driver and serial output to start
                fltl    #LED2                           ' DEBUG
                setluts #LSHARE_WRITE                   ' Allow class driver cog to write this LUT
                setse1  #H_EVENT_WR1FC                  ' Class driver write to LUT location H_EVENT triggers this event
                mov     ijmp1, #isr1_frame              ' Set the USB 1ms frame handler ISR routine
                jmp     #host_reset                     ' Initialize host and enter main processing loop
' */
' /* do_hevent
'------------------------------------------------------------------------------
' Handler jump table for events posted to the host by the class driver cog.
'------------------------------------------------------------------------------
do_hevent
                rdlut   hevent, #H_EVENT
                fle     hevent, #H_END
                push    #end_hevent                     ' All jump table entries are CALL targets
                mov     context_retval, #ERR_NONE       ' Assume overall operation success
                jmprel  hevent
hevent_jmp
                ret                                     ' EventID zero is a NOP
                jmp     #do_ctrl_read
                jmp     #do_ctrl_write
                jmp     #do_int_in
                jmp     #do_int_out
end_hevent
        _ret_   wrlut   #H_READY, #H_EVENT              ' Ready for next event posting
' */
' /* post_devent
'------------------------------------------------------------------------------
' Post an eventID to be handled by the class driver cog.
'------------------------------------------------------------------------------
' On entry: Reg hevent: eventID to post.
'           Regs hpar1, hpar2, hpar3: eventID parameters, if needed.
' On exit:
'------------------------------------------------------------------------------
post_devent
                rdlut   htmp, #D_EVENT          wz      ' Wait for any pending class driver event to complete
        if_nz   jmp     #post_devent
                wrlut   hpar1, #D_PAR1
                wrlut   hpar2, #D_PAR2
                wrlut   hpar3, #D_PAR3
        _ret_   wrlut   hevent, #D_EVENT                ' This driver LUT location is the write event trigger for the event request
' */
' /* control_read
'------------------------------------------------------------------------------
' Perform a control read transaction (Section 8.5.3, Figure 8-37).
' Status reporting is always in the function-to-host direction.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: start address of the SETUP data in hub.
'           Reg PB: start address of the buffer/struct to be written to
'           during the IN data stage.
'           Reg ep_addr_pid: device address, endpoint and CRC5.
' On exit:  Reg retval: PID_ACK on success, otherwise error. If successful,
'           reg total_data contains the count of data stage bytes actually
'           received, which must always be <= the count requested.
'           Reg context_retval: ERR_NONE if the overall transfer succeeds,
'           otherwise a more specific USB operation error code.
'------------------------------------------------------------------------------
control_read
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                mov     nak_retry, ##IN_NAK_RETRIES
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
.nak_retry
                mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
.in_retry
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' Commit on ACK
        if_z    jmp     #.commit
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.nak_retry                     ' Function not ready to send data
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.in_retry                      ' Bus error retry
                ret                                     ' The transfer has failed
.commit
                cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
        if_z    jmp     #.pre_status                    ' and also end-of-data
                loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest struct
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
                add     stage_data, pkt_cnt             ' Update bytes received on commit
                cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
        if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
                cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
        if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
        if_a    mov     retval, #ERR_PACKET
        if_a    mov     context_retval, retval          ' In this case overall and context are the same
        if_a    ret                                     ' Caller must handle ERR_PACKET
                bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
                jmp     #.data                          ' Start next IN transaction
.pre_status
                mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
                setbyte ep_addr_pid, #PID_OUT, #0
                mov     pkt_data, #0
                bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
                mov     nak_retry, ##OUT_NAK_RETRIES
.out_retry
                call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
                cmp     retval, #PID_ACK        wz
        if_z    ret                                     ' All is good when ACK
                cmp     retval, #PID_STALL      wz
        if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.out_retry                     ' Function not ready so resend status result
                cmp     retval, #ERR_NAK        wz
        if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
                ret                                     ' Caller must handle transfer retirement
' I've encountered transfer STALL, even though the data looks correct, and
' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
' ControlRead() transfer gets things unstuck most of the time...
.xfer_retry
                mov     hctwait, ##XFER_WAIT
                call    #poll_waitx
                call    #wait_txn_ok
                mov     ep_addr_pid, hpar1
                mov     ptra, hpar2
                mov     pb, hpar3
                djnz    xfer_retry, #.xfer_start
                mov     context_retval, retval          ' Preserve the USB error code
        _ret_   mov     retval, #ERR_XFER_RETRY
' */
' /* control_write
'------------------------------------------------------------------------------
' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
' reporting is always in the function-to-host direction. It is assumed that
' the SETUP data struct is filled with the required values.
'------------------------------------------------------------------------------
' On entry: Reg PTRA points to the start of the struct for the SETUP data.
'           Reg PB has the start address of the struct/buffer to be read for
'           the OUT data stage.
'           Reg ep_addr_pid has the proper CRC'd address and endpoint to use.
' On exit:  Reg retval is used to convey the success/failure of each stage.
'           Reg context_retval: ERR_NONE if the overall transfer succeeds,
'           otherwise a more specific USB operation error code.
'------------------------------------------------------------------------------
control_write
                mov     hpar1, ep_addr_pid
                mov     hpar2, ptra
                mov     hpar3, pb
                mov     xfer_retry, #XFER_RETRIES
.xfer_start
                mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
                rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
                call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to caller to handle error
                cmp     total_data, #0          wz
        if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
                mov     stage_data, #0                  ' Prepare for data stage
                setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
                bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.data
                mov     pkt_data, total_data
                sub     pkt_data, stage_data
                cmp     pkt_data, max_pkt_size  wcz
        if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
.out_retry
                mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
                call    #txn_out
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit                        ' Function got the data
                call    #retry_wait                     ' Wait a bit before retry
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.out_retry                     ' In this context, NAK gets unlimited retries
                cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
        if_nz   jmp     #.out_retry
                ret                                     ' Caller must handle transfer retirement
.commit
                mov     pb, ptra                        ' Save the current buffer/struct location
                add     stage_data, pkt_data
                cmp     stage_data, total_data  wz
        if_nz   bitnot  hstatus, #DATAX_TGLB            ' Toggle DATAx sync bit
        if_nz   jmp     #.data                          ' More data to send
pre_status_in
                bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
                mov     retry, #TXN_RETRIES             ' Reset txn retry limit
.status_retry
                mov     pkt_data, #0
                call    #txn_in
                cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
        if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
        if_z    ret                                     ' Control Write finished
                call    #retry_wait                     ' NAK or bus error, so delay a bit
                cmp     retval, #PID_NAK        wz
        if_z    jmp     #.status_retry                  ' FIXME: should probably have a NAK limit here?
                cmp     retval, #ERR_TXN_RETRY  wz
        if_nz   jmp     #.status_retry
                ret                                     ' Caller must handle transfer retirement
' */
' /* txn_setup
'------------------------------------------------------------------------------
' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
' special because the receiving function must not respond with either STALL or
' NAK, and must accept the DATAx packet that follows the SETUP token. If a
' non-control endpoint receives a SETUP token, or the function receives a
' corrupt packet, it must ignore the transaction
'------------------------------------------------------------------------------
' On entry: Reg PTRA: start address of the SETUP data struct.
' On exit:  Reg retval: PID_ACK on success, otherwise error code.
'------------------------------------------------------------------------------
txn_setup
                setbyte ep_addr_pid, #PID_SETUP, #0
                mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
                bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
                mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
                mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
.setup
                call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
                cmp     retval, #PID_ACK        wz
        if_z    ret
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    ret
                mov     ptra, pa                        ' Restore SETUP's DATAx pointer
                jmp     #.setup
' */
' /* txn_in
'------------------------------------------------------------------------------
' IN/INTERRUPT transaction.
' Possible function response: STALL or NAK handshake, or DATAx packet.
'------------------------------------------------------------------------------
' On entry: Reg ep_addr_pid: PID_IN(b0..7), address(b8..b14),
'           endpoint(b15..18) and CRC(b19..23).
' On exit:
'------------------------------------------------------------------------------
txn_in
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                setbyte ep_addr_pid, #PID_IN, #0
                wrfast  #0, ##urx_buff                  ' Use hub RAM FIFO interface to buffer bytes received
                call    #utx_token                      ' Put IN request on the bus
' Fall through to urx_packet
' vvvvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* urx_packet
'------------------------------------------------------------------------------
' Wait for a packet from a device/function. As host, the only two packet types
' received are handshakes and DATAx.
'------------------------------------------------------------------------------
' On entry: The routine waits until the USB is idle.
' On exit:  Reg retval: the ID of the packet. If a PID fails validation,
'           ERR_PACKET is returned.
'------------------------------------------------------------------------------
urx_packet
                rqpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #urx_packet
                getct   hct2
                addct2  hct2, tat_wait                  ' Start the response turn-around timer
                bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
                mov     newb_flg, #0                    ' Initialize for multi-byte read
.wait_sop
                rdpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #.get_pid
                jnct2   #.wait_sop
        _ret_   mov     retval, #ERR_TAT
.get_pid
                call    #urx_next
                testb   urx, #RXERRB            wc
        if_nc   jmp     #.chk_pid
        _ret_   mov     retval, #ERR_URX
.chk_pid
                cmp     retval, #PID_ACK        wz
        if_nz   cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
                testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
                cmp     retval, #PID_DATA0      wz
   if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
   if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the function must have missed
                cmp     retval, #PID_DATA1      wz
   if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
   if_z_and_nc  jmp     #.ack_resend
        _ret_   mov     retval, #ERR_PACKET
.ack_resend
                rqpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #.ack_resend
                mov     hctwait, ip_delay
                call    #poll_waitx
                mov     retval, #PID_ACK
                jmp     #utx_handshake                  ' Send handshake PID and return to caller
.chk_eop
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.idle                          ' FIXME: this may change with FS at > 80MHz
                call    #urx_next                       ' Low-speed requires an additional read to get EOP status
                testb   hstatus, #EOPB          wc
        if_c    jmp     #.idle                          ' Low-speed EOP seen
                testb   urx, #RXERRB            wz
        if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
        if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
                ret
.idle
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                ret
' */
' /* utx_token
'------------------------------------------------------------------------------
' Send a token packet with CRC5 checksum of address and endpoint. It is the
' responsibility of the caller to append the appropriate inter-packet delay,
' if one is required.
'------------------------------------------------------------------------------
' On entry: Reg ep_addr_pid: packed with the PID, address and endpoint.
' On exit:
'------------------------------------------------------------------------------
utx_token
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     htmp, ep_addr_pid               ' Preserve the PID and destination
                mov     pkt_cnt, #3
.next_byte
                getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
                shr     htmp, #8                        ' Shift to next byte to send
.wait
                testp   #DP                     wc
        if_nc   jmp     #.wait
                akpin   #DP
                wypin   utx, #DM
                djnz    pkt_cnt, #.next_byte
                ret
' */
' /* txn_out
'------------------------------------------------------------------------------
' SETUP/OUT/INTERRUPT transaction.
' Possible function response in order of precedence: STALL, ACK, NAK.
'------------------------------------------------------------------------------
' On entry: Reg ep_addr_pid: PID_OUT(b0..7), address(b8..b14),
'           endpoint(b15..18) and CRC(b19..23).
'           Reg PTRA: start address of the data buff/struct that has the bytes
'           to send.
'           Reg pkt_data: count of DATAx payload bytes to send.
' On exit:
'------------------------------------------------------------------------------
txn_out
                call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
                rdfast  #0, ptra                        ' Use hub RAM FIFO interface to read the tx buffer
                call    #utx_token                      ' Put SETUP/OUT token on the bus
                mov     pkt_cnt, pkt_data
                mov     hctwait, ip_delay
                call    #poll_waitx
' Fall through to utx_data
' vvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* utx_data
'------------------------------------------------------------------------------
' Transmit a DATAx packet with CRC16 checksum of payload. The packet CRC is
' calculated using Ariba's pre-calculated CRC16 table. Since data stage
' success/fail is not determined until the status stage of the transaction,
' this routine is only concerned about the current DATAx packet.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: hub start address of the data to read.
'           Reg pkt_cnt: data payload size.
' On exit:
'------------------------------------------------------------------------------
utx_data
                rqpin   urx, #DM
                testb   urx, #SOPB              wc
        if_c    jmp     #utx_data
                mov     hctwait, ip_delay
                call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     crc, ##$ffff                    ' Prime the CRC16 pump
                testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
        if_nc   mov     utx, #PID_DATA0
        if_c    mov     utx, #PID_DATA1
                call    #utx_byte                       ' No CRC calc done on PID
                cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
        if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
.read_byte
                rfbyte  utx
' In-line tx for max speed
.txwait
                testp   #DP                     wc
        if_nc   jmp     #.txwait
                akpin   #DP
                wypin   utx, #DM                        ' Data byte to the smartpins for transmit
' End tx in-line
                rev     utx                             ' Calculate CRC while the data is shifting out
                setq    utx                             ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
                djnz    pkt_cnt, #.read_byte
.send_crc
                xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
                getbyte utx, crc, #0
                call    #utx_byte
                getbyte utx, crc, #1
                call    #utx_byte                       ' Last CRC byte out
                jmp     #urx_packet                     ' Handle function response/error and back to caller
' */
' /* urx_data
'------------------------------------------------------------------------------
' Receive a DATAx_ payload with CRC16 checksum. The CRC is calculated using
' Ariba's pre-calculated CRC16 table. The routine reads bytes until EOP is
' detected, and expects the payload to include at least the CRC16 word.
'
' In control transfers, it's possible to recieve fewer data bytes than what
' was requested, which makes it difficult to determine where the data stops
' and the CRC word begins. So the CRC calculation is done on every byte of the
' packet, including the CRC word. The CRC value should then be equal to the
' USB-16 expected residual value of 0xB001.
'
' The routine writes the IN packet data to a static max_packet_size buffer
' so the caller can verify IN success before writing the data to its final
' destination.
'------------------------------------------------------------------------------
' On entry: Reg pkt_data: max byte count expected to be in the packet.
'           Reg newb_flg: signals new byte ready when toggled.
' On exit:  Reg pkt_cnt: actual number of bytes read.
'------------------------------------------------------------------------------
urx_data
                mov     crc, ##$ffff                    ' Prime the CRC16 pump
                mov     pkt_cnt, #0                     ' Keep track of payload bytes received
                mov     pkt_tmp, pkt_data
                add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
.wait_byte
' In-line rx for max speed
                rqpin   urx, #DM
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   jmp     #.get_byte                      ' New byte!
                testb   urx, #EOPB              wc
        if_c    jmp     #.chk_crc                       ' At end-of-packet
                jmp     #.wait_byte
.get_byte
                getbyte retval, urx, #1                 ' Fetch the new byte from smartpins
                wfbyte  retval                          ' and add it to the data buffer
                rev     retval                          ' Calculate CRC while next byte is shifting in
                setq    retval                          ' SETQ left-justifies the reflected data byte
                crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
                crcnib  crc, ##USB16_POLY
.end_crc
                add     pkt_cnt, #1
                cmp     pkt_cnt, pkt_tmp        wcz
        if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
        if_a    ret
' For full-speed at 80MHz, the time it takes to do the final byte write and
' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
' to miss it, so cheat a bit and look for SOP clear here.
                rqpin   urx, #DM
                testb   urx, #SOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
        if_c    jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
.chk_crc
                sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
                xor     crc, ##USB16_RESIDUAL           ' CRC of (data + transmitted CRC) XOR residual should equal zero
                tjz     crc, #.ack                      ' If we jump, the CRCs matched
        _ret_   mov     retval, #ERR_CRC
.ack
                mov     retval, #PID_ACK
                testb   hstatus, #LOW_SPEEDB    wc      ' FIXME: only insert ip delay when low-speed
        if_nc   jmp     #utx_handshake                  ' FIXME: ip delay for full-speed will be needed when > 80MHz
                mov     hctwait, ip_delay
                call    #poll_waitx
' Fall through to utx_handshake
' vvvvvvvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* utx_handshake
'------------------------------------------------------------------------------
' Transmit a handshake PID. The routine assumes that the bus is IDLE and
' the appropriate IP delay has been inserted.
'------------------------------------------------------------------------------
' On entry: Reg retval: handshake PID to send.
' On exit:  Reg retval unchanged.
'------------------------------------------------------------------------------
utx_handshake
                testp   #DP                     wc
        if_nc   jmp     #utx_handshake
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync
                mov     utx, retval
                call    #utx_byte                       ' Send handshake PID
.idle
                rqpin   urx, #DM
                testb   urx, #J_IDLEB           wc
        if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
                mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
                jmp     #poll_waitx
' */
' /* utx_byte
'------------------------------------------------------------------------------
' Move a data byte or line state command to the smart pin tx buffer.
'------------------------------------------------------------------------------
' On entry: Reg utx: byte to transmit.
' On exit:
'------------------------------------------------------------------------------
utx_byte
                testp   #DP                     wc
        if_nc   jmp     #utx_byte
                akpin   #DP
        _ret_   wypin   utx, #DM
' */
' /* urx_next
'------------------------------------------------------------------------------
' Fetch the next data byte of a packet. Always check receiver status for EOP.
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg retval: the byte read.
'           Reg urx contains the receiver status. The caller must check the
'           hstatus reg EOP flag on return. If EOP is set, the byte in reg
'           retval remains as the last byte received.
'------------------------------------------------------------------------------
urx_next
                rdpin   urx, #DM
                mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
                and     utx, urx
                cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
        if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
        if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
        if_nz   ret                                     ' New byte is priority, so return now
                testb   urx, #EOPB              wc
                testb   urx, #RXERRB            wz
  if_nc_and_nz  jmp     #urx_next                       ' If SOP still raised and !RXERRB a new byte should be coming
        if_c    bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
                ret
' */
' /* poll_waitx
'------------------------------------------------------------------------------
' The one millisecond frame timer is implemented as an interrupt service
' routine. Since this timing is critical, care must be taken to avoid any
' instructions that can delay the interrupt branch, which will likely upset
' the timer. WAITX is among those instructions, so any time you're inside
' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'------------------------------------------------------------------------------
' On entry: Reg hctwait: wait interval in sysclocks.
' On exit:
'------------------------------------------------------------------------------
poll_waitx
                getct   hct2
                addct2  hct2, hctwait
.wait
                jnct2   #.wait
                ret
' */
' /* wait_txn_ok
'------------------------------------------------------------------------------
' Wait for a window within the 1ms frame boundary that will ensure that a
' transaction can complete without spanning the frame.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
wait_txn_ok
                testb   hstatus, #TXN_LIMITB    wc
        if_c    jmp     #wait_txn_ok                    ' In "no transaction" zone, so wait for the next frame
                ret                                     ' In the "transaction OK" zone, so good to go
' */
' /* wait_sof
{
wait_sof
                waitint                                 ' Wait for the start-of-frame interrupt
                testb   hstatus, #TXN_LIMITB    wc
        if_nc   ret
                jmp     #wait_sof
}
' */
' /* isr1_frame
'------------------------------------------------------------------------------
' Full-speed/low-speed frame timing interrupt service routine.
'------------------------------------------------------------------------------
isr1_frame
                testb   hstatus, #TXN_LIMITB    wc
        if_nc   jmp     #.no_txn_zone                   ' Timer "txn OK" expired, go set "no txn" timer
                addct1  hct1, ##TXN_OK_ZONE - 6         ' Refresh the "txn OK zone" timespan
                testb   hstatus, #LOW_SPEEDB    wc
        if_nc   jmp     #.fullspeed
                mov     utx, #OUT_EOP                   ' Timer "no txn" expired, so it's end-of-frame
                call    #utx_byte                       ' EOP is the low-speed keep-alive strobe
                mov     isr_tmp, ip_delay               ' Normal inter-packet delay works when low-speed
                jmp     #.wait
.fullspeed
                mov     utx, #OUT_SOP
                call    #utx_byte                       ' Send sync byte
                mov     icrc, #$1f                      ' Prime the CRC5 pump
                mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
                rev     sof_pkt                         ' Input data reflected
                mov     utx, #PID_SOF
                call    #utx_byte                       ' Send token PID byte
                setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
                crcnib  icrc, #USB5_POLY
                crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
                getbyte utx, frame, #0                  ' Send the low byte of the frame number
                call    #utx_byte
                shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
                rep     #2, #3                          ' Three data bits left to process
                shl     sof_pkt, #1             wc
                crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
                xor     icrc, #$1f                      ' Final XOR value
                getbyte utx, frame, #1                  ' Send remaining frame number bits
                shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
                or      utx, icrc
                call    #utx_byte                       ' Last start-of-frame byte is on the wire
                mov     isr_tmp, ##IP_DELAY_FS * 2      ' Use 2x normal inter-packet delay when full-speed
.wait
                rqpin   utx, #DM
                testb   utx, #SOPB              wc
        if_c    jmp     #.wait
                waitx   isr_tmp                         ' Make sure bus is idle before 
                add     frame, #1                       ' Calculate number for next frame
                and     frame, ##$7ff
                bitl    hstatus, #TXN_LIMITB            ' Bus ready for traffic
                reti1
.no_txn_zone
                addct1  hct1, ##NO_TXN_ZONE - 7         ' Refresh the "no txn zone" timespan
                bith    hstatus, #TXN_LIMITB
                reti1
' */
' /* hmemcpy
'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: source address.
'           Reg PB: destination address.
'           Reg hr0: length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
hmemcpy
                rdbyte  htmp, ptra++
                wrbyte  htmp, pb
                add     pb, #1
                djnz    hr0, #hmemcpy
                ret
' */
' /* memset
'------------------------------------------------------------------------------
' Write a single byte value to sequential hub memory locations.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: start address.
'           Reg hr0: length of the memory block, in bytes.
'           Reg hr1: byte value to write.
' On exit:
'------------------------------------------------------------------------------
memset
                wrbyte  hr1, ptra++
                djnz    hr0, #memset
                ret
' */
' /* Host common registers
hreg_init_start
hr0             long    0                               ' Multi-purpose registers
hr1             long    0
hpar1           long    0                               ' Routine entry/exit parameters
hpar2           long    0
hpar3           long    0
hct1            long    0                               ' Timer for the 1ms frame generator interrupt service routine
hct2            long    0                               ' Function response bus turn-around timer
hct3            long    0                               ' DEBUG: used to do the blinky thing on Prop123-A9 USER_LEDs
hstatus         long    0                               ' Host status flags
hctwait         long    0                               ' Poll-based wait clocks
ip_delay        long    0                               ' Inter-packet delay in bit periods for connected device speed
tat_wait        long    0                               ' Maximum bus turn-around time in bit periods for connected device speed
nak_retry       long    0                               ' NAK retry count, unlimited retries if zero
xfer_retry      long    0                               ' Control transfer retry count
retry           long    0                               ' Transaction retry count
utx             long    0                               ' Byte to transmit on USB
urx             long    0                               ' Written by ISR only. LSByte receiver status flags, MSByte received data
newb_flg        long    0                               ' Receive "new byte" bit toggle detector
hevent          long    0                               ' Command/request eventID posted by the driver cog
max_pkt_size    long    0                               ' Maximum payload bytes allowed, likely to change on device connect.
total_data      long    0                               ' Total bytes to tx/rx in a transfer data stage
stage_data      long    0                               ' Count of bytes sent/received so far during a data stage.
pkt_data        long    0                               ' Payload size of an OUT packet or bytes received on IN
frame           long    0                               ' USB 1ms frame counter value
sof_pkt         long    0                               ' ISR frame# packet and CRC5
icrc            long    0                               ' Only used by the 1ms frame output ISR routine
pkt_cnt         long    0                               ' Count of DATAx packet payload bytes
dbgc            long    0                               ' Debug count/index
crc             long    0                               ' Used for CRC16 calculation
ep_addr_pid     long    0                               ' Endpoint and device addresses for connected device
retval          long    0                               ' Global success/fail return parameter
context_retval  long    0                               ' Operation contextual return parameter
htmp            long    0                               ' Scratch registers whose context remains within the same code block
isr_tmp         long    0
pkt_tmp         long    0                               ' Tmp storage for routines that deal with datax packets
hreg_init_end
                long    DBG_FEEDBEEF                    ' End of used cog space marker
                long    -1[$1f0 - $]                    ' Fill remaining free cog space with $FFs
                fit     $1f0
' */
' #endregion DAT (Host Cog)
' #region (Boot Protocol Mouse/Keyboard Hub Interface)
con
'------------------------------------------------------------------------------
' Refrence: Device Class Definition for Human Interace Devices (HID), v1.11,
' Appendix B: Boot Interface.
'------------------------------------------------------------------------------
' Boot protocol mouse constants:
'------------------------------------------------------------------------------
' Mouse button bit assignments (left, right, center):
        #0, MOUSE_LBTNB, MOUSE_RBTNB, MOUSE_CBTNB       ' Button bits 3..7 device specific
' Mouse button bitflags:
        MOUSE_LBTNF     = |< MOUSE_LBTNB
        MOUSE_RBTNF     = |< MOUSE_RBTNB
        MOUSE_CBTNF     = |< MOUSE_CBTNB
'------------------------------------------------------------------------------
' The mouse data should be treated as read-only.
' Whenever the driver processes a mouse event, it will refresh the mouse
' position/button data and increment the mouse_count location. The client
' should poll this location to determine when to read new data.
'------------------------------------------------------------------------------
dat
                orgh

mouse_count     long    0                               ' Count is incremented at every mouse event posted by the driver
mouse_x         long    0                               ' Signed X displacement min -127, max 127
mouse_y         long    0                               ' Signed Y displacement min -127, max 127
mouse_btnflgs   long    0                               ' See above "Mouse button bit assignments" constants

con
'------------------------------------------------------------------------------
' Boot protocol keyboard constants:
'------------------------------------------------------------------------------
' Keyboard LED output report toggle key bit postions:
        #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
        LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
' Keyboard LED output report toggle key bitflags:
        LED_NUMLKF   = |< LED_NUMLKB
        LED_CAPSLKF  = |< LED_CAPSLKB
        LED_SCRLKF   = |< LED_SCRLKB
        LED_COMPOSEF = |< LED_COMPOSEB
        LED_KANAF    = |< LED_KANAB
        LED_CONST0F  = |< LED_CONST0B
        LED_CONST1F  = |< LED_CONST1B
        LED_CONST2F  = |< LED_CONST2B
' Keyboard modifier key bit positions:
        #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
        RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
' Keyboard modifier bitflags
        LEFT_CTRLF   = |< LEFT_CTRLB
        LEFT_SHIFTF  = |< LEFT_SHIFTB
        LEFT_ALTF    = |< LEFT_ALTB
        LEFT_GUIF    = |< LEFT_GUIB
        RIGHT_CTRLF  = |< RIGHT_CTRLB
        RIGHT_SHIFTF = |< RIGHT_SHIFTB
        RIGHT_ALTF   = |< RIGHT_ALTB
        RIGHT_GUIF   = |< RIGHT_GUIB
' Keyboard modifier flag combinations:
        KEY_SHIFT = LEFT_SHIFTF | RIGHT_SHIFTF
        KEY_ALT   = LEFT_ALTF | RIGHT_ALTF
'------------------------------------------------------------------------------
' The keyboard data should be treated as read-only.
' Whenever the driver processes a keyboard event, it will refresh the keyboard
' key/flags data and increment kbd_count location. The client should poll this
' location to determine when to read new data.
' FIXME: Need a real keypress buffer...
'------------------------------------------------------------------------------
dat
                orgh

kbd_count       long    0                               ' Count is incremented at every keyboard event posted by the driver
kbd_keypress    long    0                               ' ASCII keycode of keypress
kbd_modkeys     long    0                               ' See above "Keyboard modifier key bit positions" constants
kbd_ledstate    long    0                               ' See above "Keyboard LED output report toggle key bit postions" constants
' #endregion DAT (Boot protocol mouse/keyboard hub interface)
' #region DAT (Host HubExec)
' /* usb_start
'------------------------------------------------------------------------------
' Subroutine to start the USB host/driver by using the COGINIT option to locate
' and start an unused even/odd cog pair.
' README: Call this subroutine to start the USB host and device driver code
' from your program. THIS ROUTINE ALTERS THE CONTENT OF THE PA REGISTER.
'------------------------------------------------------------------------------
' On entry:
' On exit:  PA register set to zero on success, non-zero if COGINIT error.
'------------------------------------------------------------------------------
dat
                orgh
                alignl
usb_start
                mov     pa, #%0_1_0001                  ' COGINIT option to find even/odd stopped/unallocated cog pair
                coginit pa, ##@usb_host         wc
        if_nc   mov     pa, #0                          ' Clear PA to signal COGINIT success
                ret
' */
' /* host_reset
host_reset
                setint1 #0
                drvl    #DP
                drvl    #DM
                wrpin   #0, #DP                         ' Disable smart pins
                wrpin   #0, #DM
                waitx   #100
                fltl    #DP                             ' Passively read DP and DM lines
                fltl    #DM
                mov     pa, #hreg_init_start            ' Reset all host common registers
.loop
                altd    pa
                mov     0-0, #0
                add     pa, #1
                cmp     pa, #hreg_init_end      wz
        if_nz   jmp     #.loop
                loc     ptra, #@cache_start             ' Clear the USB descriptor buffer area
                mov     hr0, ##cache_end
                sub     hr0, ptra
                mov     hr1, #0                         ' Clear the host request result cache in hub RAM
                call    #memset                         ' memset(PTRA, hr0, hr1)
                wrlut   #H_READY, #H_EVENT
                call    #hpulse_led                     ' DEBUG: initialize the host connect wait loop blinking LED
'-----------------------------------------------------------------------------------------------------------------
' Device connect handling (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
' The smart pin transceiver is not configured at this stage. The 15K pull-down resistors on D+ and D- allow the
' host to passively monitor the bus lines while waiting for a device to connect (Section 7.1.7.3).
'-----------------------------------------------------------------------------------------------------------------
disconnected
                pollct3                         wc
        if_c    call    #hpulse_led                     ' Toggle the host wait for connect USER_LED
                testp   #DP                     wc      ' Wait for rise of DP or DM, mutually exclusive
                testp   #DM                     wz
  if_nc_and_nz  jmp     #disconnected                   ' DP and DM still low, so keep waiting for connect
  if_c_and_nz   jmp     #.connect_test                  ' DP or DM high is LS/FS connect state
  if_nc_and_z   jmp     #.connect_test
.se1_test
                waitx   ##_1ms * 100                    ' In illegal SE1 state, so wait and retest
                testp   #DP                     wc
                testp   #DM                     wz
  if_c_and_z    jmp     #.se1                           ' Still in illegal SE1 state, so throw error and stop
                mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
                jmp     #disconnected                   ' Back to connect detection loop
.se1            loc     ptra, #@sz_err_se1
                mov     retval, #ERR_SE1
                ' DEBUG: SE1 is error condition
                call    #htx_result_to_con
                waitx   ##_1ms * 100
                mov     retval, hstatus
                jmp     #dbg_break                      ' Seeing SE1 for any length of time is not good...
.connect_test                                           ' Test lines until stable J/K state seen
                waitx   ##_1ms * 100                    ' Total of 100ms debounce interval (Section 7.1.7.3)
                testp   #DP                     wc
                testp   #DM                     wz
  if_nc_and_nz  jmp     #disconnected                   ' DP and DM low
  if_c_and_z    jmp     #.se1_test                      ' DP and DM high
connected
                bith    hstatus, #CONNECTEDB            ' Device plugged in
                drvh    #HOST_WAIT_LED                  ' DEBUG: stays lit while device connected
                call    #hpulse_led                     ' Initialize the main loop activity USER_LED pulse timer
                call    #on_connect                     ' Initial device configuration
' Fall through to idle/processing loop
' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
hidle
                pollct3                         wc
        if_c    call    #hpulse_led                     ' Toggle the main loop activity indicator USER_LED
                pollse1                         wc
        if_c    call    #do_hevent
                rqpin   urx, #DM
                testb   urx, #SE0_RESETB        wc
        if_c    jmp     #.se0_test
                jmp     #hidle
' Check for extended SE0 state on the bus
.se0_test
                mov     hctwait, ##_1ms
                call    #poll_waitx                     ' Wait a bit and test for SE0 again
                rqpin   urx, #DM
                testb   urx, #SE0_RESETB        wc
        if_nc   jmp     #hidle                          ' Bus still IDLE
                setint1 #0                              ' Turn off frame strobe interrupt
                fltl    #HOST_WAIT_LED                  ' DEBUG
                fltl    #HOST_ACTIVITY_LED              ' DEBUG
                mov     hevent, #DINF_DISCONNECT
                mov     hpar1, ep_addr_pid
                call    #post_devent                    ' Inform HID driver of reset/disconnect
                waitx   ##_1ms * 1000
                jmp     #host_reset                     ' Device disconnected
' */
' /* load_lut
'------------------------------------------------------------------------------
' The host owns LUT cells 256..511.
'------------------------------------------------------------------------------
load_host_lut
                ret
' */
' /* dev_reset
'------------------------------------------------------------------------------
' Reset connected device FIXME: speed selection should be POST RESET?
' If it's initial connect, start the transceiver and set it to detected speed
'------------------------------------------------------------------------------
dev_reset
                testp   #DM                     wc
        if_c    bith    hstatus, #LOW_SPEEDB            ' DM pulled high, so it's a Low-Speed device
        if_c    call    #set_speed_low                  ' Configure pins for detected speed
        if_nc   call    #set_speed_full
                dirh    #DP                             ' Crank them smart pins up
                dirh    #DM
                waitx   #100
reset
                setint1 #0                              ' Don't want frame interrupt at reset
                wypin   #OUT_SE0, #DM                   ' Assert bus reset
                waitx   ##RESET_HOLD                    ' Spec is >= 10ms
                wypin   #OUT_IDLE, #DM
                bitl    hstatus, #TXN_LIMITB            ' Reset the frame txn OK/!OK flag
                mov     frame, #0                       ' Reset the frame count
                getct   hct1                            ' Reset the frame timer
                addct1  hct1, ##TXN_OK_ZONE
                setint1 #1                              ' Set ISR event trigger to CT1-equals-CT
                mov     hctwait, ##_1ms * 21
                call    #poll_waitx                     ' Allow reset recovery time (Section 9.2.6.2)
                ret
' */
' /* on_connect
'------------------------------------------------------------------------------
' Perform configuration stuff required when a device intitially connects.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
on_connect
                mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
                call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
.retry
                mov     hevent, #DINF_CONNECT           ' Prepare to inform driver a device has connected
                testb   hstatus, #LOW_SPEEDB    wc
        if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
        if_nc   mov     hpar1, #USB_SPEED_FULL
                call    #post_devent
                mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
                loc     ptra, #@get_dev_desc            ' Hub start address of GetDeviceDescriptor SETUP struct
                wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
                loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct for IN data
                call    #control_read                   ' Execute GetDeviceDescriptor()
                loc     ptra, #@sz_getdev_result
                call    #htx_result_to_con              ' Route results to terminal
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.get_dev_desc
                mov     hctwait, ##_1ms * 1000          ' If the first GetDescriptor() fails, reset and try again
                call    #poll_waitx
                sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
        if_z    pop     htmp                            ' This POP should empty the hardware stack
        if_z    jmp     #host_reset                     ' Re-initialize everything if reset retry limit exceeded
                call    #reset                          ' Try another reset to see if the device responds
                jmp     #.retry
.get_dev_desc
                loc     pa, #@dev_desc_buff             ' Fetch the max packet size for control transactions from the
                add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
                rdbyte  max_pkt_size, pa
                mov     hctwait, ##_1ms
                call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
                call    #reset
                loc     ptra, #@set_address             ' Hub start address of SetAddress SETUP struct
                wrword  #1, ptra[wValue]                ' Only support one device port at this time
                call    #control_write                  ' Execute SetAddress()
                loc     ptra, #@sz_setaddr_result
                call    #htx_result_to_con              ' Route results to terminal
                cmp     retval, #PID_ACK        wz
        if_nz   ret                                     ' Back to idle if not ACK
                mov     hctwait, ##_1ms * 8
                call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
                mov     ep_addr_pid, ##1 << 8           ' Device ep/addr now #1 and endpoint zero
                call    #calc_crc5
                loc     ptra, #@get_dev_desc            ' Repeat SETUP for GetDeviceDescriptor()
                loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct has exact descriptor length
                rdbyte  total_data, pb
                wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
                call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.ack0
                loc     ptra, #@sz_getdev_result
                jmp     #htx_result_to_con              ' Route error result to terminal and back to idle state
.ack0
                mov     hevent, #DINF_DEV_DESC          ' Notify driver cog that the device descriptor is cached
                mov     hpar1, ep_addr_pid
                mov     hpar2, ##dev_desc_buff
                mov     hpar3, retval
                call    #post_devent
                mov     hctwait, ##_1us * 500
                call    #poll_waitx
                loc     ptra, #@get_config_desc         ' Hub start address of GetConfigurationDescriptor SETUP struct
                wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
                loc     pb, #@con_desc_buff             ' Hub start address of ConfigurationDescriptor structure
                call    #control_read                   ' Execute GetConfigurationDescriptor()
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.ack1
                loc     ptra, #@sz_getconf_result
                jmp     #htx_result_to_con              ' Route error result to terminal and go back to idle state
.ack1
                loc     ptra, #@con_desc_buff           ' Check the config descriptor struct for expected data
                rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
                rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
                rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= byte count actually received
                cmp     hr0, #CON_DESC_LEN      wcz
        if_ae   cmp     hr1, #TYPE_CONFIG       wcz
        if_z    cmp     htmp, total_data        wcz
        if_b    jmp     #.err_config
                mov     hevent, #DINF_CON_DESC          ' Notify driver cog that the configuration descriptor is cached
                mov     hpar1, ep_addr_pid
                mov     hpar2, ##con_desc_buff
                mov     hpar3, retval
                jmp     #post_devent                    ' From now on the host idles and waits for class driver IRPs
.err_config
                loc     ptra, #@sz_getconf_result
                mov     retval, #ERR_PACKET
                jmp     #htx_result_to_con              ' Error to terminal and back to idle state
' */
' /* do_ctrl_read
'------------------------------------------------------------------------------
' Execute a ControlRead transaction on behalf of the class driver via the
' event mechanism and post the result.
' TODO: The function address should really be cached by the host and not the
'       class driver.
'------------------------------------------------------------------------------
' On entry: Reg hevent: H_CTRL_READ eventID.
' On exit:  Reports the result of the transaction to the class driver via the
'           event mechanism.
'------------------------------------------------------------------------------
do_ctrl_read
                rdlut   ep_addr_pid, #H_PAR1            ' Function address and control endpoint zero
                rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
                rdlut   pb, #H_PAR3                     ' Start address of the IN data buffer
                call    #control_read                   ' Execute ControlRead() txn
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction overall result
                mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* do_ctrl_write
'------------------------------------------------------------------------------
' Execute a ControlWrite transaction on behalf of the class driver via the
' event mechanism.
' TODO: The function address should really be cached by the host and not the
'       class driver.
'------------------------------------------------------------------------------
' On entry: Reg hevent: HCTRL_WRITE eventID.
' On exit:  Reports the result of the transaction to the class driver via the
'           event mechanism.
'------------------------------------------------------------------------------
do_ctrl_write
                rdlut   ep_addr_pid, #H_PAR1            ' Function address and control endpoint zero
                rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
                rdlut   pb, #H_PAR3                     ' Start address of the OUT data buffer
                call    #control_write                  ' Execute ControlWrite() txn
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction overall result
                mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* do_int_in
'------------------------------------------------------------------------------
' Execute an IN interrupt transaction on behalf of the class driver via the
' event mechanism.
' FIXME: The function address, endpoint and data toggle info should be cached
'        and maintained by the host and not the class driver.
'        Need to handle IN data lengths > max_pkt_size.
'------------------------------------------------------------------------------
' On entry: Reg hevent: HINT_IN eventID.
' On exit:  Reports the result of the transaction to the class driver via the
'           host<->driver event mechanism.
'------------------------------------------------------------------------------
do_int_in
                rdlut   ep_addr_pid, #H_PAR1            ' Function address and endpoint
                rdlut   hpar3, #H_PAR3                  ' Word1 max_pkt, word0 DATAx to expect
                testn   ep_addr_pid, ##EP_ADDR_MASK wz
        if_z    call    #calc_crc5                      ' Calculate CRC5 if not yet done
                getword htmp, hpar3, #0
                cmp     htmp, #PID_DATA0        wz
                bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
                mov     retry, #TXN_RETRIES
.retry
                getword pkt_data, hpar3, #1             ' IN max packet length
                call    #txn_in
                cmp     retval, #PID_ACK        wz
        if_z    jmp     #.commit
                cmp     retval, #PID_NAK        wz
        if_nz   cmp     retval, #PID_STALL      wz
        if_z    jmp     #.post_ret                      ' IRP poster must handle NAK or STALL
                call    #retry_wait
                cmp     retval, #ERR_TXN_RETRY  wz
        if_z    jmp     #.post_ret
                jmp     #.retry
.commit
                cmp     pkt_cnt, #0             wz
        if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
                loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest buffer
                rdlut   pb, #H_PAR2                     ' Start address of buffer for the IN data
                mov     hr0, pkt_cnt
                call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
.post_ret
                mov     hevent, #DTXN_RESULT
                mov     hpar1, ep_addr_pid              ' Confirm USB target
                mov     hpar2, retval                   ' Transaction result
                mov     hpar3, pkt_cnt                  ' IN bytes actually received
                jmp     #post_devent                    ' Post results to the class driver and return to caller
' */
' /* do_int_out
'------------------------------------------------------------------------------
' Execute an OUT interrupt transaction on behalf of the class driver via the
' event mechanism.
'------------------------------------------------------------------------------
do_int_out
                ret
' */
' /* retry_wait
'------------------------------------------------------------------------------
' Transaction retry handling for NAK/STALL or bus error.
'------------------------------------------------------------------------------
' On entry: Reg retval: transaction response PID or error code.
' On exit:
'------------------------------------------------------------------------------
retry_wait
                cmp     retval, #PID_NAK        wz
        if_z    mov     hctwait, ##_1us * 17            ' This seems to be a decent IN/OUT-NAK delay period
        if_nz   mov     hctwait, ##_1us * 51            ' More time for TAT and other errors
                call    #poll_waitx                     ' poll_waitx doesn't touch Z flag
        if_z    jmp     #.nak
                cmp     retval, #PID_STALL      wz
        if_z    ret                                     ' STALL is special case
.dec
                sub     retry, #1               wz
        if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
                ret                                     ' Retry result to caller
.nak
                cmp     nak_retry, #NAK_NOLIMIT wz
        if_z    ret                                     ' Indefinite NAK retries
                sub     nak_retry, #1           wz
        if_z    mov     retval, #ERR_NAK
                ret
' */
' /* calc_crc5
'------------------------------------------------------------------------------
' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
' the data used for the USB-5 CRC lookups. The token packet is three bytes in
' length, and the PID is not included in the CRC calculation:
'  CRC5  FRAME_NUMBER SOF (full-speed)
'  CRC5  ENDP ADDRESS PID
' %00000_1111_1111111_xxxxxxxx
'------------------------------------------------------------------------------
' On entry: Reg ep_addr_pid: stuffed with the function endpoint, address and
'           SETUP/IN/OUT/SOF PID according to the USB standard.
' On exit:  Reg ep_addr_pid: CRC value appended to the packet.
'------------------------------------------------------------------------------
calc_crc5
                and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
                mov     htmp, ep_addr_pid
                shr     htmp, #8                        ' PID not included in CRC calc
                mov     crc, #$1f                       ' Initial CRC5 value
                rev     htmp                            ' Input data reflected
                setq    htmp                            ' CRCNIB setup for data bits 0..7
                crcnib  crc, #USB5_POLY
                crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
                shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
                crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                shl     htmp, #1                wc
                crcbit  crc, #USB5_POLY
                xor     crc, #$1f                       ' Final XOR value
                shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
        _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
' */
' /* set_speed_full
'------------------------------------------------------------------------------
' Configure smart pins for USB host, Full-Speed
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
set_speed_full
                wrpin   #%1_11001_0, #DP                ' Configure DP pin (passive)
                wrpin   #%1_11001_0, #DM                ' Configure DM pin (the brain)
                wxpin   ##_12Mbps, #DM                  ' Set 12Mbps Full-Speed mode
                mov     max_pkt_size, #64               ' Maximum full-speed control read/write DATAx packet size
                mov     tat_wait, ##TAT_WAIT_FS         ' Bus turn-around time in full-speed bit periods
        _ret_   mov     ip_delay, ##IP_DELAY_FS         ' Inter-packet delay in full-speed bit periods
' */
' /* set_speed_low
'------------------------------------------------------------------------------
' Configure smart pins for USB host, Low-Speed
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
set_speed_low
                wrpin   #%1_11000_0, #DP                ' Configure DP pin (passive)
                wrpin   #%1_11000_0, #DM                ' Configure DM pin (the brain)
                wxpin   ##_1_5Mbps, #DM                 ' Set 1.5Mbs Low-Speed mode
                mov     max_pkt_size, #8                ' Maximum low-speed control read/write DATAx packet size
                mov     tat_wait, ##TAT_WAIT_LS         ' Bus turn-around time in low-speed bit periods
        _ret_   mov     ip_delay, ##IP_DELAY_LS         ' Inter-packet delay in low-speed bit periods
' */
' /* htx_result_to_con
'------------------------------------------------------------------------------
' Send USB transaction or other event results to the serial terminal via the
' host->class driver event mechanism. If the "verbose" output option is active,
' output is unfiltered, otherwise ACK/SUCCESS result codes are suppressed.
'
' NOTE: only call this routine prior to the class driver being notified that
'       the device and configuration descriptors have been successfully read.
'       After that happens, all USB I/O is done using the class driver->host
'       IRP mechanism, which does its own transaction result handling.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: address of the transaction/event zero-terminated
'           description string. If zero, a generic description will be used.
'           Reg retval: value of the result.
' On exit:
'------------------------------------------------------------------------------
htx_result_to_con
                mov     hpar1, ptra
                mov     hpar2, retval
                mov     hpar3, #RXERRF
                and     hpar3, hstatus                  ' RXERRF is never good
                mov     hevent, #DTXN_HRESULT
                jmp     #post_devent
' */
' /* dbg_break
'------------------------------------------------------------------------------
' Output a debug value and stop the host.
'------------------------------------------------------------------------------
' On entry: Reg retval: whatever debug info that fits into a long.
' On exit:  You can check in any time you like, but you will never leave...
'------------------------------------------------------------------------------
dbg_break
                mov     hpar1, retval
                mov     hevent, #DREQ_BREAK
                call    #post_devent
                stalli
                waitx   ##_1ms * 500
.halt           jmp     #.halt
' */
' /* dbg_hexdump
'------------------------------------------------------------------------------
' Dump hex byte data to the terminal.
'------------------------------------------------------------------------------
' On entry: Reg hpar1: start address of data.
'           Reg hpar2: length of data, in bytes.
'------------------------------------------------------------------------------
dbg_hexdump
                mov     hevent, #DREQ_HEXDUMP
                jmp     #post_devent
' */
' /* dbg_data
'------------------------------------------------------------------------------
' Dump hex byte data to the terminal.
'------------------------------------------------------------------------------
' On entry: Reg retval: arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
dbg_data
                mov     hevent, #DREQ_DBG_DATA
                mov     hpar1, retval
                jmp     #post_devent
' */
' /* hpulse_led
'------------------------------------------------------------------------------
' Toggle a Prop123-A9 USER_LED when the host is the connect wait loop or the
' main USB processing loop.
'------------------------------------------------------------------------------
hpulse_led
                getct   hct3
                addct3  hct3, ##PULSE_TIME
                testb   hstatus, #CONNECTEDB    wc
        if_nc   drvnot  #HOST_WAIT_LED
        if_c    drvnot  #HOST_ACTIVITY_LED
                ret
' */
' #endregion DAT (Host HubExec)
' #region DAT (Class Driver HubExec)
'------------------------------------------------------------------------------
' USB Class Driver hub exec routines. Save the cog space for time critical
' stuff.
'------------------------------------------------------------------------------
dat
                orgh
' /* parse_dev_desc
'------------------------------------------------------------------------------
' Parse the Device Descriptor. For now just parse out the string indexes. Root
' out additional info as needed.
'------------------------------------------------------------------------------
' On entry: Reg devent: eventID.
'           Reg dpar1: device address and control pipe endpoint (0).
'           Reg dpar2: start address of the cached device descriptor struct.
' On exit:
'------------------------------------------------------------------------------
parse_dev_desc
                mov     ctrl_ep_addr, dpar1             ' Save the ctrlep/addr of the device
                mov     device_base, dpar2              ' Save start address of device descriptor
                loc     ptra, #@sz_getdev_result        ' Since the intent is to parse the device
                mov     dpar2, dpar3                    ' descriptor, the result *should* always be ACK
                jmp     #dtx_result_to_con
' */
' /* parse_con_desc
'------------------------------------------------------------------------------
' Parse a configuration descriptor chain to see if the device is a recognized
' one. If it is, start the task progression that will configure the device for
' use.
'------------------------------------------------------------------------------
' On entry: Reg devent: eventID.
'           Reg dpar1: device address and control pipe endpoint (0).
'           Reg dpar2: start address of the cached config descriptor chain.
' On exit:
'------------------------------------------------------------------------------
parse_con_desc
                mov     ctrl_ep_addr, dpar1             ' Get ctrlep/addr of the device
                mov     config_base, dpar2              ' Save start address of config chain
                loc     ptra, #@sz_getconf_result       ' Since the intent is to parse the configuration
                mov     dpar2, dpar3                    ' descriptor, the result *should* always be ACK
                call    #dtx_result_to_con
                call    #init_kbd_data                  ' Reset keyboard/mouse data area to start-up values
                mov     pa, #CON_wTotalLen
                add     pa, config_base
                rdword  con_tot_len, pa                 ' Keep config chain size handy
                call    #search_boot_triad              ' The heavy lifting is done here
                mov     dtask, #DT_SET_CONF             ' Direct to configuration decision
                ret
' */
' /* search_boot_triad
'------------------------------------------------------------------------------
' Search the configuration descriptor chain looking for the interface
' Class/SubClass/Protocol "triad" that defines a keyboard and/or mouse.
'------------------------------------------------------------------------------
' On entry: Reg config_base: start address of the config descriptor chain.
'           Reg con_tot_len: total length of the config descriptor chain.
' On exit:  Reg kbd_ep_addr will be non-zero if a boot keyboard found.
'           Reg mouse_ep_addr will be non-zero if a boot mouse found.
'------------------------------------------------------------------------------
search_boot_triad
                rdbyte  next_desc, config_base          ' Config desc size is offset to first desc in chain
.next_intf
                mov     search_key, #TYPE_INTERFACE
                call    #search_desc_type
                cmp     ptrb, #0                wz
        if_z    ret                                     ' No more interface descs
                rdbyte  dtmp, ptrb
                add     next_desc, dtmp                 ' Get offset to next desc, if any
                rdbyte  hid_intf_idx, ptrb[INTF_bIntfNum]
                rdbyte  dtmp, ptrb[INTF_bIntfClass]
                cmp     dtmp, #CLASS_HID        wz      ' Only interested in the HID class interface descriptors
        if_nz   jmp     #.next_intf                     ' Search next interface in chain, if any
                rdbyte  dtmp, ptrb[INTF_bSubClass]      ' Look for a boot interface sub-class
                cmp     dtmp, #SUBCLASS_INTF_BOOT wz
        if_nz   jmp     #.next_intf
                rdbyte  dr3, ptrb[INTF_bProtocol] wz    ' Protocol must be non-zero
        if_z    jmp     #.next_intf
.endp
                push    ptrb
                push    next_desc
                mov     search_key, #TYPE_ENDPOINT
                call    #search_desc_type               ' Endpoint descs always follow interface descs
                cmp     ptrb, #0                wz
        if_nz   jmp     #.get_ep
.bad_ep
                pop     next_desc
                pop     ptrb
                jmp     #.next_intf
.get_ep
                rdbyte  dr1, ptrb[ENDP_bAddress]
                testb   dr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
        if_nc   jmp     #.bad_ep                        ' Not an IN endpoint
                and     dr1, #$0f                       ' FIXME: define constant for IN endpoint address mask
                shl     dr1, #8 + 7
                add     ptrb, #ENDP_wMaxPktSize
                rdword  dr2, ptrb++
                and     dr2, ##$7ff                     ' Bits 10..0 define the max packet size
                rdbyte  dr0, ptrb                       ' Fetch the bInterval member (min poll interval, in milliseconds)
                pop     next_desc
                pop     ptrb
                cmp     dr3, #INTF_PROTO_KBD    wz
        if_nz   jmp     #.mouse
.keyboard
                wrbyte  hid_intf_idx, ##kbd_intf_num    ' Save interface index and poll interval values
                wrbyte  dr0, ##kbd_interval
                mov     kbd_ep_addr, ctrl_ep_addr
                and     kbd_ep_addr, ##ADDR_MASK
                or      kbd_ep_addr, dr1                ' IN endpoint address
                wrbyte  dr2, ##kbd_in_max_pkt
                jmp     #.next_intf                     ' See if there's a mouse subclass
.mouse
                cmp     dr3, #INTF_PROTO_MOUSE  wz
        if_nz   jmp     #.next_intf
                wrbyte  hid_intf_idx, ##mouse_intf_num  ' Save interface index and poll interval values
                wrbyte  dr0, ##mouse_interval
                mov     mouse_ep_addr, ctrl_ep_addr
                and     mouse_ep_addr, ##ADDR_MASK
                or      mouse_ep_addr, dr1              ' IN endpoint address
                wrbyte  dr2, ##mouse_in_max_pkt
                jmp     #.next_intf                     ' See if there's a keyboard protocol
' */
' /* search_desc_type
'------------------------------------------------------------------------------
' Search the configuration descriptor chain for a specific descriptor type.
'------------------------------------------------------------------------------
' On entry: Reg con_tot_len: total length of the config descriptor chain.
'           Reg next_desc: offset from the configuration descriptor to start
'           the search. It is assumed that the offset will point to the start
'           of a USB standard descriptor.
'           Reg search_key: descriptor type to match.
' On exit:  Reg PTRB: if a match is found, the descriptor start address,
'           otherwise zero.
'           Reg next_desc: descriptor offset if found, otherwise unchanged.
'------------------------------------------------------------------------------
search_desc_type
                push    next_desc
.next
                cmp     next_desc, con_tot_len  wcz
        if_ae   mov     ptrb, #0
        if_ae   pop     next_desc
        if_ae   ret
                mov     ptrb, config_base
                add     ptrb, next_desc
                rdbyte  dtmp, ptrb[DESC_bDescType]
                cmp     dtmp, search_key        wz
        if_z    pop     dtmp                            ' Toss the old next_desc value
        if_z    ret
                rdbyte  dtmp, ptrb
                add     next_desc, dtmp                 ' Get offset of next desc to check
                jmp     #.next
' */
' /* dset_config
'------------------------------------------------------------------------------
' If a newly-connected device is recognized, do whatever is needed to configure
' it according to its function, or functions. In the case of this boot protocol
' keyboard/mouse class driver:
' - SetConfiguration(config_num)
' - SetProtocol(boot)
' - SetIdle(indefinite)
' - Enter the device interrupt IN polling task stage.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dset_config
'               mov     kbd_ep_addr, #0                 ' DEBUG
'               mov     mouse_ep_addr, #0               ' DEBUG
                cmp     kbd_ep_addr, #0         wz
        if_z    cmp     mouse_ep_addr, #0       wz
        if_nz   jmp     #.config                        ' Did we find a boot protocol keyboard and/or mouse?
                loc     ptra, #@sz_bummer               ' Unknown device
                mov     dtask, #DT_IDLE
                jmp     #dtx_asciiz                     ' Don't bother to configure unknown device
.config
                loc     ptra, #@set_config
                mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
                add     pa, config_base
                rdbyte  dpar1, pa
                wrword  dpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, #0                       ' SetConfiguration() has no data stage
                mov     dtask, #DT_IDLE                 ' Into task idle until configuration IRP done
                mov     dres_handler, ##res_conf        ' Label is akin to a callback routine for the IRP result
                jmp     #post_hevent                    ' Post ControlWrite() event
res_conf
                loc     ptra, #@sz_setcon_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   ret                                     ' FIXME: should try to recover instead of punting to idle
kbd_setup
                cmp     kbd_ep_addr, #0         wz
        if_z    jmp     #mouse_setup                    ' No keyboard, so setup the mouse, if detected
                loc     ptra, #@sz_woohoo_kbd
                call    #dtx_asciiz
                mov     dpar1, #BOOT_PROTOCOL
                rdbyte  dpar2, ##kbd_intf_num
                mov     dres_handler, ##res_proto_kbd
                jmp     #dset_protocol
res_proto_kbd
                loc     ptra, #@sz_setprot_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
                mov     dpar1, #0                       ' SetIdle() duration 0 = indefinite
                rdbyte  dpar2, ##kbd_intf_num
                mov     dres_handler, ##res_kbd_idle
                jmp     #dset_idle
res_kbd_idle
                loc     ptra, #@sz_setidle_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
                waitx   ##_1ms * 2
                mov     dres_handler, ##res_kbdled0     ' Set the keyboard LED indicators to their startup states
                jmp     #dset_kbdled_report
res_kbdled0
                cmp     dpar2, #PID_ACK         wz
        if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
                mov     dtmp, #KEY_NO_KEY
                wrbyte  dtmp, ##kbd_last_key
                mov     kbd_poll_cnt, #0                ' Initialize key auto-repeat counters
                mov     kbd_repeat, ##KBD_REPEAT_DELAY
                loc     ptra, #@sz_kbd_ready            ' DEBUG: to terminal with keyboard ready message
                call    #dtx_asciiz
                getct   dct1
                addct1  dct1, ##KBD_POLL_INTERVAL       ' Wait an interval before the first IN poll
mouse_setup
                cmp     mouse_ep_addr, #0       wz
        if_z    jmp     #conf_exit
                loc     ptra, #@sz_woohoo_mouse
                call    #dtx_asciiz
                mov     dpar1, #BOOT_PROTOCOL
                rdbyte  dpar2, ##mouse_intf_num
                mov     dres_handler, ##res_proto_mouse
                jmp     #dset_protocol
res_proto_mouse
                loc     ptra, #@sz_setprot_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   mov     mouse_ep_addr, #0
        if_nz   jmp     #conf_exit                      ' FIXME: should try to recover
                cmp     kbd_ep_addr, #0         wz
        if_nz   jmp     #mouse_timer                    ' Skip SetIdle() if it's already been done
                mov     dpar1, #0                       ' SetIdle() duration 0 = indefinite
                rdbyte  dpar2, ##mouse_intf_num
                mov     dres_handler, ##res_mouse_idle
                jmp     #dset_idle
res_mouse_idle
                loc     ptra, #@sz_setidle_result
                call    #dtx_result_to_con
                cmp     dpar2, #PID_ACK         wz
        if_nz   mov     mouse_ep_addr, #0
        if_nz   jmp     #conf_exit                      ' FIXME: should try to recover
mouse_timer
                loc     ptra, #@sz_mouse_ready          ' DEBUG: to terminal with keyboard ready message
                call    #dtx_asciiz
                cmp     kbd_ep_addr, #0         wz
        if_nz   mov     dct2, dct1                      ' Keyboard/mouse combo, so stagger poll intervals
        if_nz   addct2  dct2, ##KBD_POLL_INTERVAL / 2
        if_z    getct   dct2                            ' Mouse is the only connected device
        if_z    addct2  dct2, ##MOUSE_POLL_INTERVAL     ' Set first poll interval
conf_exit
                mov     dtask, #DT_POLL_DATA
                jmp     #dtx_newline                    ' Make sure keyboard/mouse output starts on a new line
' */
' /* dset_protocol
'------------------------------------------------------------------------------
' Post a ControlWrite() request to the host that will perform the HID-specific
' SET_PROTOCOL function.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: protocol to set: 0 = Boot Protocol, 1 = Report Protocol.
'           Reg dpar2: index number of the interface to configure.
' On exit:
'------------------------------------------------------------------------------
dset_protocol
                waitx   ##_1ms * 2
                loc     ptra, #@set_protocol
                wrword  dpar1, ptra[wValue]
                wrword  dpar2, ptra[wIndex]
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, #0                       ' SetProtocol() has no data stage
                jmp     #post_hevent                    ' Post ControlWrite() event
' */
' /* dset_idle
'------------------------------------------------------------------------------
' Post a ControlWrite() request to the host that will perform the HID-specific
' HID_SET_IDLE function.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'           Reg dpar2: index number of the target interface.
' On exit:
'------------------------------------------------------------------------------
dset_idle
                waitx   ##_1ms * 2
                loc     ptra, #@set_idle
                wrword  dpar1, ptra[wValue]
                wrword  dpar2, ptra[wIndex]
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, #0                       ' SetIdle() has no data stage
                jmp     #post_hevent                    ' Post ControlWrite() event
' */
' /* dset_kbd_report
'------------------------------------------------------------------------------
' Post a ControlWrite() request to the host that will perform the HID-specific
' HID_SET_REPORT function to set keyboard CapsLk, ScrLk and NumLk indicators.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dset_kbdled_report
                loc     ptra, #@set_report
                rdbyte  dtmp, ##kbd_intf_num
                wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
                wrword  dtmp, ptra[wIndex]
                wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
                mov     devent, #HCTRL_WRITE
                mov     dpar1, ctrl_ep_addr
                mov     dpar2, ptra                     ' SETUP struct addr
                mov     dpar3, ##kbd_led_states         ' Start address of OUT data
                jmp     #post_hevent                    ' Post ControlWrite(SET_REPORT) event
' */
' /* kbd_compare
'------------------------------------------------------------------------------
' Compare current and previous keyboard data buffers for keypress changes.
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg dpar1: keycode of the last key in the down state, otherwise
'           zero (KEY_NO_KEY) if no keys were in the down state.
'           Reg dpar2: the current (possibly changed) modifier key states.
'------------------------------------------------------------------------------
kbd_compare
                mov     dpar3, #KEY_NO_KEY
                loc     ptrb, #@kbd_cur_report + 2      ' Start of keycode array
                rdbyte  dpar1, ptrb++                   ' First array byte tells us if no keys down or keyboard error
                cmp     dpar1, #KEY_ERR_UNDEF   wcz     ' First four key values in lookup table are "special" keycodes
        if_a    jmp     #.get_keys                      ' Process normal keycode
                cmp     dpar1, #KEY_NO_KEY      wz
        if_z    jmp     #.end_keys                      ' No key activity or key up event, so commit current to previous
                loc     ptra, #@kbd_prev_report         ' Keyboard rollover overflow or other error
                mov     drep, #KBD_IN_RPT_LEN           ' This data can't be used for compare purposes in the future
                jmp     #dmemcpy                        ' So make the previous data the current data and return to caller
' Walk the keycode array looking for pressed keys
.get_keys
                rdbyte  dr0, ##kbd_max_index
                mov     dr3, dr0
                add     dr3, ##kbd_cur_report           ' Last keycode array element
.next_key
                cmp     dpar1, #KEY_NO_KEY      wz
        if_z    jmp     #.end_keys                      ' No more pressed keys in the current report
                call    #check_key                      ' Process this keycode
                cmp     ptrb, dr3               wz      ' Check for array end
        if_nz   rdbyte  dpar1, ptrb++
        if_nz   jmp     #.next_key
.end_keys
                rdbyte  dtmp, ##kbd_last_key
                cmp     dpar3, dtmp             wz
        if_nz   mov     kbd_repeat, ##KBD_REPEAT_DELAY  ' Key down event was a different key than last,
        if_nz   mov     kbd_poll_cnt, #0                ' so reset auto-repeat
        if_nz   wrbyte  dpar3, ##kbd_last_key
.end
                loc     ptra, #@kbd_cur_report          ' Done processing current IN report
                loc     ptrb, #@kbd_prev_report
                mov     drep, #KBD_IN_RPT_LEN
                jmp     #dmemcpy                        ' So it becomes the previous report for future compare
' */
' /* check_key (boot protocol specific)
'------------------------------------------------------------------------------
' See if the given keycode exists in the previously read keyboard data. If
' found it means the key is still pressed and can be ignored. If not found it's
' a new keypress to process.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: keycode to check.
'           Reg dpar2: current CapsLock, NumLock and ScrollLock bitflags.
' On exit:  Reg dpar1: input keycode if matched (still in the down state).
'           otherwise the input keycode (new keypress).
'           Reg dpar2: possibly modified toggle key state
'           Reg dpar3: keycode of the last key found in the down state
'------------------------------------------------------------------------------
check_key
                loc     ptra, #@kbd_prev_report + 2
                mov     dr1, ##kbd_prev_report
                add     dr1, dr0                        ' Last keycode array element
.loop
                rdbyte  dtmp, ptra++
                cmp     dtmp, dpar1             wz
        if_z    mov     dpar3, dpar1
        if_z    ret                                     ' Key still in down state, so done with this key
                cmp     ptra, dr1               wz
        if_nz   jmp     #.loop
' The previous key report has been searched and no match found, so this is a
' newly-pressed key. Check first for a toggle key.
                mov     dtmp, dkbd_ledstates
                cmp     dpar1, #KEY_CAPSLK      wz
        if_z    bitnot  dtmp, #LED_CAPSLKB
                cmp     dpar1, #KEY_SCRLK       wz
        if_z    bitnot  dtmp, #LED_SCRLKB
                cmp     dpar1, #KEY_NUMLK       wz
        if_z    bitnot  dtmp, #LED_NUMLKB
                cmp     dtmp, dkbd_ledstates    wz
        if_nz   mov     dkbd_ledstates, dtmp
        if_nz   mov     dpar3, #KEY_NO_KEY              ' Toggle key pressed cancels auto-repeat
        if_nz   ret                                     ' Done if toggle key processed
' Fall through to sendkey with new keypress
' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
' */
' /* sendkey
'------------------------------------------------------------------------------
' Process a newly-pressed key using the keycode table in LUT.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: the keycode to send to the terminal.
' On exit:
'------------------------------------------------------------------------------
sendkey
                mov     dpar3, dpar1                    ' Save keycode for repeat evaluation
'                mov     dtmp, #LSHARE_TOP
'                add     dtmp, dpar1
'                rdlut   dpar2, dtmp                     ' Lookup ASCII character pair (byte1 shifted, byte0 un-shifted)
                rdlut   dpar2, dpar1                    ' Lookup ASCII character pair (byte1 shifted, byte0 un-shifted)
                rdbyte  dtmp, ##kbd_cur_report          ' Key array zero is shift/alt/ctrl/gui modifier bits
                testb   dkbd_ledstates, #LED_CAPSLKB wc
        if_nc   jmp     #.chk_shift                     ' CapsLock not active, so we can evaluate shift now
' Active CapsLock key only affects the alpha keys
' FIXME: Ctrl/Alt keys not handled
                cmp     dpar1, #KEY_Z_z         wcz     ' The first valid keycode is KEY_A_a
        if_a    jmp     #.chk_shift                     ' So if it's above KEY_Z_z it's not an alpha key
                test    dtmp, #KEY_SHIFT        wz
        if_nz   getbyte dtx, dpar2, #0                  ' CapsLock AND Shift is lowercase alpha
        if_z    getbyte dtx, dpar2, #1
                jmp     #.out_key
.chk_shift
                test    dtmp, #KEY_SHIFT        wz      ' Determine upper/lower case keycode to send
        if_z    getbyte dtx, dpar2, #0
        if_nz   getbyte dtx, dpar2, #1
.out_key
' Publish the updated keyboard keypress and modifier flags to the public interface in hub RAM
                mov     dkbd_keypress, dtx
                add     dkbd_count, #1
                setq    #4 - 1                          ' Two cog registers in fast block write
                wrlong  dkbd_count,##@kbd_count
                jmp     #dtx_char
' */
' /* mouse_compare
'------------------------------------------------------------------------------
' Compare current and previous mouse data buffers for changes.
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg drep: zero if a change was detected.
'------------------------------------------------------------------------------
mouse_compare
                loc     ptra, #@mouse_cur_report
                loc     ptrb, #@mouse_prev_report
                mov     drep, #0
.loop
                rdbyte  dr0, ptra++
                rdbyte  dr1, ptrb++
                cmp     dr0, dr1                wz
        if_nz   jmp     #.change
                add     drep, #1
                cmp     drep, #MOUSE_RPT_LEN    wz
        if_z    ret                                     ' No changes detected
                jmp     #.loop
.change
                loc     ptra, #@mouse_cur_report
                loc     ptrb, #@mouse_prev_report
                mov     drep, #MOUSE_RPT_LEN
                jmp     #dmemcpy
' */
' /* dmemcpy
'------------------------------------------------------------------------------
' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: source address.
'           Reg PTRB: destination address.
'           Reg drep: length of copy, in bytes.
' On exit:
'------------------------------------------------------------------------------
dmemcpy
                rdbyte  dtmp, ptra++
                wrbyte  dtmp, ptrb++
                djnz    drep, #dmemcpy
                ret
' */
' /* htx_hexdump
'------------------------------------------------------------------------------
' Serial output of raw data in hexadecimal byte format.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: start address of data header string.
'           Reg PB: start address of the data blob.
'           Reg dr0: count of data bytes to output.
' On exit:
'------------------------------------------------------------------------------
htx_hexdump
                rdlut   pb, #D_PAR1
                rdlut   dr0, #D_PAR2
dtx_unknown
                loc     ptra, #@sz_unknown_data
dtx_raw_data
                call    #dtx_asciiz
                mov     dr1, #16                        ' Column count
.loop
                cmp     dr1, #16                wz
        if_z    mov     dr1, #0
        if_z    call    #dtx_newline
' At 3MBaud on PST some data was getting dropped, so delay between rows
        if_z    waitx   ##_1us * 500
                mov     dtx, #" "
                call    #dtx_char
                rdbyte  dtx, pb
                add     pb, #1
                call    #dtx_hexbyte
                add     dr1, #1
                djnz    dr0, #.loop
                ret
{
.offset_header
                call    #dtx_newline
                mov     dtx, #" "
                call    #dtx_char
                mov     dtx, dpar3
                bith    dtxopts, #PREPEND_0XB
                call    #dtx_hexword
                bitl    dtxopts, #PREPEND_0XB
                add     dpar3, #16                      ' Next row offset
                mov     dpar2, #0                       ' Reset column count
                mov     dtx, #" "
                mov     drep, #2
                jmp     #dtx_rptchar
}
' */
' /* dtx_result_to_con
'------------------------------------------------------------------------------
' Output detailed transaction results to the terminal. If reg dtxopts has the
' TX_VERBOSEB bitflag cleared, transactions with an ACK result will not be
' output.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: address of the zero-terminated string that describes the
'           transaction, zero if no string defined.
'           Reg dpar2: return code for the transaction.
'           Reg dpar3: If not ERR_NONE, a contextual error code.
' On exit:  Reg dpar2: unchanged.
'           Reg dpar3: unchanged.
'------------------------------------------------------------------------------
dtx_result_to_con
                modcz   _clr, _clr              wcz     ' Ensure both C and Z clear before tests
                testb   dtxopts, #TX_VERBOSEB   wc      ' Suppress ACK/ERR_NONE/ERR_ACK_RETRY when not verbose
        if_nc   cmp     dpar2, #PID_ACK         wz
  if_nc_and_nz  cmp     dpar2, #ERR_NONE        wz
  if_nc_and_nz  cmp     dpar2, #ERR_ACK_RETRY   wz
  if_nc_and_z   ret
dtx_result_code
                cmp     ptra, #0                wz
        if_z    loc     ptra, #@sz_generic_result
                call    #dtx_asciiz
                cmp     dpar2, #ERR_END         wcz
        if_b    jmp     #.extended_code                 ' The error has bus and transfer/transaction context
'------------------------------------------------------------------------------
' Fetch a pointer to the text string for a USB response PID.
'------------------------------------------------------------------------------
' On entry: Reg dpar2: USB response PID type.
'------------------------------------------------------------------------------
.code_text
                mov     ptra, #0
                cmp     dpar2, #PID_ACK         wz      ' Get text equivalent of USB result PID
        if_z    loc     ptra, #@sz_ack
                cmp     dpar2, #PID_NAK         wz
        if_z    loc     ptra, #@sz_nak
                cmp     dpar2, #PID_STALL       wz
        if_z    loc     ptra, #@sz_stall
                cmp     ptra, #0                wz
        if_nz   jmp     #dtx_asciiz                     ' If known PID response, output text and back to caller
.hex
                mov     dtx, dpar2                      ' Output the USB result as a hex value
                bith    dtxopts, #PREPEND_0XB
                call    #dtx_hexlong
        _ret_   bitl    dtxopts, #PREPEND_0XB
.extended_code
                push    dpar2                           ' Transfer/transaction context is a pointer offset to an error description string
                mov     dpar2, dpar3                    ' Reg dpar3 has the USB error code encountered within the transfer/transaction
                call    #.code_text                     ' Output USB error as text
                loc     ptra, #@sz_list_break
                call    #dtx_asciiz
                pop     ptra                            ' Retrieve saved transfer/transaction context pointer offset
                shl     ptra, #2                        ' Table offset in longs
                add     ptra, ##err_code_text
                rdlong  ptra, ptra
                jmp     #dtx_asciiz                     ' Concatenate transfer/transaction result text and back to caller
' */
' /* dtx_txn_result
'------------------------------------------------------------------------------
' Raw data for transaction results posted by the host.
'------------------------------------------------------------------------------
dtx_txn_result
                bith    dtxopts, #APPEND_CRB
                call    #dtx_newline
                mov     dtx, dpar1
                call    #dtx_hexlong
                mov     dtx, dpar2
                call    #dtx_hexlong
                mov     dtx, dpar3
                call    #dtx_hexlong
        _ret_   bitl    dtxopts, #APPEND_CRB
' */
' /* htx_dbg_data
'------------------------------------------------------------------------------
' Output a single host debug value to the terminal.
'------------------------------------------------------------------------------
' On entry: Reg dpar2: whatever the host put there.
' On exit:
'------------------------------------------------------------------------------
htx_dbg_data
                loc     ptra, #@sz_dbg_data
                mov     dpar2, dpar1                    ' FIXME: need consistent parameter types
                jmp     #dtx_result_code                ' Debug data overrides OPT_VERBOSE setting
' */
' /* htx_break
'------------------------------------------------------------------------------
' Output host breakpoint info and debug value. The host halts after posting
' this request, so the driver does too.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: whatever the host put there.
' On exit:
'------------------------------------------------------------------------------
htx_break
                loc     ptra, #@sz_breakh
                call    #dtx_asciiz
                mov     dtx, dpar1
                call    #dtx_hexlong
                loc     ptra, #@sz_host_stopped         ' Host halts
                call    #dtx_newline
                call    #dtx_asciiz
.halt           jmp     #.halt                          ' Driver halts
' */
' /* init_kdb_data
'------------------------------------------------------------------------------
' Initialize the keyboard/mouse data area to start-up values.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
init_kbd_data
                mov     kbd_ep_addr, #0
                mov     mouse_ep_addr, #0
                mov     pa, ##kbd_mouse_start
.loop
                wrbyte  #0, pa
                add     pa, #1
                cmp     pa, ##kbd_mouse_end     wz
        if_nz   jmp     #.loop
                wrbyte  #PID_DATA0, ##kbd_next_datax    ' Reset interrupt IN datax sequence
        _ret_   wrbyte  #PID_DATA0, ##mouse_next_datax
' */
' /* serial_init
'------------------------------------------------------------------------------
' Initialize smart pins for asynchronout serial I/O.
'------------------------------------------------------------------------------
serial_init
                wrpin   #%1_11110_0, #TX                ' Initialize the asynchronous serial smart pin
'                wxpin   ##_115_200_8b, #TX
'                wxpin   ##_1M_8b, #TX
'                wxpin   ##_1_5M_8b, #TX
                wxpin   ##_2M_8b, #TX
'                wxpin   ##_3M_8b, #TX
                dirh    #TX                             ' Enable serial tx
                waitx   ##1000
                wypin   #CLS, #TX                       ' Prime the async buffer by outputting the PST clear screen byte
                loc     ptra, #@dcog_started
                jmp     #dtx_asciiz
' */
{
' /* htx_retstat
'------------------------------------------------------------------------------
' Output USB host receiver status word (data:flags) plus one debug value.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: rx status word.
'           Reg dpar2: optional arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
htx_retstat
                mov     drep, #12                       ' Format the output
                mov     dtx, #" "
                call    #dtx_rptchar
                loc     ptra, #@sz_stathdr
                call    #dtx_asciiz
                loc     ptra, #@sz_stat
                call    #dtx_asciiz
                mov     dtx, dpar1                      ' Fetch the USB rx status word
                push    dtx
                mov     drep, #8
                call    #dtx_bin                        ' Output USB rx status bits
                mov     drep, #2
                mov     dtx, #" "
                call    #dtx_rptchar
                mov     dtx, #"$"
                call    #dtx_char
                pop     dtx
                shr     dtx, #8
                call    #dtx_hexbyte                    ' Output USB rx data byte
                call    #dtx_newline
                loc     ptra, #@sz_ret
                call    #dtx_asciiz
                mov     dtx, dpar2                      ' Fetch the debug data
                call    #dtx_hexlong
                call    #dtx_newline
                ret
' */
}
' /* dpulse_led
'------------------------------------------------------------------------------
' Blink Prop123-A9 LED12 while the driver is in the disconnected/idle state.
'------------------------------------------------------------------------------
dpulse_led
                drvnot  #DRIVER_WAIT_LED
                getct   dct3
        _ret_   addct3  dct3, ##PULSE_TIME
' */
' #endregion DAT (Class Driver HubExec)
' #region CON (Class Driver)
con
'------------------------------------------------------------------------------
' Serial I/O, if required, is part of the class driver. Default output text
' newline behavior is that every carriage return (CR) code encountered implies
' that a line feed character will follow.
' NOTE: The Parallax Serial Terminal (PST) treats the carriage return character
' as newline. In the Preferences->Functions Tab you can deselect the Line Feed
' character to prevent the double spacing of output text lines.
'------------------------------------------------------------------------------
        _3M_8b       = round(SYSCLOCK / 3_000_000.0 * 65536.0) & $fffffc00 | 7
        _2M_8b       = round(SYSCLOCK / 2_000_000.0 * 65536.0) & $fffffc00 | 7
        _1_5M_8b     = round(SYSCLOCK / 1_500_000.0 * 65536.0) & $fffffc00 | 7
        _1M_8b       = round(SYSCLOCK / 1_000_000.0 * 65536.0) & $fffffc00 | 7
        _115_200_8b  = round(SYSCLOCK / 115_200.0 * 65536.0) & $fffffc00 | 7
        TX           = 62                       ' Standard P2 tx/rx pins
        RX           = 63
' ASCII control codes.
        BELL  = $07
        BSP   = $08
        TAB   = $09
        LF    = $0a
        CR    = $0d                             ' PST: single CR is newline
        GOTOX = $0e                             ' PST: position cursor to column X
        GOTOY = $0f                             ' PST: position cursor to row Y
        CLS   = $10                             ' PST: clear screen cmd
        ESC   = $1b
        USE_GOTOX = 1   ' If non-zero use the PST GOTOX cursor positioning function to update
                        ' mouse position data without line scrolling, otherwise a carriage
                        ' return without a line feed will be transmitted.
'------------------------------------------------------------------------------
' Serial text output option bit positions:
'------------------------------------------------------------------------------
        #0, APPEND_CRB, PREPEND_0XB, IN_PARENSB, UNI_TXTB, TX_VERBOSEB, MSCROLLB
' Option bitflags (active high):
        APPEND_CRF   = |< APPEND_CRB            ' Value->text append CR char
        PREPEND_0XF  = |< PREPEND_0XB           ' Prepend "0x" to hexadecimal output, "0b" to binary output
        IN_PARENSF   = |< IN_PARENSB            ' Enclose the value in parentheses
        UNI_TXTF     = |< UNI_TXTB              ' Unicode text word
        TX_VERBOSEF  = |< TX_VERBOSEB           ' Parse connected device descriptor and config descriptor chain
        MSCROLLF     = |< MSCROLLB              ' Enable line scrolling of mouse button states and X/Y direction/velocity
' Pushbutton option startup defaults:
        OPT_VERBOSE = TX_VERBOSEF               ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
'        OPT_VERBOSE = 0                         ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
'        OPT_MSCROLL = MSCROLLF                  ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
        OPT_MSCROLL = 0                         ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
'------------------------------------------------------------------------------
' USB HID keyboard and/or mouse class driver using the boot protocol.
' Constants specific to the HID Class driver:
'------------------------------------------------------------------------------
' A task progression list that is specific to this type of class driver. When
' the host cog enumerates a device, the class driver is notified when the
' Device Descriptor and the Configuration Descriptor have been read, always in
' that order. After both notifications have been received, the class driver
' must define the tasks that will parse the descriptor(s) to determine if the
' device is compatible with the class driver. If not, the host should be
' notified that the device is "unknown" FIXME: unknown not yet handled.
'
' If the device is compatible, the task list is used as a way for the class
' driver to do what is necessary to configure the device for its intended
' function. Each task routine in the list is responsible for setting the task
' that follows it, if there is one. The final task in the list is typically
' akin to a "main" processing routine that calls other routines which post the
' relevant USB transactions needed to implement the device's functions. This
' task runs until the host cog notifies the class driver that the device has
' been reset or disconnected.
'------------------------------------------------------------------------------
        #0, DT_IDLE, DT_SET_CONF, DT_POLL_DATA
' Mark end of task list.
        DT_END = DT_POLL_DATA
'------------------------------------------------------------------------------
' Keyboard interrupt endpoint poll interval and auto-repeat timing. Since the
' interrupt IN transactions are executed on a timed basis, use that to
' calculate auto-repeat initial delay and repeat rate.
'------------------------------------------------------------------------------
        KBD_POLL_INTERVAL = _1ms * 8            ' Interrupt IN txn timespan
        KBD_REPEAT_DELAY  = 62                  ' 62 * 8ms = 496ms initial delay
        KBD_REPEAT_RATE   = 5                   ' 5 * 8ms = 40ms repeat rate
'------------------------------------------------------------------------------
' Mouse interrupt endpoint poll interval:
'------------------------------------------------------------------------------
        MOUSE_POLL_INTERVAL = _1ms * 8          ' Interrupt IN txn timespan
        MOUSE_NAK_DELAY     = 62                ' USER_LED feedback blink delay uses the NAK count
' #endregion CON (Class Driver)
' #region DAT (Class Driver Cog)
dat
                orgh
                alignl
                org
' /* hid_driver
'------------------------------------------------------------------------------
' The USB HID driver cog.
'------------------------------------------------------------------------------
hid_driver
                drvh    #LED3                           ' DEBUG
                waitx   ##_1ms * 5000                   ' Delay to allow time to get the serial terminal ready to receive
                fltl    #LED3                           ' DEBUG
                call    #serial_init                    ' Init serial output and send startup splash text to terminal
                call    #load_kbd_lut                   ' Copy keyboard conversion table to LUT
                wrlut   #D_READY, #D_EVENT              ' Reset shared LUT eventID
                setluts #LSHARE_WRITE                   ' Allow host cog to write this LUT
                setse1  #D_EVENT_WR1FD                  ' Host write to LUT location D_EVENT triggers this event
                dirl    #PB3
                mov     dpar1, #OPT_VERBOSE             ' Default verbose terminal output option flag
                or      dtxopts, dpar1
                mov     dpar1, #TX_VERBOSEB
                loc     ptra, #@sz_verbose_opt
                call    #dtx_opt_toggle
                dirl    #PB2
                mov     dpar1, #OPT_MSCROLL             ' Default mouse button and X/Y position/velocity scroll option flag
                or      dtxopts, dpar1
                mov     dpar1, #MSCROLLB
                loc     ptra, #@sz_mscroll_opt
                call    #dtx_opt_toggle
                call    #dpulse_led
'------------------------------------------------------------------------------
hid_main
                pollct3                         wc
        if_c    call    #dpulse_led
                pollse1                         wc
        if_c    call    #do_devent                      ' The host cog has posted an event
                cmp     dtask, #DT_IDLE         wz
        if_nz   call    #do_task                        ' Process the current task
                cmp     device_base, #0         wz
        if_z    call    #check_buttons                  ' Option buttons only active when a device is not connected
                jmp     #hid_main
' */
' /* post_hevent
'------------------------------------------------------------------------------
' Post an eventID to the host cog.
'------------------------------------------------------------------------------
' On entry: Reg devent: eventID to post.
'           Regs dpar1, dpar2 and dpar3: required parameters, if any.
' On exit:
'------------------------------------------------------------------------------
post_hevent
                rdlut   dtmp, #H_EVENT          wz      ' Wait for any pending host event to complete
        if_nz   jmp     #post_hevent
                wrlut   dpar1, #H_PAR1
                wrlut   dpar2, #H_PAR2
                wrlut   dpar3, #H_PAR3
        _ret_   wrlut   devent, #H_EVENT                ' This LUT location is a write event trigger
' */
' /* do_devent
'------------------------------------------------------------------------------
' Handler jump table for events posted to the driver by the host cog.
'------------------------------------------------------------------------------
do_devent
                rdlut   devent, #D_EVENT        wz
        if_z    ret                                     ' Zero is a nop
                rdlut   dpar1, #D_PAR1
                rdlut   dpar2, #D_PAR2
                rdlut   dpar3, #D_PAR3
                fle     dtmp, #D_END
                push    #devent_exit                    ' Event handlers return here
                jmprel  devent
devent_jmp
                ret                                     ' EventID zero is a NOP
                jmp     #htx_asciiz                     ' Host requested string output to terminal
                jmp     #htx_break                      ' Send host debug data to terminal, then halt
                jmp     #htx_dbg_data                   ' Send host debug data to terminal
                jmp     #htx_hexdump                    ' Dump raw data to terminal
                jmp     #connect_info
                jmp     #dev_disconnect
                jmp     #parse_dev_desc                 ' Parse string data in the device descriptor
                jmp     #parse_con_desc                 ' Parse config descriptor to determine if it's a known device class
                jmp     #get_dtxn_result                ' Get DTXN_RESULT event data and jump to IRP result handler routine
                jmp     #get_dtxn_hresult               ' DTXN_HRESULT is a way for the host to route processing results directly to the terminal
devent_exit
        _ret_   wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
' */
' /* do_task
'------------------------------------------------------------------------------
' Handler jump table for tasks that this class driver understands. All jump
' targets are implemented as CALL targets.
'------------------------------------------------------------------------------
do_task
                fle     dtask, #DT_END
                jmprel  dtask
.dtask_jmp
                ret                                     ' TaskID zero is a NOP
                jmp     #dset_config                    ' Configure (or not) a newly-connected device
                jmp     #dpoll_data                     ' Manage required data I/O for this class driver
dtask_idle
        _ret_   mov     dtask, #DT_IDLE
' */
' /* check_buttons
'------------------------------------------------------------------------------
' Prop123-A9 board pushbutton options.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
check_buttons
                call    #scan_buttons
                cmp     dr0, #0                 wz
        if_z    ret                                     ' No button pressed
                cmp     dr0, #PB3               wz
        if_z    jmp     #.pb3
.pb2
                loc     ptra, #@sz_mscroll_opt
                mov     dpar1, #MSCROLLB
                jmp     #.exit
.pb3
                loc     ptra, #@sz_verbose_opt
                mov     dpar1, #TX_VERBOSEB
.exit
                bitnot  dtxopts, dpar1
                call    #dtx_opt_toggle
.wait_up
                testp   dr0                     wc
        if_nc   jmp     #.wait_up                       ' Button still pressed (active low)
                waitx   ##_1ms
        _ret_   mov     dr0, #0
'------------------------------------------------------------------------------
' Output a pushbutton description and on/off state to the serial terminal.
'------------------------------------------------------------------------------
' On entry: Reg ptra: the address of the option description string.
'           Reg dpar1: the bitflag state of the option.
' On exit:
'------------------------------------------------------------------------------
dtx_opt_toggle
                call    #dtx_asciiz
                testb   dtxopts, dpar1          wc
        if_nc   loc     ptra, #@sz_off
        if_c    loc     ptra, #@sz_on
                jmp     #dtx_asciiz
' */
' /* scan_buttons
'------------------------------------------------------------------------------
' Poll monitored buttons for pressed state (active low).
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg dr0: pin# of the pressed button, otherwise zero.
'------------------------------------------------------------------------------
scan_buttons
                loc     ptra, #@button_list
.next
                rdbyte  dr0, ptra++             wz
        if_z    ret                                     ' No more buttons to check
                testp   dr0                     wc
        if_c    jmp     #.next                          ' Not pressed
                waitx   ##_1ms * 10                     ' Debounce press
                testp   dr0                     wc
        if_c    jmp     .next                           ' No longer pressed, so treat as false press and test next button
                ret                                     ' Process the pressed button
' */
' /* connect_info
'------------------------------------------------------------------------------
' Host notification that a device has connected. Initialize whatever is
' required prior to configuring the device.
'------------------------------------------------------------------------------
' On entry: Reg devent: eventID.
'           Reg dpar1: speed of the connected device.
' On exit:
'------------------------------------------------------------------------------
connect_info
                drvh    #DRIVER_WAIT_LED                ' DEBUG: show that the driver sees the device connect
                cmp     dpar1, #USB_SPEED_LOW   wz
        if_z    loc     ptra, #@sz_lowspeed
        if_nz   loc     ptra, #@sz_fullspeed
                call    #dtx_asciiz
                mov     pa, #dreg_init_start            ' First cog register address of consecutive
.loop                                                   ' registers to reset to zero
                altd    pa                              ' Use pointer-based register indirection
                mov     0-0, #0                         ' Reset register content to zero
                add     pa, #1
                cmp     pa, #dreg_init_end      wz
        if_nz   jmp     #.loop                          ' Until end of register block reached
' Reset the USB mouse/keyboard interface in hub RAM
                setq    #8 - 1                          ' Interface is 4 mouse and 4 keyboard longs
                wrlong  dmouse_count, ##@mouse_count    ' Use registers reset in above loop for cog->hub block write
                ret
' */
' /* dev_disconnect
'------------------------------------------------------------------------------
' Host notification that a device was reset or has disconnected.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dev_disconnect
                call    #dpulse_led                     ' DEBUG: show that the driver sees the device disconnect
                fltl    #DRIVER_MOUSE_LED
                fltl    #DRIVER_KBD_LED
                wrlut   #D_READY, #D_EVENT              ' Reset shared LUT eventID
                mov     dtask, #DT_IDLE                 ' Disconnect means nothing to do
                mov     device_base, #0                 ' Invalidate current device
                loc     ptra, #@sz_disconnect
                jmp     #dtx_asciiz                     ' Send disconnect message to the terminal
' */
' /* dpoll_data
'------------------------------------------------------------------------------
' Post interrupt IN transactions at configured intervals.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dpoll_data
                cmp     kbd_ep_addr, #0         wz
        if_z    jmp     #.mouse                         ' No keyboard connected
                jnct1   #.mouse                         ' Nothing to do yet
                getct   dct1
                addct1  dct1, ##KBD_POLL_INTERVAL       ' Set the timer for next poll interval
                jmp     #dget_kbd_in_report             ' Post IN txn and return to caller
.mouse
                cmp     mouse_ep_addr, #0       wz
        if_z    ret                                     ' No mouse connected
                pollct2                         wc
        if_nc   ret                                     ' Nothing to do
                cmp     kbd_ep_addr, #0         wz
        if_nz   mov     dct2, dct1                      ' Keyboard/mouse combo, so stagger poll intervals
        if_nz   addct2  dct2, ##_1ms * 4                ' Try to keep 4ms timespan between them
        if_z    getct   dct2
        if_z    addct2  dct2, ##MOUSE_POLL_INTERVAL     ' Mouse is the only connected device
                jmp     #dget_mouse_in_report           ' Post IN txn and return to caller
' */
' /* dget_kbd_in_report
'------------------------------------------------------------------------------
' Post an IN interrupt request to the host to poll for keyboard activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dget_kbd_in_report
                mov     dtask, #DT_IDLE
                mov     devent, #HINT_IN
                mov     dpar1, kbd_ep_addr
                mov     dpar2, ##kbd_cur_report
                rdbyte  dtmp, ##kbd_in_max_pkt          ' Always ask for max report size
                rdbyte  dpar3, ##kbd_next_datax
                setword dpar3, dtmp, #1                 ' Max IN packet size to expect
                mov     dres_handler, ##res_kbd_in
                jmp     #post_hevent
res_kbd_in
' DEBUG: rarely, a zero-length packet shows up with ACK, which shouldn't happen.
' I don't yet know why, but the short term fix is to just ignore it...
                mov     kbd_ep_addr, dpar1              ' Get address with calculated CRC
                cmp     dpar3, #0               wz
        if_z    cmp     dpar2, #PID_ACK         wz
        if_nz   jmp     #.do_in
        _ret_   mov     dtask, #DT_POLL_DATA
'                mov     dtask, #DT_POLL_DATA            ' DEBUG
'                jmp     #dtx_txn_result                 ' DEBUG
.do_in
                cmp     dpar2, #PID_ACK         wz
        if_z    jmp     #.data
                cmp     dpar2, #PID_NAK         wz
        if_z    jmp     #.nak
                loc     ptra, #@sz_intin_result
                jmp     #dtx_result_to_con              ' Something other than ACK/NAK, so likely fatal
' The NAK count is used to determine when key auto-repeat kicks in.
.nak
                mov     dtask, #DT_POLL_DATA
                add     kbd_poll_cnt, #1
                cmp     kbd_poll_cnt, kbd_repeat wcz
        if_b    ret                                     ' No auto-repeat action
                cmp     kbd_poll_cnt, ##KBD_REPEAT_DELAY wz
        if_z    drvnot  #DRIVER_KBD_LED                 ' DEBUG: pulse USER_LED when keyboard activity
                rdbyte  dpar1, ##kbd_last_key           ' Peek at the last key-down keycode
                cmp     dpar1, #KEY_CAPSLK      wz
        if_z    mov     dpar1, #KEY_NO_KEY
                cmp     dpar1, #KEY_NO_KEY      wz
        if_z    mov     kbd_repeat, ##KBD_REPEAT_DELAY  ' Key repeat delay reset on KEY_NO_KEY
        if_z    mov     kbd_poll_cnt, #0
        if_z    ret
                add     kbd_repeat, ##KBD_REPEAT_RATE   ' Set the next repeat interval
                jmp     #sendkey                        ' Repeat the key being held down and return to caller
.data
                drvnot  #DRIVER_KBD_LED                 ' DEBUG: pulse USER_LED when keyboard activity
                rdbyte  dpar1, ##kbd_next_datax
                cmp     dpar1, #PID_DATA0       wz
        if_z    mov     dpar1, #PID_DATA1               ' Txn success, so toggle DATAx
        if_nz   mov     dpar1, #PID_DATA0
                wrbyte  dpar1, ##kbd_next_datax
                wrbyte  dpar3, ##kbd_max_index          ' Save actual bytes read
                call    #kbd_compare                    ' Check keypress activity since last IN
.led_check
                rdbyte  dtmp, ##kbd_led_states
                cmp     dkbd_ledstates, dtmp    wz
        if_z    mov     dtask, #DT_POLL_DATA
        if_z    ret                                     ' No toggle key indicator changes, so we're done
                wrbyte  dkbd_ledstates, ##kbd_led_states' Update toggle key indicator states
                mov     dres_handler, ##res_kbdled1     ' Send USB transaction to set/clear keyboard LEDs affected
                jmp     #dset_kbdled_report
res_kbdled1
                cmp     dpar2, #PID_ACK         wz
        if_nz   loc     ptra, #@sz_setrept_output
        if_nz   jmp     #dtx_result_to_con              ' FIXME: on !ACK try to recover instead of punting to idle state
                mov     dtask, #DT_POLL_DATA            ' ACK, so back to device poll task
                mov     dtx, #BELL
                jmp     #dtx_char
{
dtx_kbd_data
.loop
                rdbyte  dtx, ptrb++
                call    #dtx_hexbyte
                mov     dtx, #" "
                call    #dtx_char
                djnz    dpar3, #.loop                   ' Txn result reg dpar3 has actual bytes in report
                ret
}
' */
' /* dget_mouse_in_report
'------------------------------------------------------------------------------
' Post an IN interrupt request to the host to poll for mouse activity.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
dget_mouse_in_report
                mov     dtask, #DT_IDLE
                mov     devent, #HINT_IN
                mov     dpar1, mouse_ep_addr
                mov     dpar2, ##mouse_cur_report
                rdbyte  dtmp, ##mouse_in_max_pkt        ' Always ask for max report size
                rdbyte  dpar3, ##mouse_next_datax       ' Word0 DATAx PID to expect
                setword dpar3, dtmp, #1                 ' Word1 max IN packet size to expect
                mov     dres_handler, ##res_mouse_in
                jmp     #post_hevent
res_mouse_in
                mov     mouse_ep_addr, dpar1            ' Get address with calculated CRC
                cmp     dpar2, #PID_ACK         wz
        if_z    jmp     #.data
                cmp     dpar2, #PID_NAK         wz
        if_z    jmp     #.nak
                loc     ptra, #@sz_intin_result
                cmp     dpar2, #ERR_TXN_RETRY   wz      ' FIXME: full-speed will sometimes miss > 3 packets
        if_z    jmp     #.nak                           ' FIXME: shouldn't ignore this error when > 80MHz
                jmp     #dtx_result_to_con              ' Something other than ACK/NAK, so likely fatal
.nak
                add     mouse_poll_cnt, #1
                cmp     mouse_poll_cnt, ##MOUSE_NAK_DELAY  wcz
        if_ae   drvnot  #DRIVER_MOUSE_LED               ' DEBUG: pulse USER_LED when mouse activity
        if_ae   mov     mouse_poll_cnt, #0
        _ret_   mov     dtask, #DT_POLL_DATA
'------------------------------------------------------------------------------
' Serial output of the mouse data packet. Uses the Propeller Serial Terminal
' screen control codes to refresh the output without scrolling the screen.
'------------------------------------------------------------------------------
.data
' DEBUG: some devices may return a zero-length packet with ACK, which I'm not
' sure is "legal" or not. The easiest fix is to just treat it as a NAK...
                cmp     dpar3, #0               wz
        if_z    jmp     #.nak                           ' FIXME: ignore empty packet
                mov     mouse_poll_cnt, #0
                drvnot  #DRIVER_MOUSE_LED               ' DEBUG: pulse USER_LED when mouse activity
                rdbyte  dpar1, ##mouse_next_datax
                cmp     dpar1, #PID_DATA0       wz
        if_z    mov     dpar1, #PID_DATA1               ' ACK, so toggle DATAx
        if_nz   mov     dpar1, #PID_DATA0
                wrbyte  dpar1, ##mouse_next_datax
                call    #mouse_compare
                cmp     drep, #0                wz
        if_nz   jmp     #.nak                           ' No changes, so we're done
                testb   dtxopts, #MSCROLLB      wc
        if_c    jmp     #.data_out
' Inhibit scrolling of mouse data output text
                mov     dtx, #USE_GOTOX         wz      ' Do we use PST GOTOX command or not?
        if_z    mov     dtx, #CR
        if_z    call    #dtx_rawchar                    ' For most terminals, a lone CR does what we want
        if_nz   mov     dtx, #0                         ' Use PST GOTOX function to position cursor at column zero
        if_nz   call    #dtx_gotox
.data_out
                loc     ptra, #@sz_mouse_hdrd0          ' DEBUG
                call    #dtx_asciiz                     ' DEBUG
                push    min_digits                      ' DEBUG
                mov     min_digits, #10                 ' DEBUG
                mov     dtx, dmouse_count               ' DEBUG
                call    #dtx_decimal                    ' DEBUG
                pop     min_digits                      ' DEBUG
                loc     ptra, #@sz_mouse_hdrd1          ' DEBUG
'                loc     ptra, #@sz_mouse_hdr0
                call    #dtx_asciiz
                loc     ptrb, #@mouse_cur_report
                rdbyte  dmouse_btnflgs, ptrb++          ' Button bitflags
                mov     dtx, dmouse_btnflgs             ' Output mouse button states
                mov     drep, #8                        ' Show all eight button flags
                call    #dtx_bin
                loc     ptra, #@sz_mouse_hdr1
                call    #dtx_asciiz
                rdbyte  dmouse_x, ptrb++                ' X direction/velocity
                signx   dmouse_x, #7                    ' Sign extend, min -127, max 127
                fges    dmouse_x, ##-127                ' -128 is considered an invalid value
                mov     min_digits, #3
                mov     dtx, dmouse_x
                call    #dtx_decimal_s
                loc     ptra, #@sz_mouse_hdr2
                call    #dtx_asciiz
                rdbyte  dmouse_y, ptrb++                ' Y direction/velocity
                signx   dmouse_y, #7
                fges    dmouse_y, ##-127
                mov     min_digits, #3
                mov     dtx, dmouse_y
                call    #dtx_decimal_s                  ' Y value to terminal
' Publish the updated mouse position and button flags to the public interface in hub RAM
                add     dmouse_count, #1                ' Increment to signal client(s) there's a new mouse event
                setq    #4 - 1                          ' Four cog registers in fast block write
                wrlong  dmouse_count, ##@mouse_count
                mov     dtask, #DT_POLL_DATA
                testb   dtxopts, #MSCROLLB      wc
        if_c    jmp     #dtx_newline                    ' Scroll the mouse data output and back to caller
                ret
{
                sub     dpar3, #3               wz      ' Bytes 0..2 in boot protocol interpreted the same for all
        if_z    jmp     #.eol                           ' Report bytes 3..N are allowed but device specific
                loc     ptra, #@sz_mouse_hdr3
                call    #dtx_asciiz
                call    #dtx_kbd_data                   ' Use keyboard routine to dump remaining data and return to caller
.eol
                mov     drep, #4
                mov     dtx, #" "                       ' Pad end of line as X/Y output is not a constant width
                call    #dtx_rptchar                    ' Propeller Serial Terminal code to prohibit line scroll
}
' */
' /* get_dtxn_hresult
'------------------------------------------------------------------------------
' Retrieve the results of a USB transaction submitted via the event mechanism.
' NOTE: The host must use this eventID BEFORE the device has been configured.
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg dpar1: CRC5/ep/addr for the txn.
'           Reg dpar2: result code for the txn or error code.
'           Reg dpar3: content depends on the result context.
'------------------------------------------------------------------------------
get_dtxn_hresult
                rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
                rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
                rdlut   dpar3, #D_PAR3                  ' Host active/idle state
                wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
                mov     ptra, dpar1
                jmp     #dtx_result_to_con              ' Result routed to the terminal
' */
' /* get_dtxn_result
'------------------------------------------------------------------------------
' Retrieve the results of a USB transaction submitted via the event mechanism.
' NOTE: The host must use this eventID AFTER the device has been configured.
'------------------------------------------------------------------------------
' On entry:
' On exit:  Reg dpar1: CRC5/ep/addr for the txn.
'           Reg dpar2: result code for the txn.
'           Reg dpar3: content depends on the result context.
'------------------------------------------------------------------------------
get_dtxn_result
                rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
                rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
                rdlut   dpar3, #D_PAR3                  ' Context dependent value
                wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
                jmp     dres_handler                    ' Off to the result handler
' */
' /* dtx_dbgval
'------------------------------------------------------------------------------
' Output class driver debug value (driver does not halt).
'------------------------------------------------------------------------------
' On entry: Reg dpar3: arbitrary debug value.
' On exit:
'------------------------------------------------------------------------------
dtx_dbgval
                loc     ptra, #@sz_breakd
                call    #dtx_asciiz
                mov     dtx, dpar3
                jmp     #dtx_hexlong
' */
' /* dtx_asciiz
'------------------------------------------------------------------------------
' Output an ASCIIZ string to the terminal.
'------------------------------------------------------------------------------
' On entry: Reg PTRA: address of first byte of the string.
' On exit:
'------------------------------------------------------------------------------
dtx_asciiz
                rdbyte  dtx, ptra++             wz
        if_z    ret
                call    #dtx_char
                jmp     #dtx_asciiz
' */
' /* dtx_char
'------------------------------------------------------------------------------
' Output a character to the terminal. A carriage return character ($0D)
' encountered here should be translated to whatever your particular terminal
' expects as a newline sequence.
'------------------------------------------------------------------------------
dtx_char
                testp   #TX                     wc
        if_nc   jmp     #dtx_char
                and     dtx, #$ff                       ' Ensure limited to extended ASCII space
                wypin   dtx, #TX
                cmp     dtx, #CR                wz
        if_nz   ret
                mov     dtx, #LF                        ' Translate CR to CRLF
                jmp     #dtx_char
' /* dtx_newline
'------------------------------------------------------------------------------
' For those times you just want to start a new line.
'------------------------------------------------------------------------------
dtx_newline
                mov     dtx, #CR
                jmp     #dtx_char
' */
' /* dtx_rawchar
'------------------------------------------------------------------------------
' Output a single byte to the serial port without any translation.
'------------------------------------------------------------------------------
dtx_rawchar
                testp   #TX                     wc
        if_nc   jmp     #dtx_char
                and     dtx, #$ff                       ' Ensure limited to extended ASCII space
        _ret_   wypin   dtx, #TX
' */
' /* dtx_rptchar
'------------------------------------------------------------------------------
' Output character, repeated n times.
'------------------------------------------------------------------------------
' On entry: Reg dtx: character to transmit.
'           Reg drep: contains the repeat count.
' On exit:
'------------------------------------------------------------------------------
dtx_rptchar
                call    #dtx_char
                djnz    drep, #dtx_rptchar
                ret
' */
' /* dtx_cls
'------------------------------------------------------------------------------
' Clear the terminal screen (PST specific).
'------------------------------------------------------------------------------
dtx_cls
                mov     dtx, #CLS
                jmp     #dtx_char
' */
' /* dtx_gotox
'------------------------------------------------------------------------------
' Position the cursor at column X of the terminal screen (PST specific).
'------------------------------------------------------------------------------
' On entry: Reg dtx: the new column position for the cursor.
'------------------------------------------------------------------------------
dtx_gotox
                push    dtx                             ' Save new column position
                mov     dtx, #GOTOX
                call    #dtx_char                       ' Send GOTOX command to PST
                pop     dtx
                jmp     #dtx_rawchar                    ' Send byte as-is and return to caller
' */
' /* dtx_decimal_s, dtx_decimal
'------------------------------------------------------------------------------
' Convert a signed/unsigned 32-bit decimal value to text. Leading zeros are
' skipped on output. Based on a routine written by Ozpropdev.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert to decimal characters.
'           Reg min_digits: if the value has fewer than min_digits, pad with
'           leading zeroes.
' On exit:
'------------------------------------------------------------------------------
dtx_decimal_s
                mov     dtmp, dtx
                testb   dtx, #31                wc
        if_c    mov     dtx, #"-"
        if_nc   mov     dtx, #"+"
                negc    dtmp                            ' If negative, back to positive for output
                call    #dtx_char
                mov     dtx, dtmp
dtx_decimal
                mov     dr0, ##1_000_000_000            ' Divisor
                mov     dr1, #0                         ' Reg dr1 holds digit postions 7..0
                mov     drep, #10                       ' Max of 10 digit output
                fle     min_digits, #10                 ' FIXME: should throw out-of-range error
                fge     min_digits, #1
                mov     dr3, #0
                rep     @.end, #10
                qdiv    dtx, dr0
                getqx   dtmp                    wz
        if_nz   add     dr3, #1                         ' Becomes non-zero at first leading non-zero digit
                cmp     dr3, #0                 wz
        if_z    sub     drep, #1                        ' Decrement digit count if it's a leading zero
.getqy
                getqy   dtx
                rolnib  dr2, dr1, #7                    ' Reg dr2 holds digit postions 9..8
                rolnib  dr1, dtmp, #0
                qdiv    dr0, #10
                getqx   dr0
.end
                fge     drep, min_digits                ' Pad with zeroes as necessary to meet minimum digit count
                cmp     drep, #9                wcz
        if_b    jmp     #.r1out
                mov     dr3, drep
                sub     drep, #8                        ' Get count of digits > 8
                mov     dtx, dr2
                call    #dtx_hex
                mov     drep, dr3
.r1out
                mov     min_digits, #1                  ' Reset to minimum digit count default
                fle     drep, #8
                mov     dtx, dr1                        ' Output remaining digits
                jmp     #dtx_hex
' */
' /* Output hex nibble/byte/word/long
'------------------------------------------------------------------------------
' Convert to text a 4-bit value as hexadecimal.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_hexnib
                mov     drep, #1
                jmp     #dtx_hex
'------------------------------------------------------------------------------
' Convert to text an 8-bit value as hexadecimal.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_hexbyte
                mov     drep, #2
                jmp     #dtx_hex
'------------------------------------------------------------------------------
' Convert to text a 16-bit value as hexadecimal.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_hexword
                mov     drep, #4
                jmp     #dtx_hex
'------------------------------------------------------------------------------
' Convert to text a 32-bit value as hexadecimal.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_hexlong
                mov     drep, #8
                jmp     #dtx_hex
' */
' /* dtx_hex
'------------------------------------------------------------------------------
' Convert to text one to 8 hexadecimal/decimal digits.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to send.
'           Reg drep: count of nibbles to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_hex
                fge     drep, #1
                fle     drep, #8
                mov     dtmp, drep
                shl     dtmp, #2
                subr    dtmp, #32
                shl     dtx, dtmp                       ' Left justify for output
                mov     dtmp, dtx
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #"("
        if_c    call    #dtx_char
                testb   dtxopts, #PREPEND_0XB   wc
        if_c    loc     ptra, #@sz_0x
        if_c    call    #dtx_asciiz
.loop
                getnib  dtx, dtmp, #7
                cmp     dtx, #9                 wcz
        if_be   add     dtx, #"0"
        if_a    add     dtx, #"A" - 10
                call    #dtx_char
                shl     dtmp, #4                        ' Left justify next nibble
                djnz    drep, #.loop
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #")"
        if_c    call    #dtx_char
                testb   dtxopts, #APPEND_CRB    wc
        if_c    jmp     #dtx_newline
                ret
' */
' /* dtx_bin
'------------------------------------------------------------------------------
' Convert to text one to 32 binary digits. Bits are sent MSb first.
'------------------------------------------------------------------------------
' On entry: Reg dtx: value to convert.
'           Reg drep: count of bits to convert.
' On exit:
'------------------------------------------------------------------------------
dtx_bin
                fle     drep, #32
                fge     drep, #1
                mov     dtmp, dtx
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #"("
        if_c    call    #dtx_char
                testb   dtxopts, #PREPEND_0XB   wc
        if_c    loc     ptra, #@sz_0b
        if_c    call    #dtx_asciiz                     ' Option prepend "0x" to output
                mov     dtx, #32
                sub     dtx, drep
                shl     dtmp, dtx                       ' Left justify to get to MSb
.next
                shl     dtmp, #1                wc      ' Tx MSb->LSb
        if_nc   mov     dtx, #"0"
        if_c    mov     dtx, #"1"
                call    #dtx_char
                djnz    drep, #.next
                testb   dtxopts, #IN_PARENSB    wc
        if_c    mov     dtx, #")"
        if_c    call    #dtx_char
                testb   dtxopts, #APPEND_CRB    wc
        if_c    jmp     #dtx_newline
                ret
' */
' /* htx_asciiz
'------------------------------------------------------------------------------
' Read LUT request queue and output an ASCIIZ string to the terminal.
'------------------------------------------------------------------------------
' On entry: Reg dpar1: start address of string to output.
' On exit:
'------------------------------------------------------------------------------
htx_asciiz
                mov     ptra, dpar1
.next
                rdbyte  dtx, ptra++             wz
        if_z    ret                                     ' Done with string output
                call    #dtx_char
                jmp     #.next
' */
' /* load_kdb_lut
'------------------------------------------------------------------------------
' Cells 0..255 of the shared LUT cells are allocated to the driver cog.
'------------------------------------------------------------------------------
' Copy the keyboard conversion table to LUT at startup.
'------------------------------------------------------------------------------
' On entry:
' On exit:
'------------------------------------------------------------------------------
load_kbd_lut
                mov     drep, ##@kbd_end - 4            ' Hub RAM is byte-aligned
                sub     drep, ##@kbd_table
                shr     drep, #2                        ' SETQ2 N - 1 LUT cell count in longs
                setq2   drep
        _ret_   rdlong  0, ##@kbd_table
' */
' /* Class driver registers
dr0             long    0                               ' Multi-purpose registers
dr1             long    0
dr2             long    0
dr3             long    0
dpar1           long    0                               ' Routine entry/exit parameters
dpar2           long    0
dpar3           long    0
dct1            long    0                               ' Keyboard interrupt IN interval timer
dct2            long    0                               ' Mouse interrupt IN interval timer
dct3            long    0                               ' Driver main loop blinking LED timer
dtxopts         long    0                               ' Value->text conversion option bitflags
min_digits      long    0                               ' Pad with leading zeros if value has fewer than min_digits
dtx             long    0                               ' Character to output
dtmp            long    0
devent          long    0                               ' Command/request eventID posted by the host cog
dres_handler    long    0                               ' Address of an IRP result handler routine
drep            long    0                               ' Repeat count
con_tot_len     long    0                               ' Size of the complete config descriptor chain
hid_intf_idx    long    0                               ' Used during verbose descriptor terminal output
search_key      long    0                               ' Descriptor type to search for in the config chain
next_desc       long    0                               ' Offset from the config descriptor start address to the next descriptor in the chain
langid          long    0                               ' Keep LangID stickey
ctrl_ep_addr    long    0                               ' Ep/addr for control transactions
'------------------------------------------------------------------------------
' Define registers you want initialized to zero at device reset/disconnect
' between labels dreg_init_start/dreg_init_end.
'------------------------------------------------------------------------------
dreg_init_start
dtask           long    0                               ' Class driver's current task focus
device_base     long    0                               ' Base address for the device descriptor buffer
config_base     long    0                               ' Base address for config descriptor chain buffer
kbd_ep_addr     long    0
kbd_report      long    0                               ' Address of report descriptor data for the keyboard interface
kbd_poll_cnt    long    0                               ' Poll interval counter used for key auto-repeat
kbd_repeat      long    0                               ' Key auto-repeat delay threshold
mouse_ep_addr   long    0
mouse_report    long    0                               ' Address of report descriptor data for the mouse interface
mouse_poll_cnt  long    0
' The following registers must match the layout of the "public" mouse/keyboard
' interface that's in hub RAM.
dmouse_count    long    0                               ' mouse_count
dmouse_x        long    0                               ' mouse_x
dmouse_y        long    0                               ' mouse_y
dmouse_btnflgs  long    0                               ' mouse_btnflgs
dkbd_count      long    0                               ' kbd_count
dkbd_keypress   long    0                               ' kbd_keypress
dkbd_modkeys    long    0                               ' kbd_modkeys
dkbd_ledstates  long    0                               ' kbd_ledstates
dreg_init_end
' */
                long    DBG_FEEDBEEF                    ' End of used cog space marker
                long    -1[$1f0 - $]                    ' Fill remaining free space with $FFs
                fit     $1f0                            ' Not using interrupt registers
' #endregion DAT (Class Driver Cog)
' #region CON (USB Descriptor Definitions)
con
'------------------------------------------------------------------------------
' USB References:
' Universal Serial Bus Specification, Revision 2.0
'   www.usb.org/developers/docs/usb20_docs/
' Device Class Definition for Human Interface Devices (HID), Version 1.11
'   www.usb.org/developers/hidpage/
'------------------------------------------------------------------------------
' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' Use TYPE_STANDARD for all USB Standard Device Request codes.
'------------------------------------------------------------------------------
' D7 Data direction  | D6:5 Type    | D4:0 Recipient
'------------------------------------------------------------------------------
' 0 - Host-to-device | 0 = Standard | 0 = Device
' 1 - Device-to-host | 1 = Class    | 1 = Interface
'                    | 2 = Vendor   | 2 = Endpoint
'                    | 3 = Reserved | 3 = Other
'                    |              | 4 -31 = Reserved
'------------------------------------------------------------------------------
        DIR_HOST_TO_DEV = 0 << 7
        DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
        TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
        TYPE_CLASS      = %01 << 5
        TYPE_VENDOR     = %10 << 5
        TYPE_RESERVED   = %11 << 5
        RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
        RECIP_INTERFACE = %0_0001
        RECIP_ENDPOINT  = %0_0010
        RECIP_OTHER     = %0_0011
'       RECIP 4 - 31 = Reserved
'------------------------------------------------------------------------------
' Standard Device Request codes (Section 9.4, Table 9-4):
'------------------------------------------------------------------------------
        #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
        REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
        REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
'------------------------------------------------------------------------------
' Standard descriptor types (Section 9.4, Table 9-5):
'------------------------------------------------------------------------------
        #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
        TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
'------------------------------------------------------------------------------
' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
'------------------------------------------------------------------------------
        #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
        CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
        CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
        CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
        CLASS_DIAGNOSTIC_DEV  = $dc
        CLASS_WIRELESS_CTRL   = $e0
        CLASS_MISCELLANEOUS   = $ef
        CLASS_APP_SPECIFIC    = $fe
        CLASS_VENDOR_SPECIFIC = $ff
'------------------------------------------------------------------------------
' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
'------------------------------------------------------------------------------
        #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
        HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
' HID Descriptor types:
        #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
'------------------------------------------------------------------------------
' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
'------------------------------------------------------------------------------
        #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
'------------------------------------------------------------------------------
' HID Interface SubClasses:
'------------------------------------------------------------------------------
        #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
'------------------------------------------------------------------------------
' HID Protocol codes:
'------------------------------------------------------------------------------
        #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
        #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
'------------------------------------------------------------------------------
' Other HID buffer lengths:
'------------------------------------------------------------------------------
        MAX_HID_REPTS   = 4             ' We have this many HID report buffers
        REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
        REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
        LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
        USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
'------------------------------------------------------------------------------
' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
'------------------------------------------------------------------------------
        LANG_ENG_US  = $0409            ' English (United States)
        LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
'------------------------------------------------------------------------------
' SETUP structure member offsets.
' NOTE: These offsets are defined in terms of the structure member's data type,
'       to take advantage of PTRA/B scaled indexing, e.g.:
'         RDBYTE D,   PTRA[bRequest]
'         WRWORD D/#, PTRA[wLength]
'------------------------------------------------------------------------------
        bmRequestType = 0
        bRequest      = 1
        wValue        = 1
        wIndex        = 2
        wLength       = 3
' SETUP bmRequestType combinations:
{
        HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
        DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
        HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
        HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
}
'------------------------------------------------------------------------------
' Standard USB descriptor structure sizes in bytes. The values defined are the
' minimum size of the descriptor:
'------------------------------------------------------------------------------
        SETUP_TXN_LEN = 8
        DEV_DESC_LEN  = 18
        CON_DESC_LEN  = 9
        INTF_DESC_LEN = 9
        ENDP_DESC_LEN = 7
        STR0_DESC_LEN = 4
        USTR_DESC_LEN = 4
'------------------------------------------------------------------------------
' Other USB-related buffer sizes:
'------------------------------------------------------------------------------
        URX_BUFF_LEN = 128      ' USB receiver scratch buffer
        CON_BUFF_LEN = 255      ' Entire configuration descriptor chain
'------------------------------------------------------------------------------
' CON_bmAttrs member bit positions:
'------------------------------------------------------------------------------
        ATTR_RESVB     = 7      ' Reserved (should always be one)
        ATTR_SELF_PWRB = 6      ' Device Self-Powered
        ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
'       bmAttributes bits 4..0 reserved and reset to zero
'------------------------------------------------------------------------------
' Standard USB descriptor struct member offset and member size, in bytes. Note
' that the DESC_bLength and DESC_bDescType members are defined in all of the
' descriptors (including HID) at the offsets shown.
'------------------+
' !!! IMPORTANT !!!|
'------------------+
' All standard descriptor member offsets are defined in bytes, so if you want
' to use PTRA/B indexing, it is best to use the unscaled PTRx[##index20] syntax
' so the compiler will invoke AUGS with RDxxxx/WRxxxx, e.g.:
'       RDBYTE D,   PTRA[##DEV_bMaxPktSize0]
'       WRWORD D/#, PTRA[##DEV_bIdProduct]
' It goes without saying that if PTRA/B unscaled indexing is used with pre/post
' increment/decrement, one must be very careful...
'------------------------------------------------------------------------------
'       Member          Offset  Size    Value           Description
'------------------------------------------------------------------------------
        DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
        DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
' Device Descriptor (Section 9.6.1, Table 9-8):
        DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
        DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
        DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
        DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
        DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
        DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
        DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
        DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
        DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
        DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
        DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
        DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
' Configuration Descriptor (Section 9.6.3, Table 9-10):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
        CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
        CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
        CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
        CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
        CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
        CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
' Interface Descriptor (Section 9.6.5, Table 9-12):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
        INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
        INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
        INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
        INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
        INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                                '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                                '                       reserved for assignment by the USB-IF.
        INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                                '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                                '                       vendor-specific protocol for this interface.
        INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
' Endpoint Descriptor (Section 9.6.6, Table 9-13):
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
        ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
        ENDP_bmAttrs     = 3    ' 1     Bitmap
        ENDP_wMaxPktSize = 4    ' 2     Number
        ENDP_bInterval   = 6    ' 1     Number
' String Descriptor Zero (Section 9.6.7, Table 9-15):
'       DESC_bLength     = 0    ' 1     N + 2
'       DESC_bDescType   = 1    ' 1     Constant
        STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
' Unicode String Descriptor (Section 9.6.7, Table 9-16):
'       DESC_bLength     = 0    ' 1     N + 2
'       DESC_bDescType   = 1    ' 1     Constant
        USTR_wString     = 2    ' N     wString[(N - 2) / 2]
' HID Descriptor (Section 6.2.1)
'       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
'       DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
        HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
        HID_bCountryCode = 4    ' 1     Number          Hardware target country
        HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
        HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
        HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
' Keyboard and mouse report data buffer lengths (boot protocol):
        KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
        KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
        MOUSE_RPT_LEN   = 8     ' Maximum mouse boot protocol IN data packet size
'------------------------------------------------------------------------------
' USB HID Keyboard/Keypad Page (0x07). The keycodes below are indexes into
' the keycode->character look-up table.
'------------------------------------------------------------------------------
' First four entries in the key lookup table are info/error indicators:
        #0,   KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
' Alpha keycodes are contiguous in the lookup table, and if caps lock key is
' toggled on, these are the only keycodes affected by it:
        KEY_A_a    = $04
        KEY_Z_z    = $1d
' The toggle keys:
        KEY_CAPSLK = $39
        KEY_SCRLK  = $47
        KEY_NUMLK  = $53
'------------------------------------------------------------------------------
' #endregion Con (USB Descriptor Definitions)
' #region DAT (Hub RAM Strings & Buffers)
dat
                        orgh
' Static data:
button_list             byte    PB3, PB2, 0                     ' Prop123-A9 pushbuttons in use
' #region Strings
' /* Startup splash text:
dcog_started            byte    "USB low/full speed host & HID boot protocol keyboard/mouse driver v0.16."
                        byte    CR, "- Button PB3 toggles verbose terminal output on/off."
                        byte    CR, "- Button PB2 toggles mouse data scrolling on/off."
                        byte    CR, "The device must be disconnected before options can be changed.", 0
sz_verbose_opt          byte    CR, "Debug output to terminal is ", 0
sz_mscroll_opt          byte    CR, "Mouse data scroll option is ", 0
sz_off                  byte    "off.", 0
sz_on                   byte    "on.", 0
sz_0x                   byte    "0x", 0
sz_0b                   byte    "0b", 0
sz_unknown_data         byte    CR, " Data:", 0
' */
' /* Status messages:
sz_fullspeed            byte    CR, "<Full-Speed device connected.>", 0
sz_lowspeed             byte    CR, "<Low-Speed device connected.>", 0
sz_disconnect           byte    CR, "<Device disconnected>.", 0
sz_no_txn               byte    CR, "Waiting for txn slot...", 0
sz_generic_result       byte    CR, "Transaction result: ", 0
sz_getdev_result        byte    CR, "GetDescriptor(TYPE_DEVICE): ", 0
sz_getconf_result       byte    CR, "GetDescriptor(TYPE_CONFIG): ", 0
sz_setaddr_result       byte    CR, "SetAddress(): ", 0
sz_getrpt_result        byte    CR, "GetDescriptor(TYPE_REPORT): ", 0
sz_getstr_result        byte    CR, "GetDescriptor(TYPE_STRING): ", 0
sz_setcon_result        byte    CR, "SetConfiguration(): ", 0
sz_setprot_result       byte    CR, "SetProtocol(): ", 0
sz_setidle_result       byte    CR, "SetIdle(): ", 0
sz_intin_result         byte    CR, "InterruptIN(): ", 0
sz_intout_result        byte    CR, "InterruptOUT(): ", 0
sz_setrept_output       byte    CR, "SetReport(TYPE_OUTPUT): ", 0
sz_success              byte    CR, "Success!", 0
sz_bummer               byte    CR, "Bummer! I don't know what to do with this device.", 0
sz_txn_err              byte    "Error ", 0
sz_omit_strs            byte    CR, "The device offers no string descriptors.", 0
sz_ack                  byte    "ACK", 0
sz_nak                  byte    "NAK", 0
sz_stall                byte    "STALL", 0
sz_list_break           byte    ", ", 0
sz_nak_count            byte    CR, "[IN-NAK]: ", 0
sz_woohoo_kbd           byte    CR, "Woo-hoo, found a boot keyboard!", 0
sz_kbd_ready            byte    CR, "Keyboard ready...", 0
sz_kbd_leds             byte    CR, "LED bits: 0b", 0
sz_kbd_data             byte    CR, "Kbd Data: ", 0
sz_woohoo_mouse         byte    CR, "Woo-hoo, found a boot mouse!", 0
sz_mouse_ready          byte    CR, "Mouse ready...", 0
sz_mouse_hdrd0          byte    "Count: ", 0
sz_mouse_hdrd1          byte    ", Buttons: ", 0
sz_mouse_hdr0           byte    ", Buttons: ", 0
sz_mouse_hdr1           byte    ", X: ", 0
sz_mouse_hdr2           byte    ", Y: ", 0
sz_mouse_hdr3           byte    ", Device specific: ", 0
' */
' /* Host debug stuff
'sz_stathdr             byte    CR, "NeES10KJ  Data", CR, 0
'sz_stat                        byte    CR, "USB Status: ", 0
sz_host_stopped         byte    CR, "!!Host has stopped!!", CR, 0
sz_dbg_data             byte    CR, "Debug Data: ", 0
sz_breakh               byte    CR, "Debug Break (Host): $", 0
sz_breakd               byte    CR, "Debug Value (Driver): $", 0
sz_jmptbl_err           byte    CR, "Jump table overrun!", 0
' */
' /* Error code descriptions:
sz_err_none             byte    "The operation completed successfully.", 0
sz_err_urx              byte    "Bit unstuff error, EOP or SE0 > 3 bit-times or SE1.", 0
sz_err_se1              byte    "!USB in illegal SE1 state!", 0
sz_err_packet           byte    "Packet missing or corrupt.", 0
sz_err_tat              byte    "Bus turn-around time exceeded.", 0
sz_err_txn_retry        byte    "Retry limit exceeded, transaction canceled.", 0
sz_err_xfer_retry       byte    "Retry limit exceeded, transfer canceled.", 0
sz_err_out_nak          byte    "OUT-NAK retry limit exceeded.", 0
sz_err_ack_retry        byte    "IN DATAx sync recovery.", CR, 0
sz_err_empty_pkt        byte    "Unexpected empty packet.", CR, 0
sz_err_crc              byte    "CRC16 verify failed.", CR, 0
' String pointer table for error code descriptions:
err_code_text           long    sz_err_none, sz_err_urx, sz_err_se1, sz_err_packet
                        long    sz_err_tat, sz_err_txn_retry, sz_err_xfer_retry
                        long    sz_err_out_nak, sz_err_ack_retry, sz_err_empty_pkt, sz_err_crc
' */
' #endregion Strings
' #region Partially populated SETUP packets
'------------------------------------------------------------------------------
get_dev_desc            byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_GET_DESC
                        word    TYPE_DEVICE << 8
                        word    0       ' Zero or Language ID (Section 9.6.7)
                        word    0       ' Number of bytes to transfer if there is a data stage
get_config_desc         byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_GET_DESC
                        word    TYPE_CONFIG << 8
                        word    0       ' Zero or Language ID (Section 9.6.7)
                        word    0       ' Number of bytes to transfer if there is a data stage
set_config              byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_SET_CONFIG
                        word    0       ' Configuration value
                        word    0       ' Zero
                        word    0       ' Zero, as REQ_SET_CONFIG has no data stage
set_address             byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                        byte    REQ_SET_ADDR
                        word    0       ' Zero
                        word    0       ' Zero
                        word    0       ' Zero, as REQ_SET_ADDR has no data stage
'------------------------------------------------------------------------------
' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
' wValue field dictates which protocol should be used.
'
' When initialized, all devices default to report protocol. However the host
' should not make any assumptions about the device state and should set the
' desired protocol whenever initializing a device.
'------------------------------------------------------------------------------
set_protocol            byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                        byte    HID_SET_PROTO
                        word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                ' (HID 1.11 Section 7.2.6).
                        word    0               ' Interface index number.
                        word    0               ' Zero, as HID_SET_PROTO has no data stage.
'------------------------------------------------------------------------------
set_idle                byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                        byte    HID_SET_IDLE
                        word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                        ' reporting until a change is detected in the report data

                                        ' (HID 1.11 Section 7.2.4).
                        word    0       ' Interface index number.
                        word    0       ' Zero, as HID_SET_IDLE has no data stage.
set_report              byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
                        byte    HID_SET_REPORT
                        word    0       ' Byte1 = report type, byte0 = ReportID.
                                        ' (HID 1.11 Section 7.2.2).
                        word    0       ' Interface index number.
                        word    0       ' Size of the report, in bytes.
' #endregion Partially populated SETUP packets
' #region Data buffers and structures
'------------------------------------------------------------------------------
' Class driver data structure for boot protocol keyboard.
' FIXME: Device endpoint/address and DATAx toggle state probably should be
'        maintained by the host and not the class driver.
'------------------------------------------------------------------------------
kbd_mouse_start
kbd_intf_num            byte    0                       ' Keyboard interface index (zero-based)
kbd_interval            byte    0                       ' Minimum poll interval, in milliseconds
kbd_in_max_pkt          byte    0                       ' Boot protocol IN report max is 8 bytes
kbd_next_datax          byte    0                       ' DATAx PID expected on the next IN transaction
kbd_max_index           byte    0                       ' Actual length of the current IN interrupt packet
kbd_led_states          byte    0                       ' Output report for keyboard toggle key indicator LED states
kbd_cur_report          byte    0[KBD_IN_RPT_LEN]       ' Compare buffers for key down/up detection
kbd_prev_report         byte    0[KBD_IN_RPT_LEN]
kbd_last_key            byte    0                       ' Used for key auto-repeat
' Class driver data structure for boot protocol mouse:
mouse_intf_num          byte    0                       ' Mouse interface index (zero based)
mouse_interval          byte    0                       ' Minimum poll interval, in milliseconds
mouse_in_max_pkt        byte    0                       ' Boot protocol IN report min of three bytes, max of 8
mouse_next_datax        byte    0                       ' DATAx PID expected on the next IN transaction
mouse_cur_report        byte    0[MOUSE_RPT_LEN]        ' Max mouse IN data buffer
mouse_prev_report       byte    0[MOUSE_RPT_LEN]
kbd_mouse_end                                           ' End of keyboard/mouse data block
' The USB data cache area gets zero-filled at every device disconnect.
cache_start
urx_buff                byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
dev_desc_buff           byte    0[DEV_DESC_LEN]         ' Device descriptor
con_desc_buff           byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
cache_end
                alignl
                long    DBG_DEADC0DE    ' Marker for top of hub RAM in use
' #endregion Data buffers and structures
' #endregion DAT (Hub RAM Strings & Buffers)
' #region Data loaded to LUT at startup
'------------------------------------------------------------------------------
' USB HID "boot protocol" mouse/keyboard driver cog data.
'------------------------------------------------------------------------------
' Keyboard/Keypad lookup table.
' Keyboard data gets copied to the class driver cog's LUT at startup, after
' which the block is available for general use.
'------------------------------------------------------------------------------
' HID keyboard/keypad usage page conversion table. This example converts to US
' 7-bit ASCII, intended for serial terminals. Byte1 is the shifted character,
' byte0 is the unshifted character.
'------------------------------------------------------------------------------
dat
                orgh
                alignl
kbd_table
          {$00} long    KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF      ' $03
          {$04} long    $4161, $4262, $4363, $4464                                      ' $07: Aa Bb Cc Dd
          {$08} long    $4565, $4666, $4767, $4868, $4969, $4A6A, $4B6B, $4C6C          ' $0f: Ee Ff Gg Hh Ii Jj Kk Ll
          {$10} long    $4D6D, $4E6E, $4F6F, $5070, $5171, $5272, $5373, $5474          ' $17: Mm Nn Oo Pp Qq Rr Ss Tt
          {$18} long    $5575, $5676, $5777, $5878, $5979, $5A7A, $2131, $4032          ' $1f: Uu Vv Ww Xx Yy Zz !1 @2
          {$20} long    $2333, $2434, $2535, $5E36, $2637, $2A38, $2839, $2930          ' $27: #3 $4 %5 ^6 &7 *8 (9 )0
          {$28} long    $0D0D, $1B1B, $0808, $0909, $2020, $5F2D, $2B3D, $7B5B          ' $2f: Enter Esc BkSpc Tab Spc _- += {[
          {$30} long    $7D5D, $7C5C, $7E23, $3A3B, $2227, $7E60, $3C2C, $3E2E          ' $37: }] |\ ~# :; "' ~` <, >.
          {$38} long    $3F2F, $3939, $3A3A, $3B3B, $3C3C, $3D3D, $3E3E, $3F3F          ' $3f: ?/ CapsLock F1 F2 F3 F4 F5 F6
          {$40} long    $4040, $4141, $4242, $4343, $4444, $4545, $4646, $4747          ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
          {$48} long    $4848, $4949, $4A4A, $4B4B, $087F, $4D4D, $4E4E, $4F4F          ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
          {$50} long    $5050, $5151, $5252, $5353, $2F2F, $2A2A, $2D2D, $2B2B          ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
          {$58} long    $0D0D, $3131, $3232, $3333, $5034, $3535, $3636, $3737          ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
          {$60} long    $3838, $3939, $3030, $7F2E, $5C7C, $6565                        ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App
kbd_end
' #endregion Data loaded to LUT at startup
{{
+------------------------------------------------------------------------------------------------------------------------------+
|                                                   TERMS OF USE: MIT License                                                  |
+------------------------------------------------------------------------------------------------------------------------------+
|Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |
|files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
|modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
|is furnished to do so, subject to the following conditions:                                                                   |
|                                                                                                                              |
|The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
|                                                                                                                              |
|THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
|WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
|COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
|ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
+------------------------------------------------------------------------------------------------------------------------------+
}}
