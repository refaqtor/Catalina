                   '------------------------------------------------------------------------------
                   ' Low/full speed Minimal USBHost with Keyboard/Mouse "boot protocol" support.
                   ' garryj 5/2018
                   ' TABs as space, width: 8.
                   ' Serial terminal: Parallax Serial Terminal
                   ' Prop123-A9 FPGA Board, P2v32 image:
                   '   PB0 = 54 (hardware reset)
                   '   PB1 = 55
                   '   PB2 = 56
                   '   PB3 = 57
                   '   P32..P47 are connected to the green LEDs (LED0..LED15)
                   '------------------------------------------------------------------------------
                   ' Generic loader for the USB host/driver cog pair:
                   '  The host and driver cogs use LUT sharing, so they must be started as an
                   '  adjacent even/odd pair. The usb_start subroutine will attempt to locate and
                   '  start a free cog pair.
                   ' Integration of the USB boot mouse/keyboard code into your own program should
                   '  be relatively simple.
                   '  1 - Adapt the HubExec "usb_start" subroutine call into your startup code.
                   '  2 - Copy USB code and append to your program.
                   '  3 - Fix up any constant/label name collisions.
                   '  4 - Adapt your program to read the mouse/keyboard data from the (Boot
                   '      Protocol Mouse/Keyboard Hub Interface) region, which is located at the
                   '      label mouse_count.
                   '------------------------------------------------------------------------------
                   dat
00000 000                          org
00000 000          loader_entry
00000 000 fd65fe00                 hubset  #$ff                            ' P2v26+ always need to initialize fast clock
00004 001 fda00800                 call    #usb_start                      ' Hub-based subroutine that attempts to locate a free even/odd cog pair
00008 002 fb97ec03                 tjz     pa, #.continue                  ' PA will be zero if free cogs found
0000c 003 f547f6ff                 or      dirb, #$ff                      ' Host/driver cogs not started, show error on LED7..LED0 of P123-A9
00010 004 f547faff                 or      outb, #$ff
00014 005          .error
00014 005 fd9ffffc                 jmp     #.error
00018 006          .continue
00018 006 fd63ec01                 cogid   pa
0001c 007 fd63ec03                 cogstop pa
                   '------------------------------------------------------------------------------
                   ' vvvvvvvvvvvvvvvvvvvvvvvv Copy code from below to EOF vvvvvvvvvvvvvvvvvvvvvvvv
                   '------------------------------------------------------------------------------
                   ' #region (Basics of P2 USB SmartPins)
                   {
                     USB References:
                     Universal Serial Bus Specification, Revision 2.0
                       www.usb.org/developers/docs/usb20_docs/
                     Device Class Definition for Human Interface Devices (HID), Version 1.11
                       www.usb.org/developers/hidpage/
                   
                   Smart pin configuration bits:
                     D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0
                   
                   USB smart pin modes:
                     %11000 = USB host, low-speed
                     %11001 = USB host, full-speed
                     %11010 = USB device, low-speed
                     %11011 = USB device, full-speed
                   
                   These modes require that two adjacent pins be configured together to form a USB pair, whose OUTs
                   will be overridden to control their output states. These pins must be an even/odd pair, having
                   only the LSB of their pin numbers different. For example: pins 0 and 1, pins 2 and 3, pins 4
                   and 5, etc., can form USB pairs. They can be configured via WRPIN with identical D data of
                   %1_110xx_0. Using D data of %0_110xx_0 will disable output drive and effectively create a USB
                   'sniffer'. A new WRPIN can be done to effect such a change without resetting the smart pin.
                   
                   NOTE: in the current FPGA, there are no built-in 1.5k and 15k resistors, which the final silicon
                   smart pins will contain, so it is up to you to insert these yourself on the DP and DM lines.
                   
                   The upper (odd) pin is the DP pin. This pin's IN is raised whenever the output buffer empties,
                   signalling that a new output byte can be written via WYPIN to the lower (even) pin. No
                   WXPIN/WYPIN instructions are used for this pin.
                   
                   The lower (even) pin is the DM pin. This pin's IN is raised whenever a change of status occurs in
                   the receiver, at which point a RDPIN can be used on this pin to read the 16-bit status word.
                   WXPIN is used on this pin to set the NCO baud rate.
                   
                   These DP/DM electrical designations can actually be switched by swapping low-speed and full-speed
                   modes, due to USB's mirrored line signalling.
                   
                   To start USB, clear the DIR bits of the intended two pins and configure them each via WRPIN. Use
                   WXPIN on the lower pin to set the baud rate, which is a 16-bit fraction of the system clock. For
                   example, if the main clock is 80MHz and you want a 12MHz baud rate (full-speed), use
                   12,000,000 / 80,000,000 * $10000 = 9830. Then, set the pins' DIR bits. You are now ready to read
                   the receiver status via RDPIN and set output states and send packets via WYPIN, both on the
                   lower pin.
                   
                   To affect the line states or send a packet, use WYPIN on the lower pin. Here are its D values:
                    0 = output IDLE        - default state, float pins, except possible resistor(s) to 3.3V or GND
                    1 = output SE0         - drive both DP and DM low
                    2 = output K           - drive K state onto DP and DM (opposite)
                    3 = output J           - drive J state onto DP and DM (opposite), like IDLE, but driven
                    4 = output EOP         - output end-of-packet: SE0, SE0, J, then IDLE
                    $80 = SOP              - output start-of-packet, then bytes, automatic EOP when buffer runs out
                   
                   To send a packet, first do a 'WYPIN #$80, lowerpin'. Then, after each IN rise on the upper pin,
                   do a 'AKPIN upperpin', followed by a 'WYPIN byte,lowerpin' to buffer the next byte. Bits 31..8
                   of your data bytes are ignored, but by keeping those upper bits clear, WYPIN will be able to do
                   the fastest transfer to the smart pin, which takes only 4 clocks. The transmitter will automatically
                   send an EOP when you stop giving it bytes. To keep the output buffer from overflowing, you should
                   always verify that the upper pin's IN was raised after each WYPIN, before issuing another
                   WYPIN, even if you are just setting a state. The reason for this is that all output activity is
                   timed to the baud generator and even state changes must wait for the next bit period before being
                   implemented, at which time the output buffer empties.
                   
                   There are separate state machines for transmitting and receiving. Only the baud generator is common
                   between them. The transmitter was just described above. Below, the receiver is detailed. Note that
                   the receiver receives not just input from another host/device, but all local output, as well.
                   
                   At any time, a RDPIN can be executed on the lower pin to read the current 16-bit status of the
                   receiver. The lower pin's IN will be raised whenever a change occurs in the receiver's status. This
                   will necessitate a 'AKPIN lowerpin' before IN can be raised again, to alert of the next change in
                   status.
                   
                   NOTE that after an AKPIN, it will take five clocks for IN to drop, before it can be polled again:
                       AKPIN    pin                   ' Acknowledge smart pin, releases IN from high
                       WAITX    #3                    ' Elapse at least 5 clocks (WAITX takes 2 + 3)
                       TESTB    INA, pin    WC        ' IN  can now be polled again
                   
                   The receiver's status bits are as follows:
                    [31:16] <unused>                - $0000
                    [15:8]  byte                    - last byte received
                    [7]     byte toggle             - cleared on SOP, toggled on each byte received
                    [6]     error                   - cleared on SOP, set on bit-unstuff error, EOP SE0 > 3 bits, or SE1
                    [5]     EOP in                  - cleared on SOP or 7+ bits of J or K, set on EOP
                    [4]     SOP in                  - cleared on EOP or 7+ bits of J or K, set on SOP
                    [3]     steady-state indicator  - cleared on line change, set on 7+ bits of no line change
                    [2]     SE0 in         (RESET)  - cleared on !SE0, set on 1+ bits of SE0
                    [1]     K in           (RESUME) - cleared on !K, set on 1+ bits of K
                    [0]     J in           (IDLE)   - cleared on !J, set on 1+ bits of J
                   The result of a RDPIN can be bit-tested for events of interest. It can also be shifted right by 8
                   bits to LSB-justify the last byte received and get the byte toggle bit into C, in order to determine
                   if you have a new byte.
                   '------------------------------------------------------------------------------
                   ' USB References:
                   ' Universal Serial Bus Specification, Revision 2.0
                   '   www.usb.org/developers/docs/usb20_docs/
                   ' Device Class Definition for Human Interface Devices (HID), Version 1.11
                   '   www.usb.org/developers/hidpage/
                   ' Universal Serial Bus (USB) HID Usage Tables, Version 1.12
                   '   www.usb.org/developers/hidpage/Hut1_12v2.pdf
                   '------------------------------------------------------------------------------
                   }
                   ' #endregion (Basics of P2 USB SmartPins)
                   ' #region CON (USB Host)
                   con
                   ' /* Constants specific to the development environment and P2 clock speed
                   ' Prop123-A9 development board USER_LED*s on OUTB pins
                           #32, LED0, LED1, LED2, LED3, LED4, LED5, LED6, LED7
                           LED8, LED9, LED10, LED11, LED12, LED13, LED14, LED15
                           #54, PB0_RESET, PB1, PB2, PB3
                   ' USER_LEDs to show host feedback:
                           HOST_WAIT_LED     = LED8                ' Blinks while waiting for device connect, stays lit while device connected
                           HOST_ACTIVITY_LED = LED9                ' Blinks while in the host's main processing loop
                           HOST_DEBUG_LED    = LED10               ' Host debug feedback LED
                   ' USER_LEDs to show driver feedback:
                           DRIVER_WAIT_LED   = LED12               ' Blinks while waiting for device connect, stays lit while device connected
                           DRIVER_MOUSE_LED  = LED13               ' Pulses during mouse activity
                           DRIVER_KBD_LED    = LED14               ' Pulses during keyboard activity
                           DRIVER_DBG_LED    = LED15               ' Driver debug feedback LED
                   ' The v11+ P2 FPGA image introduced new pin-based DIR/OUT/IN instructions that
                   ' make pin assignment changes much easier. You should be able to use any
                   ' adjacent even/odd pin pair for the USB data signals by changing just the
                   ' DM/DP pin assignments.
                   ' Smart pin pair used for the USB transceiver (Rayman's USB/uSD/Hyperram/Flash board for P123)
                           DM           = 32                       ' DM is "The Brain"
                           DP           = 33                       ' DP is passive
                   '        DM           = 0                        ' DM is "The Brain"
                   '        DP           = 1                        ' DP is passive
                   ' Time units converted to clock cycles for the given P2 Mhz clock speed
                   '        SYSCLOCK     = 60_000_000.0
                           SYSCLOCK     = 80_000_000.0
                   '        SYSCLOCK     = 120_000_000.0
                           _12Mbps      = round((12_000_000.0 / SYSCLOCK) * 65536.0) ' = 6557 NCO @ 120Mhz, 9830 @ 80Mhz
                           _1_5Mbps     = round((1_500_000.0 / SYSCLOCK) * 65536.0)  ' = 819 NCO @ 120Mhz, 1229 @ 80Mhz
                           _1ms         = round(SYSCLOCK / 1_000.0)
                           _1us         = round(float(_1ms) / 1_000.0)
                           _100ns       = round(float(_1us) / 1_000.0 * 100.0)
                           LSBTns       = 667.0                    ' Low-Speed bit period, in nanoseconds
                           FSBTns       = 83.0                     ' Full-Speed bit period, in nanoseconds
                           _1LSBT       = round(SYSCLOCK / 1_000_000_000.0 * LSBTns)' = 53 clocks @ 80Mhz, 80 clocks @ 120Mhz
                           _1FSBT       = round(SYSCLOCK / 1_000_000_000.0 * FSBTns)' = 7 clocks @ 80Mhz, 10 clocks @ 120Mhz
                   ' */
                   ' /* Time delays and intervals
                   ' Useful USB constants and wait intervals:
                           CONNECT_WAIT    = _1ms * 250            ' Connect/disconnect verification delay
                           RESET_HOLD      = _1ms * 15             ' Host reset state hold time
                           XFER_RETRIES    = 6                     ' Maximum retries before retiring a transfer
                           TXN_RETRIES     = 6                     ' Maximum retries before retiring a transaction
                           NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
                           IN_NAK_RETRIES  = 3000                  ' Control transfer IN-NAK retry limit (0 = unlimited)
                           OUT_NAK_RETRIES = 3000                  ' Control transfer OUT-NAK retry limit (0 = unlimited)
                           XFER_WAIT       = _1ms * 5              ' Transfer retry wait timespan
                   ' Standard Device request maximum timeout periods:
                           TO_STANDARD  = _1ms * 5000              ' Non-specific maximum timout period
                           TO_DATA      = _1ms * 500               ' Standard Device requests with a data stage
                           TO_NODATA    = _1ms * 50                ' Standard Device requests without a data stage
                           TO_SETADDR   = _1ms * 50                ' Device SetAddress() command processing maximum
                           TO_CHGADDR   = _1ms * 2                 ' Device SetAddress() period allowed to change its address before next request sent
                   '------------------------------------------------------------------------------
                   ' Low-Speed inter-packet delay, in bit periods (Section 7.1.18). For the host,
                   ' the range is a minimum of two bit periods and a maximum of 7.5 bit periods:
                   '------------------------------------------------------------------------------
                           IP_DELAY_LS  = round(3.5 * LSBTns * float(_1us) / 1000.0) ' Range @80MHz: 106.7 to 400.2 clocks (1.334us to 5.003us)
                           IP_DELAY_FS  = round(3.5 * FSBTns * float(_1us) / 1000.0) ' Range @80MHz: 13.3 to 49.8 clocks (0.166us to 0.623us)
                   '------------------------------------------------------------------------------
                   ' End-to-end signal delay, in bit periods (Section 7.1.19), measured at the
                   ' data pins of the device from the SE0-to-J transition at the end of the EOP.
                   ' For example, when a device transmits the data for an IN transaction, it will
                   ' wait at least 16 bit periods for the host handshake response, but no more
                   ' than 18 bit periods:
                   '   Low-Speed:  10.672us..12.006us (@80MHz: 853.8 to 960.5 clocks).
                   '   Full-Speed: 1.238us..1.494us (@80MHz: 106.2 to 119.5 clocks).
                   ' When the host transmits data e.g. an OUT transaction, it must wait at least
                   ' 18 bit periods before it will timeout the response and start a new transaction.
                   '------------------------------------------------------------------------------
                           TAT_WAIT_LS  = round(30.0 * LSBTns * float(_1us) / 1000.0)
                           TAT_WAIT_FS  = round(100.0 * FSBTns * float(_1us) / 1000.0)
                   '------------------------------------------------------------------------------
                   ' Interrupt service routine timespans for 1ms interval frame generation.
                   ' Target resolution is 1.00ms +/- 0.0005ms. At full-speed, a numbered
                   ' start-of-frame packet is issued. At low-speed, a single EOP is issued as a
                   ' "keep-alive" strobe to prevent a device from entering suspend mode.
                   '------------------------------------------------------------------------------
                           TXN_OK_ZONE  = _1us * 667               ' All USB transactions must be started within this timespan
                           NO_TXN_ZONE  = _1us * 333               ' Buffer timespan zone to guarantee an in-progress transaction can complete
                   ' Non-USB related time intervals:
                           PULSE_TIME   = _1ms * 500               ' LED-blinking heartbeat interval
                   ' */
                   ' /* PID tokens
                   '------------------------------------------------------------------------------
                   ' Token packet format.
                   '------------------------------------------------------------------------------
                   '                       CRC5  ENDP ADDRESS PID
                           CRC_MASK     = %11111_0000_0000000_00000000
                           EP_MASK      = %00000_1111_0000000_00000000
                           ADDR_MASK    = %00000_0000_1111111_00000000
                           EP_ADDR_MASK = %00000_1111_1111111_11111111
                           EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
                   '------------------------------------------------------------------------------
                   ' Packet Identifier Bytes (PID). Notice that the first two LSBits are
                   ' identical for each group.
                   '------------------------------------------------------------------------------
                   ' Token:
                           PID_OUT   = %1110_0001                  ' $e1
                           PID_IN    = %0110_1001                  ' $69
                           PID_SOF   = %1010_0101                  ' $a5
                           PID_SETUP = %0010_1101                  ' $2d
                   
                   ' Data:
                           PID_DATA0 = %1100_0011                  ' $c3
                           PID_DATA1 = %0100_1011                  ' $4b
                           PID_DATA2 = %1000_0111                  ' $87
                           PID_MDATA = %0000_1111                  ' $0f
                   
                   ' Handshake:
                           PID_ACK   = %1101_0010                  ' $d2
                           PID_NAK   = %0101_1010                  ' $5a
                           PID_STALL = %0001_1110                  ' $1e
                           PID_NYET  = %1001_0110                  ' $96
                   ' Special:
                           PID_PRE   = %0011_1100                  ' $3c
                           PID_ERR   = %0011_1100                  ' $3c
                           PID_SPLIT = %0111_1000                  ' $78
                           PID_PING  = %1011_0100                  ' $b4
                           PID_RESVD = %1111_0000                  ' $f0
                   ' */
                   ' /* Tx, rx and host related constants
                   ' USB transmitter WYPIN D line state options:
                           OUT_IDLE = 0
                           OUT_SE0  = 1
                           OUT_K    = 2
                           OUT_J    = 3
                           OUT_EOP  = 4
                           OUT_SOP  = $80
                   ' USB receiver RDPIN status bit positions:
                           #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, RXERRB, BYTE_TGLB
                   ' USB receiver RDPIN status bitflags:
                           J_IDLEF    = |< J_IDLEB
                           K_RESUMEF  = |< K_RESUMEB
                           SE0_RESETF = |< SE0_RESETB
                           SE1_BADF   = |< SE1_BADB
                           SOPF       = |< SOPB
                           EOPF       = |< EOPB
                           RXERRF     = |< RXERRB
                           BYTE_TGLF  = |< BYTE_TGLB
                   ' USB CRC constants:
                           USB5_POLY      = %0_0101 >< 5           ' USB5 polynomial is reflected when calculating CRC
                           USB5_RESIDUAL  = %0_1100 >< 5           ' Expected CRC5 residual value when checking received data
                           USB16_POLY     = $8005 >< 16            ' USB16 polynomial is reflected when calculating CRC
                           USB16_RESIDUAL = $800d >< 16            ' Expected CRC16 residual value when checking received data
                   ' Host->class driver USB connect speed:
                           #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
                   ' Protocol error codes:
                           #0, ERR_NONE, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY, ERR_XFER_RETRY
                           ERR_NAK, ERR_ACK_RETRY, ERR_EMPTY_PKT, ERR_CRC, ERR_END
                   ' Debug stuff:
                           DBG_FEEDBEEF = $efbeedfe                ' Handy byte sequence for hex search in .obj files
                           DBG_DEADC0DE = $dec0adde                ' End of code/data marker
                   ' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
                           #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB, TXN_LIMITB '[2], ERRORB
                   ' Host status bitflags. Unless otherwise noted, bit states are active high:
                           IDLEF      = |< IDLEB                   ' Set when USB in idle state
                           CONNECTEDF = |< CONNECTEDB              ' USB device connected
                           LOW_SPEEDF = |< LOW_SPEEDB              ' Low-speed device connected, clear if full-speed
                           DATAx_TGLF = |< DATAx_TGLB              ' Cleared if sending DATA0 packet, set if sending DATA1 packet
                           TXN_LIMITF = |< TXN_LIMITB              ' No-go area to prevent transactions from spanning frame boundary
                   '       EOPF       = |< EOPB                    ' Same bit position as the USB receiver RDPIN constant defined above
                   '       RXERRF     = |< RXERRB                  ' Same bit position as the USB receiver RDPIN constant defined above
                   '       BYTE_TGLF  = |< BYTE_TGLB               ' Same bit position as the USB receiver RDPIN constant defined above
                   ' */
                   ' /* LUT allocation:
                   '------------------------------------------------------------------------------
                   ' LUT sharing between the host cog and the class driver cog is enabled. There
                   ' is no address partitioning, so both cogs must be aware of all LUT address
                   ' ranges that are in use. The host cog and class driver cogIDs must be an
                   ' adjacent even/odd pair.
                   '------------------------------------------------------------------------------
                   ' Host cog LUT locations shared with the class driver cog:
                           LSHARE_BASE = H_EVENT - 6       ' Base LUT location for command/request processing via LUT sharing
                           #LSHARE_BASE                    ' Locate shared LUT cells at the top of the LUT space
                           H_PAR1, H_PAR2, H_PAR3
                           D_PAR1, D_PAR2, D_PAR3
                   '------------------------------------------------------------------------------
                   ' LUT locations tied to selectable-events (changed in P2v11+).
                   '------------------------------------------------------------------------------
                           H_EVENT       = $1fc            ' Class driver cog writes to this host LUT address
                           H_EVENT_WR1FC = %000_00_1100    ' Setup bits for host POLLSE1/WAITSE1 selectable-event
                           D_EVENT       = $1fd            ' Host driver cog writes to this class driver LUT address
                           D_EVENT_WR1FD = %000_00_1101    ' Setup bits for class driver POLLSE1/WAITSE1 selectable-event
                   ' Bits used in SETWRL/SETRDL setup:
                           LSHARE_READ   = 0               ' The other cog can read this LUT
                           LSHARE_WRITE  = 1               ' The other cog can write this LUT
                   ' LUT locations < 256 are available to the class driver, if needed.
                   '------------------------------------------------------------------------------
                   ' USB I/O request events from the class driver that are recognized by the host
                   ' cog. At this time there is no event queueing, so the class driver must
                   ' poll/wait until for the host driver to post H_READY before it can post a new
                   ' event. The event mechanism is asynchronous. It works, but the implementation
                   ' in its current form is somewhat clumsy. For both cogs, a POLLSE1 event is
                   ' triggered when its odd/even partner posts an eventID to its assigned LUT
                   ' location.
                   '
                   ' When the class driver posts a USB I/O request to the host's eventID LUT
                   ' location, the transaction is not considered to be complete until the host
                   ' posts a DTXN_RESULT event to the class driver. The event parameters contain
                   ' the transaction type executed and its result code. Since all event postings
                   ' are asynchronous, the class driver assigns the address of a routine that
                   ' understands the context of the posted IRP, making a fairly simple callback
                   ' mechanism to handle the IRP result.
                   '------------------------------------------------------------------------------
                   '       Class Driver->Host        H_PAR1        H_PAR2          H_PAR3          Description
                           #0, H_READY             ' n/a           n/a             n/a             Host ready to process event
                           HCTRL_READ              ' ctrlep/addr   SETUP addr      IN data addr    ControlRead()
                           HCTRL_WRITE             ' ctrlep/addr   SETUP addr      OUT data addr   ControlWrite()
                           HINT_IN                 ' epN/addr      IN data addr    max_pkt|DATAx   InterruptIN(), word1 max_pkt, word0 DATAx to expect
                           HINT_OUT                ' epN/addr      OUT data addr   pkt_len|DATAx   InterruptOUT(), word1 pkt_len, word0 DATAx to tx
                   ' Last event in the jump table, useful when testing/debugging:
                           H_END = HINT_IN
                   '------------------------------------------------------------------------------
                   ' Events recognized by the class driver cog. At this time there is no event
                   ' queueing, The host must poll/wait for the class driver to post D_READY before
                   ' it can post a new event. These events don't require a post-event response to
                   ' the host, so they are implemented as a jump table.
                   '------------------------------------------------------------------------------
                   '       Host->Class Driver        D_PAR1        D_PAR2          D_PAR3          Description
                           #0, D_READY             ' n/a           n/a             n/a             Driver ready to process event
                           DREQ_ASCIIZ             ' ASCIIZ addr   n/a             n/a             Output zero-terminated string at addr
                           DREQ_BREAK              ' debug long    n/a             n/a             Debug breakpoint (host and driver halt)
                           DREQ_DBG_DATA           ' debug long    n/a             n/a             Arbitrary debug value (host and driver continue)
                           DREQ_HEXDUMP            ' buff addr     data len        n/a             Data hexdump
                           DINF_CONNECT            ' speed         n/a             n/a             Device connected, not yet configured, at given speed
                           DINF_DISCONNECT         ' ctrlep/addr   n/a             n/a             Device at ep0/addr disconnected
                           DINF_DEV_DESC           ' ctrlep/addr   buff addr       n/a             Device descriptor available at buff_addr
                           DINF_CON_DESC           ' ctrlep/addr   buff addr       n/a             Configuration descriptor available at buff addr
                   '------------------------------------------------------------------------------
                   ' The below event is posted by the host to notify the class driver that the
                   ' USB I/O request event that had been previously posted by the class driver has
                   ' completed. If the result is an error that the class driver cannot recover
                   ' from, it should put itself into an idle state.
                   '------------------------------------------------------------------------------
                           DTXN_RESULT
                   ' Control transfer result:      ' CRC/ep/addr   overall result  context result
                   ' IN transaction result:        ' CRC/ep/addr   result code     rxBytes
                   '------------------------------------------------------------------------------
                   ' The below event is a mechanism the host cog can use to notify the class
                   ' driver (or end user) that the host has completed a USB I/O action that was
                   ' NOT requested by the class driver. In general, if the result code is not
                   ' "ACK", it is likely that the host has encountered an error that it could not
                   ' recover from, and it has entered an idle state. Given this, the class driver
                   ' routine that processes this event will send the result details to the
                   ' terminal and put itself into an idle state also.
                   '
                   ' NOTE: once the class driver has configured the device and is issueing USB
                   ' I/O requests, this event should no longer be used, as the host reports I/O
                   ' results through the above DTXN_RESULT event.
                   '------------------------------------------------------------------------------
                           DTXN_HRESULT            ' ASCIIZ addr   result code     n/a             Addr of result description string, ACK/NAK/STALL result code
                   '------------------------------------------------------------------------------
                   ' Last event in the jump table, useful when testing/debugging:
                           D_END = DTXN_HRESULT
                   ' */
                   ' #endregion CON (USB Host)
                   ' #region DAT (Host Cog)
                   '------------------------------------------------------------------------------
                   ' USB host cog.
                   '------------------------------------------------------------------------------
                   dat
00020                              orgh
00020                              alignl
00020 000                          org
00020 000          usb_host
00020 000 fd631c01                 cogid   hr0                             ' Get this cogID
00024 001 f4171c00                 testb   hr0, #0                 wc      ' Find whether we're the even or odd cogID of the pair
00028 002 cf000009         if_c    coginit hr0, ##@hid_driver              ' C = 1 is the odd cog, so load the USB driver code and restart ourself
0002c 003 cce71da0 
                                   ' C = 0, so we are the host cog and fall through
                   ' /* usb_host_start
                   '------------------------------------------------------------------------------
                   ' The USB host cog.
                   '------------------------------------------------------------------------------
00030 004          usb_host_start
00030 004 fd644459                 drvh    #LED2
                   '                call    #load_host_lut                  ' Host & driver LUT space is shared. The driver cog owns cells 0..255, the host owns cells 256..511
00034 005 ff8bebc2                 waitx   ##_1ms * 5000                   ' Delay to allow time for the driver and serial output to start
00038 006 fd64001f 
0003c 007 fd644450                 fltl    #LED2                           ' DEBUG
00040 008 fd640237                 setluts #LSHARE_WRITE                   ' Allow class driver cog to write this LUT
00044 009 fd641820                 setse1  #H_EVENT_WR1FC                  ' Class driver write to LUT location H_EVENT triggers this event
00048 00a f607e958                 mov     ijmp1, #isr1_frame              ' Set the USB 1ms frame handler ISR routine
0004c 00b fd800814                 jmp     #host_reset                     ' Initialize host and enter main processing loop
                   ' */
                   ' /* do_hevent
                   '------------------------------------------------------------------------------
                   ' Handler jump table for events posted to the host by the class driver cog.
                   '------------------------------------------------------------------------------
00050 00c          do_hevent
00050 00c faa741fc                 rdlut   hevent, #H_EVENT
00054 00d f3274003                 fle     hevent, #H_END
00058 00e fd642c2a                 push    #end_hevent                     ' All jump table entries are CALL targets
0005c 00f f6075a00                 mov     context_retval, #ERR_NONE       ' Assume overall operation success
00060 010 fd634030                 jmprel  hevent
00064 011          hevent_jmp
00064 011 fd64002d                 ret                                     ' EventID zero is a NOP
00068 012 fd800b00                 jmp     #do_ctrl_read
0006c 013 fd800b24                 jmp     #do_ctrl_write
00070 014 fd800b48                 jmp     #do_int_in
00074 015 fd800bc4                 jmp     #do_int_out
00078 016          end_hevent
00078 016 0c3c01fc         _ret_   wrlut   #H_READY, #H_EVENT              ' Ready for next event posting
                   ' */
                   ' /* post_devent
                   '------------------------------------------------------------------------------
                   ' Post an eventID to be handled by the class driver cog.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hevent: eventID to post.
                   '           Regs hpar1, hpar2, hpar3: eventID parameters, if needed.
                   ' On exit:
                   '------------------------------------------------------------------------------
0007c 017          post_devent
0007c 017 faaf5dfd                 rdlut   htmp, #D_EVENT          wz      ' Wait for any pending class driver event to complete
00080 018 5d9ffff8         if_nz   jmp     #post_devent
00084 019 fc3721f9                 wrlut   hpar1, #D_PAR1
00088 01a fc3723fa                 wrlut   hpar2, #D_PAR2
0008c 01b fc3725fb                 wrlut   hpar3, #D_PAR3
00090 01c 0c3741fd         _ret_   wrlut   hevent, #D_EVENT                ' This driver LUT location is the write event trigger for the event request
                   ' */
                   ' /* control_read
                   '------------------------------------------------------------------------------
                   ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
                   ' Status reporting is always in the function-to-host direction.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: start address of the SETUP data in hub.
                   '           Reg PB: start address of the buffer/struct to be written to
                   '           during the IN data stage.
                   '           Reg ep_addr_pid: device address, endpoint and CRC5.
                   ' On exit:  Reg retval: PID_ACK on success, otherwise error. If successful,
                   '           reg total_data contains the count of data stage bytes actually
                   '           received, which must always be <= the count requested.
                   '           Reg context_retval: ERR_NONE if the overall transfer succeeds,
                   '           otherwise a more specific USB operation error code.
                   '------------------------------------------------------------------------------
00094 01d          control_read
00094 01d f60321ab                 mov     hpar1, ep_addr_pid
00098 01e f60323f8                 mov     hpar2, ptra
0009c 01f f60325f7                 mov     hpar3, pb
000a0 020 f6073606                 mov     xfer_retry, #XFER_RETRIES
000a4 021          .xfer_start
000a4 021 fae74503                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
000a8 022 fdb001d8                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
000ac 023 f20f58d2                 cmp     retval, #PID_ACK        wz
000b0 024 5d64002d         if_nz   ret                                     ' Back to caller to handle error
000b4 025 f20f4400                 cmp     total_data, #0          wz
000b8 026 ad900194         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
000bc 027 f6074600                 mov     stage_data, #0                  ' Prepare for data stage
000c0 028 ff000005                 mov     nak_retry, ##IN_NAK_RETRIES
000c4 029 f60735b8 
000c8 02a f4272c03                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
000cc 02b          .data
000cc 02b f60349a2                 mov     pkt_data, total_data
000d0 02c f18349a3                 sub     pkt_data, stage_data
000d4 02d f21b49a1                 cmp     pkt_data, max_pkt_size  wcz
000d8 02e 160349a1         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
000dc 02f          .nak_retry
000dc 02f f6073806                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
000e0 030          .in_retry
000e0 030 fdb001d4                 call    #txn_in
000e4 031 f20f58d2                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
000e8 032 ad900028         if_z    jmp     #.commit
000ec 033 f20f581e                 cmp     retval, #PID_STALL      wz
000f0 034 ad9000ac         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
000f4 035 fda00bc8                 call    #retry_wait                     ' Wait a bit before retry
000f8 036 f20f585a                 cmp     retval, #PID_NAK        wz
000fc 037 ad9fffdc         if_z    jmp     #.nak_retry                     ' Function not ready to send data
00100 038 f20f5807                 cmp     retval, #ERR_NAK        wz
00104 039 ad900098         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00108 03a f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz
0010c 03b 5d9fffd0         if_nz   jmp     #.in_retry                      ' Bus error retry
00110 03c fd64002d                 ret                                     ' The transfer has failed
00114 03d          .commit
00114 03d f20f5000                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
00118 03e ad900034         if_z    jmp     #.pre_status                    ' and also end-of-data
0011c 03f fec021cf                 loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest struct
00120 040 f6031da8                 mov     hr0, pkt_cnt
00124 041 fdb00510                 call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
00128 042 f10347a8                 add     stage_data, pkt_cnt             ' Update bytes received on commit
0012c 043 f20b47a2                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
00130 044 ad90001c         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
00134 045 f21b51a4                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
00138 046 cd900014         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
0013c 047 16075803         if_a    mov     retval, #ERR_PACKET
00140 048 16035bac         if_a    mov     context_retval, retval          ' In this case overall and context are the same
00144 049 1d64002d         if_a    ret                                     ' Caller must handle ERR_PACKET
00148 04a f4e72c03                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
0014c 04b fd9fff7c                 jmp     #.data                          ' Start next IN transaction
00150 04c          .pre_status
00150 04c f60345a3                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
00154 04d f8c756e1                 setbyte ep_addr_pid, #PID_OUT, #0
00158 04e f6074800                 mov     pkt_data, #0
0015c 04f f4272c03                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
00160 050 f6073806                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00164 051 ff000005                 mov     nak_retry, ##OUT_NAK_RETRIES
00168 052 f60735b8 
0016c 053          .out_retry
0016c 053 fdb0024c                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
00170 054 f20f58d2                 cmp     retval, #PID_ACK        wz
00174 055 ad64002d         if_z    ret                                     ' All is good when ACK
00178 056 f20f581e                 cmp     retval, #PID_STALL      wz
0017c 057 ad900020         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
00180 058 fda00bc8                 call    #retry_wait                     ' Wait a bit before retry
00184 059 f20f585a                 cmp     retval, #PID_NAK        wz
00188 05a ad9fffe0         if_z    jmp     #.out_retry                     ' Function not ready so resend status result
0018c 05b f20f5807                 cmp     retval, #ERR_NAK        wz
00190 05c ad90000c         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00194 05d f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz
00198 05e 5d9fffd0         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
0019c 05f fd64002d                 ret                                     ' Caller must handle transfer retirement
                   ' I've encountered transfer STALL, even though the data looks correct, and
                   ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
                   ' ControlRead() transfer gets things unstuck most of the time...
001a0 060          .xfer_retry
001a0 060 ff00030d                 mov     hctwait, ##XFER_WAIT
001a4 061 f6072e80 
001a8 062 fdb003b8                 call    #poll_waitx
001ac 063 fdb003c4                 call    #wait_txn_ok
001b0 064 f6035790                 mov     ep_addr_pid, hpar1
001b4 065 f603f191                 mov     ptra, hpar2
001b8 066 f603ef92                 mov     pb, hpar3
001bc 067 fb6f37b9                 djnz    xfer_retry, #.xfer_start
001c0 068 f6035bac                 mov     context_retval, retval          ' Preserve the USB error code
001c4 069 06075806         _ret_   mov     retval, #ERR_XFER_RETRY
                   ' */
                   ' /* control_write
                   '------------------------------------------------------------------------------
                   ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
                   ' reporting is always in the function-to-host direction. It is assumed that
                   ' the SETUP data struct is filled with the required values.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA points to the start of the struct for the SETUP data.
                   '           Reg PB has the start address of the struct/buffer to be read for
                   '           the OUT data stage.
                   '           Reg ep_addr_pid has the proper CRC'd address and endpoint to use.
                   ' On exit:  Reg retval is used to convey the success/failure of each stage.
                   '           Reg context_retval: ERR_NONE if the overall transfer succeeds,
                   '           otherwise a more specific USB operation error code.
                   '------------------------------------------------------------------------------
001c8 06a          control_write
001c8 06a f60321ab                 mov     hpar1, ep_addr_pid
001cc 06b f60323f8                 mov     hpar2, ptra
001d0 06c f60325f7                 mov     hpar3, pb
001d4 06d f6073606                 mov     xfer_retry, #XFER_RETRIES
001d8 06e          .xfer_start
001d8 06e f6073400                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
001dc 06f fae74503                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
001e0 070 fdb000a0                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
001e4 071 f20f58d2                 cmp     retval, #PID_ACK        wz
001e8 072 5d64002d         if_nz   ret                                     ' Back to caller to handle error
001ec 073 f20f4400                 cmp     total_data, #0          wz
001f0 074 ad90005c         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
001f4 075 f6074600                 mov     stage_data, #0                  ' Prepare for data stage
001f8 076 f8c756e1                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
001fc 077 f4272c03                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
00200 078 f6073806                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00204 079          .data
00204 079 f60349a2                 mov     pkt_data, total_data
00208 07a f18349a3                 sub     pkt_data, stage_data
0020c 07b f21b49a1                 cmp     pkt_data, max_pkt_size  wcz
00210 07c 160349a1         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
00214 07d          .out_retry
00214 07d f603f1f7                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
00218 07e fdb001a0                 call    #txn_out
0021c 07f f20f58d2                 cmp     retval, #PID_ACK        wz
00220 080 ad900018         if_z    jmp     #.commit                        ' Function got the data
00224 081 fda00bc8                 call    #retry_wait                     ' Wait a bit before retry
00228 082 f20f585a                 cmp     retval, #PID_NAK        wz
0022c 083 ad9fffe4         if_z    jmp     #.out_retry                     ' In this context, NAK gets unlimited retries
00230 084 f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
00234 085 5d9fffdc         if_nz   jmp     #.out_retry
00238 086 fd64002d                 ret                                     ' Caller must handle transfer retirement
0023c 087          .commit
0023c 087 f603eff8                 mov     pb, ptra                        ' Save the current buffer/struct location
00240 088 f10347a4                 add     stage_data, pkt_data
00244 089 f20b47a2                 cmp     stage_data, total_data  wz
00248 08a 54e72c03         if_nz   bitnot  hstatus, #DATAX_TGLB            ' Toggle DATAx sync bit
0024c 08b 5d9fffb4         if_nz   jmp     #.data                          ' More data to send
00250 08c          pre_status_in
00250 08c f4272c03                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
00254 08d f6073806                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00258 08e          .status_retry
00258 08e f6074800                 mov     pkt_data, #0
0025c 08f fdb00058                 call    #txn_in
00260 090 f20f58d2                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
00264 091 a20f4800         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
00268 092 ad64002d         if_z    ret                                     ' Control Write finished
0026c 093 fda00bc8                 call    #retry_wait                     ' NAK or bus error, so delay a bit
00270 094 f20f585a                 cmp     retval, #PID_NAK        wz
00274 095 ad9fffe0         if_z    jmp     #.status_retry                  ' FIXME: should probably have a NAK limit here?
00278 096 f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz
0027c 097 5d9fffd8         if_nz   jmp     #.status_retry
00280 098 fd64002d                 ret                                     ' Caller must handle transfer retirement
                   ' */
                   ' /* txn_setup
                   '------------------------------------------------------------------------------
                   ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
                   ' special because the receiving function must not respond with either STALL or
                   ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
                   ' non-control endpoint receives a SETUP token, or the function receives a
                   ' corrupt packet, it must ignore the transaction
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: start address of the SETUP data struct.
                   ' On exit:  Reg retval: PID_ACK on success, otherwise error code.
                   '------------------------------------------------------------------------------
00284 099          txn_setup
00284 099 f8c7562d                 setbyte ep_addr_pid, #PID_SETUP, #0
00288 09a f6074808                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
0028c 09b f4072c03                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
00290 09c f6073806                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
00294 09d f603edf8                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
00298 09e          .setup
00298 09e fdb00120                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
0029c 09f f20f58d2                 cmp     retval, #PID_ACK        wz
002a0 0a0 ad64002d         if_z    ret
002a4 0a1 fda00bc8                 call    #retry_wait
002a8 0a2 f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz
002ac 0a3 ad64002d         if_z    ret
002b0 0a4 f603f1f6                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
002b4 0a5 fd9fffe0                 jmp     #.setup
                   ' */
                   ' /* txn_in
                   '------------------------------------------------------------------------------
                   ' IN/INTERRUPT transaction.
                   ' Possible function response: STALL or NAK handshake, or DATAx packet.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg ep_addr_pid: PID_IN(b0..7), address(b8..b14),
                   '           endpoint(b15..18) and CRC(b19..23).
                   ' On exit:
                   '------------------------------------------------------------------------------
002b8 0a6          txn_in
002b8 0a6 fdb002b8                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
002bc 0a7 f8c75669                 setbyte ep_addr_pid, #PID_IN, #0
002c0 0a8 ff000010                 wrfast  #0, ##urx_buff                  ' Use hub RAM FIFO interface to buffer bytes received
002c4 0a9 fc8c01cf 
002c8 0aa fdb000c0                 call    #utx_token                      ' Put IN request on the bus
                   ' Fall through to urx_packet
                   ' vvvvvvvvvvvvvvvvvvvvvvvvvv
                   ' */
                   ' /* urx_packet
                   '------------------------------------------------------------------------------
                   ' Wait for a packet from a device/function. As host, the only two packet types
                   ' received are handshakes and DATAx.
                   '------------------------------------------------------------------------------
                   ' On entry: The routine waits until the USB is idle.
                   ' On exit:  Reg retval: the ID of the packet. If a PID fails validation,
                   '           ERR_PACKET is returned.
                   '------------------------------------------------------------------------------
002cc 0ab          urx_packet
002cc 0ab fa873c20                 rqpin   urx, #DM
002d0 0ac f4173c04                 testb   urx, #SOPB              wc
002d4 0ad cd9ffff4         if_c    jmp     #urx_packet
002d8 0ae fd63281a                 getct   hct2
002dc 0af fa6b2999                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
002e0 0b0 f4072c05                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
002e4 0b1 f6073e00                 mov     newb_flg, #0                    ' Initialize for multi-byte read
002e8 0b2          .wait_sop
002e8 0b2 fa8f3c20                 rdpin   urx, #DM
002ec 0b3 f4173c04                 testb   urx, #SOPB              wc
002f0 0b4 cd900008         if_c    jmp     #.get_pid
002f4 0b5 fbcc25fc                 jnct2   #.wait_sop
002f8 0b6 06075804         _ret_   mov     retval, #ERR_TAT
002fc 0b7          .get_pid
002fc 0b7 fdb00234                 call    #urx_next
00300 0b8 f4173c06                 testb   urx, #RXERRB            wc
00304 0b9 3d900004         if_nc   jmp     #.chk_pid
00308 0ba 06075801         _ret_   mov     retval, #ERR_URX
0030c 0bb          .chk_pid
0030c 0bb f20f58d2                 cmp     retval, #PID_ACK        wz
00310 0bc 520f585a         if_nz   cmp     retval, #PID_NAK        wz
00314 0bd 520f581e         if_nz   cmp     retval, #PID_STALL      wz
00318 0be ad90003c         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
0031c 0bf f4172c03                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
00320 0c0 f20f58c3                 cmp     retval, #PID_DATA0      wz
00324 0c1 2d900134    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
00328 0c2 8d900010    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the function must have missed
0032c 0c3 f20f584b                 cmp     retval, #PID_DATA1      wz
00330 0c4 8d900128    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
00334 0c5 2d900004    if_z_and_nc  jmp     #.ack_resend
00338 0c6 06075803         _ret_   mov     retval, #ERR_PACKET
0033c 0c7          .ack_resend
0033c 0c7 fa873c20                 rqpin   urx, #DM
00340 0c8 f4173c04                 testb   urx, #SOPB              wc
00344 0c9 cd9ffff4         if_c    jmp     #.ack_resend
00348 0ca f6032f98                 mov     hctwait, ip_delay
0034c 0cb fdb00214                 call    #poll_waitx
00350 0cc f60758d2                 mov     retval, #PID_ACK
00354 0cd fd9001a0                 jmp     #utx_handshake                  ' Send handshake PID and return to caller
00358 0ce          .chk_eop
00358 0ce f4172c02                 testb   hstatus, #LOW_SPEEDB    wc
0035c 0cf 3d90001c         if_nc   jmp     #.idle                          ' FIXME: this may change with FS at > 80MHz
00360 0d0 fdb001d0                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
00364 0d1 f4172c05                 testb   hstatus, #EOPB          wc
00368 0d2 cd900010         if_c    jmp     #.idle                          ' Low-speed EOP seen
0036c 0d3 f40f3c06                 testb   urx, #RXERRB            wz
00370 0d4 36075803         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
00374 0d5 a6075801         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
00378 0d6 fd64002d                 ret
0037c 0d7          .idle
0037c 0d7 fa873c20                 rqpin   urx, #DM
00380 0d8 f4173c00                 testb   urx, #J_IDLEB           wc
00384 0d9 3d9ffff4         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
00388 0da fd64002d                 ret
                   ' */
                   ' /* utx_token
                   '------------------------------------------------------------------------------
                   ' Send a token packet with CRC5 checksum of address and endpoint. It is the
                   ' responsibility of the caller to append the appropriate inter-packet delay,
                   ' if one is required.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg ep_addr_pid: packed with the PID, address and endpoint.
                   ' On exit:
                   '------------------------------------------------------------------------------
0038c 0db          utx_token
0038c 0db f6073a80                 mov     utx, #OUT_SOP
00390 0dc fdb00190                 call    #utx_byte                       ' Send sync byte
00394 0dd f6035dab                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
00398 0de f6075003                 mov     pkt_cnt, #3
0039c 0df          .next_byte
0039c 0df f8e33bae                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
003a0 0e0 f0475c08                 shr     htmp, #8                        ' Shift to next byte to send
003a4 0e1          .wait
003a4 0e1 fd744240                 testp   #DP                     wc
003a8 0e2 3d9ffff8         if_nc   jmp     #.wait
003ac 0e3 fc0c0221                 akpin   #DP
003b0 0e4 fc273a20                 wypin   utx, #DM
003b4 0e5 fb6f51f9                 djnz    pkt_cnt, #.next_byte
003b8 0e6 fd64002d                 ret
                   ' */
                   ' /* txn_out
                   '------------------------------------------------------------------------------
                   ' SETUP/OUT/INTERRUPT transaction.
                   ' Possible function response in order of precedence: STALL, ACK, NAK.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg ep_addr_pid: PID_OUT(b0..7), address(b8..b14),
                   '           endpoint(b15..18) and CRC(b19..23).
                   '           Reg PTRA: start address of the data buff/struct that has the bytes
                   '           to send.
                   '           Reg pkt_data: count of DATAx payload bytes to send.
                   ' On exit:
                   '------------------------------------------------------------------------------
003bc 0e7          txn_out
003bc 0e7 fdb001b4                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
003c0 0e8 fc7801f8                 rdfast  #0, ptra                        ' Use hub RAM FIFO interface to read the tx buffer
003c4 0e9 fdbfffc4                 call    #utx_token                      ' Put SETUP/OUT token on the bus
003c8 0ea f60351a4                 mov     pkt_cnt, pkt_data
003cc 0eb f6032f98                 mov     hctwait, ip_delay
003d0 0ec fdb00190                 call    #poll_waitx
                   ' Fall through to utx_data
                   ' vvvvvvvvvvvvvvvvvvvvvvvv
                   ' */
                   ' /* utx_data
                   '------------------------------------------------------------------------------
                   ' Transmit a DATAx packet with CRC16 checksum of payload. The packet CRC is
                   ' calculated using Ariba's pre-calculated CRC16 table. Since data stage
                   ' success/fail is not determined until the status stage of the transaction,
                   ' this routine is only concerned about the current DATAx packet.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: hub start address of the data to read.
                   '           Reg pkt_cnt: data payload size.
                   ' On exit:
                   '------------------------------------------------------------------------------
003d4 0ed          utx_data
003d4 0ed fa873c20                 rqpin   urx, #DM
003d8 0ee f4173c04                 testb   urx, #SOPB              wc
003dc 0ef cd9ffff4         if_c    jmp     #utx_data
003e0 0f0 f6032f98                 mov     hctwait, ip_delay
003e4 0f1 fdb0017c                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
003e8 0f2 f6073a80                 mov     utx, #OUT_SOP
003ec 0f3 fdb00134                 call    #utx_byte                       ' Send sync
003f0 0f4 ff00007f                 mov     crc, ##$ffff                    ' Prime the CRC16 pump
003f4 0f5 f60755ff 
003f8 0f6 f4172c03                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
003fc 0f7 36073ac3         if_nc   mov     utx, #PID_DATA0
00400 0f8 c6073a4b         if_c    mov     utx, #PID_DATA1
00404 0f9 fdb0011c                 call    #utx_byte                       ' No CRC calc done on PID
00408 0fa f20f5000                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
0040c 0fb ad900030         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
00410 0fc          .read_byte
00410 0fc fd633a10                 rfbyte  utx
                   ' In-line tx for max speed
00414 0fd          .txwait
00414 0fd fd744240                 testp   #DP                     wc
00418 0fe 3d9ffff8         if_nc   jmp     #.txwait
0041c 0ff fc0c0221                 akpin   #DP
00420 100 fc273a20                 wypin   utx, #DM                        ' Data byte to the smartpins for transmit
                   ' End tx in-line
00424 101 fd633a69                 rev     utx                             ' Calculate CRC while the data is shifting out
00428 102 fd633a28                 setq    utx                             ' SETQ left-justifies the reflected data byte
0042c 103 ff000050                 crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
00430 104 f9df5401 
00434 105 ff000050                 crcnib  crc, ##USB16_POLY
00438 106 f9df5401 
0043c 107 fb6f51f4                 djnz    pkt_cnt, #.read_byte
00440 108          .send_crc
00440 108 ff00007f                 xor     crc, ##$ffff                    ' Final XOR, and send the calculated CRC16
00444 109 f56755ff 
00448 10a f8e33baa                 getbyte utx, crc, #0
0044c 10b fdb000d4                 call    #utx_byte
00450 10c f8eb3baa                 getbyte utx, crc, #1
00454 10d fdb000cc                 call    #utx_byte                       ' Last CRC byte out
00458 10e fd9ffe70                 jmp     #urx_packet                     ' Handle function response/error and back to caller
                   ' */
                   ' /* urx_data
                   '------------------------------------------------------------------------------
                   ' Receive a DATAx_ payload with CRC16 checksum. The CRC is calculated using
                   ' Ariba's pre-calculated CRC16 table. The routine reads bytes until EOP is
                   ' detected, and expects the payload to include at least the CRC16 word.
                   '
                   ' In control transfers, it's possible to recieve fewer data bytes than what
                   ' was requested, which makes it difficult to determine where the data stops
                   ' and the CRC word begins. So the CRC calculation is done on every byte of the
                   ' packet, including the CRC word. The CRC value should then be equal to the
                   ' USB-16 expected residual value of 0xB001.
                   '
                   ' The routine writes the IN packet data to a static max_packet_size buffer
                   ' so the caller can verify IN success before writing the data to its final
                   ' destination.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg pkt_data: max byte count expected to be in the packet.
                   '           Reg newb_flg: signals new byte ready when toggled.
                   ' On exit:  Reg pkt_cnt: actual number of bytes read.
                   '------------------------------------------------------------------------------
0045c 10f          urx_data
0045c 10f ff00007f                 mov     crc, ##$ffff                    ' Prime the CRC16 pump
00460 110 f60755ff 
00464 111 f6075000                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
00468 112 f60361a4                 mov     pkt_tmp, pkt_data
0046c 113 f1076002                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
00470 114          .wait_byte
                   ' In-line rx for max speed
00470 114 fa873c20                 rqpin   urx, #DM
00474 115 f6073a80                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
00478 116 f5033b9e                 and     utx, urx
0047c 117 f20b3f9d                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
00480 118 55673e80         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
00484 119 5d90000c         if_nz   jmp     #.get_byte                      ' New byte!
00488 11a f4173c05                 testb   urx, #EOPB              wc
0048c 11b cd900040         if_c    jmp     #.chk_crc                       ' At end-of-packet
00490 11c fd9fffdc                 jmp     #.wait_byte
00494 11d          .get_byte
00494 11d f8eb599e                 getbyte retval, urx, #1                 ' Fetch the new byte from smartpins
00498 11e fd635815                 wfbyte  retval                          ' and add it to the data buffer
0049c 11f fd635869                 rev     retval                          ' Calculate CRC while next byte is shifting in
004a0 120 fd635828                 setq    retval                          ' SETQ left-justifies the reflected data byte
004a4 121 ff000050                 crcnib  crc, ##USB16_POLY               ' Run CRC calc on the data nibs
004a8 122 f9df5401 
004ac 123 ff000050                 crcnib  crc, ##USB16_POLY
004b0 124 f9df5401 
004b4 125          .end_crc
004b4 125 f1075001                 add     pkt_cnt, #1
004b8 126 f21b51b0                 cmp     pkt_cnt, pkt_tmp        wcz
004bc 127 16075803         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
004c0 128 1d64002d         if_a    ret
                   ' For full-speed at 80MHz, the time it takes to do the final byte write and
                   ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
                   ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
                   ' to miss it, so cheat a bit and look for SOP clear here.
004c4 129 fa873c20                 rqpin   urx, #DM
004c8 12a f4173c04                 testb   urx, #SOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
004cc 12b cd9fffa0         if_c    jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
                   ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
004d0 12c          .chk_crc
004d0 12c f1875002                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
004d4 12d ff000058                 xor     crc, ##USB16_RESIDUAL           ' CRC of (data + transmitted CRC) XOR residual should equal zero
004d8 12e f5675401 
004dc 12f fb975401                 tjz     crc, #.ack                      ' If we jump, the CRCs matched
004e0 130 0607580a         _ret_   mov     retval, #ERR_CRC
004e4 131          .ack
004e4 131 f60758d2                 mov     retval, #PID_ACK
004e8 132 f4172c02                 testb   hstatus, #LOW_SPEEDB    wc      ' FIXME: only insert ip delay when low-speed
004ec 133 3d900008         if_nc   jmp     #utx_handshake                  ' FIXME: ip delay for full-speed will be needed when > 80MHz
004f0 134 f6032f98                 mov     hctwait, ip_delay
004f4 135 fdb0006c                 call    #poll_waitx
                   ' Fall through to utx_handshake
                   ' vvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                   ' */
                   ' /* utx_handshake
                   '------------------------------------------------------------------------------
                   ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
                   ' the appropriate IP delay has been inserted.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg retval: handshake PID to send.
                   ' On exit:  Reg retval unchanged.
                   '------------------------------------------------------------------------------
004f8 136          utx_handshake
004f8 136 fd744240                 testp   #DP                     wc
004fc 137 3d9ffff8         if_nc   jmp     #utx_handshake
00500 138 f6073a80                 mov     utx, #OUT_SOP
00504 139 fdb0001c                 call    #utx_byte                       ' Send sync
00508 13a f6033bac                 mov     utx, retval
0050c 13b fdb00014                 call    #utx_byte                       ' Send handshake PID
00510 13c          .idle
00510 13c fa873c20                 rqpin   urx, #DM
00514 13d f4173c00                 testb   urx, #J_IDLEB           wc
00518 13e 3d9ffff4         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
0051c 13f f6032f99                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
00520 140 fd900040                 jmp     #poll_waitx
                   ' */
                   ' /* utx_byte
                   '------------------------------------------------------------------------------
                   ' Move a data byte or line state command to the smart pin tx buffer.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg utx: byte to transmit.
                   ' On exit:
                   '------------------------------------------------------------------------------
00524 141          utx_byte
00524 141 fd744240                 testp   #DP                     wc
00528 142 3d9ffff8         if_nc   jmp     #utx_byte
0052c 143 fc0c0221                 akpin   #DP
00530 144 0c273a20         _ret_   wypin   utx, #DM
                   ' */
                   ' /* urx_next
                   '------------------------------------------------------------------------------
                   ' Fetch the next data byte of a packet. Always check receiver status for EOP.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg retval: the byte read.
                   '           Reg urx contains the receiver status. The caller must check the
                   '           hstatus reg EOP flag on return. If EOP is set, the byte in reg
                   '           retval remains as the last byte received.
                   '------------------------------------------------------------------------------
00534 145          urx_next
00534 145 fa8f3c20                 rdpin   urx, #DM
00538 146 f6073a80                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
0053c 147 f5033b9e                 and     utx, urx
00540 148 f20b3f9d                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
00544 149 55673e80         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
00548 14a 58eb599e         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
0054c 14b 5d64002d         if_nz   ret                                     ' New byte is priority, so return now
00550 14c f4173c05                 testb   urx, #EOPB              wc
00554 14d f40f3c06                 testb   urx, #RXERRB            wz
00558 14e 1d9fffd8   if_nc_and_nz  jmp     #urx_next                       ' If SOP still raised and !RXERRB a new byte should be coming
0055c 14f c4272c05         if_c    bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
00560 150 fd64002d                 ret
                   ' */
                   ' /* poll_waitx
                   '------------------------------------------------------------------------------
                   ' The one millisecond frame timer is implemented as an interrupt service
                   ' routine. Since this timing is critical, care must be taken to avoid any
                   ' instructions that can delay the interrupt branch, which will likely upset
                   ' the timer. WAITX is among those instructions, so any time you're inside
                   ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hctwait: wait interval in sysclocks.
                   ' On exit:
                   '------------------------------------------------------------------------------
00564 151          poll_waitx
00564 151 fd63281a                 getct   hct2
00568 152 fa6b2997                 addct2  hct2, hctwait
0056c 153          .wait
0056c 153 fbcc25ff                 jnct2   #.wait
00570 154 fd64002d                 ret
                   ' */
                   ' /* wait_txn_ok
                   '------------------------------------------------------------------------------
                   ' Wait for a window within the 1ms frame boundary that will ensure that a
                   ' transaction can complete without spanning the frame.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
00574 155          wait_txn_ok
00574 155 f4172c04                 testb   hstatus, #TXN_LIMITB    wc
00578 156 cd9ffff8         if_c    jmp     #wait_txn_ok                    ' In "no transaction" zone, so wait for the next frame
0057c 157 fd64002d                 ret                                     ' In the "transaction OK" zone, so good to go
                   ' */
                   ' /* wait_sof
                   {
                   wait_sof
                                   waitint                                 ' Wait for the start-of-frame interrupt
                                   testb   hstatus, #TXN_LIMITB    wc
                           if_nc   ret
                                   jmp     #wait_sof
                   }
                   ' */
                   ' /* isr1_frame
                   '------------------------------------------------------------------------------
                   ' Full-speed/low-speed frame timing interrupt service routine.
                   '------------------------------------------------------------------------------
00580 158          isr1_frame
00580 158 f4172c04                 testb   hstatus, #TXN_LIMITB    wc
00584 159 3d9000a0         if_nc   jmp     #.no_txn_zone                   ' Timer "txn OK" expired, go set "no txn" timer
00588 15a ff000068                 addct1  hct1, ##TXN_OK_ZONE - 6         ' Refresh the "txn OK zone" timespan
0058c 15b fa67266a 
00590 15c f4172c02                 testb   hstatus, #LOW_SPEEDB    wc
00594 15d 3d900010         if_nc   jmp     #.fullspeed
00598 15e f6073a04                 mov     utx, #OUT_EOP                   ' Timer "no txn" expired, so it's end-of-frame
0059c 15f fdbfff84                 call    #utx_byte                       ' EOP is the low-speed keep-alive strobe
005a0 160 f6035f98                 mov     isr_tmp, ip_delay               ' Normal inter-packet delay works when low-speed
005a4 161 fd90005c                 jmp     #.wait
005a8 162          .fullspeed
005a8 162 f6073a80                 mov     utx, #OUT_SOP
005ac 163 fdbfff74                 call    #utx_byte                       ' Send sync byte
005b0 164 f6074e1f                 mov     icrc, #$1f                      ' Prime the CRC5 pump
005b4 165 f6034da5                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
005b8 166 fd634c69                 rev     sof_pkt                         ' Input data reflected
005bc 167 f6073aa5                 mov     utx, #PID_SOF
005c0 168 fdbfff60                 call    #utx_byte                       ' Send token PID byte
005c4 169 fd634c28                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
005c8 16a f9df4e14                 crcnib  icrc, #USB5_POLY
005cc 16b f9df4e14                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
005d0 16c f8e33ba5                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
005d4 16d fdbfff4c                 call    #utx_byte
005d8 16e f0674c08                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
005dc 16f fcdc0403                 rep     #2, #3                          ' Three data bits left to process
005e0 170 f0774c01                 shl     sof_pkt, #1             wc
005e4 171 f9d74e14                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
005e8 172 f5674e1f                 xor     icrc, #$1f                      ' Final XOR value
005ec 173 f8eb3ba5                 getbyte utx, frame, #1                  ' Send remaining frame number bits
005f0 174 f0674e03                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
005f4 175 f5433ba7                 or      utx, icrc
005f8 176 fdbfff28                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
005fc 177 ff000000                 mov     isr_tmp, ##IP_DELAY_FS * 2      ' Use 2x normal inter-packet delay when full-speed
00600 178 f6075e2e 
00604 179          .wait
00604 179 fa873a20                 rqpin   utx, #DM
00608 17a f4173a04                 testb   utx, #SOPB              wc
0060c 17b cd9ffff4         if_c    jmp     #.wait
00610 17c fd635e1f                 waitx   isr_tmp                         ' Make sure bus is idle before 
00614 17d f1074a01                 add     frame, #1                       ' Calculate number for next frame
00618 17e ff000003                 and     frame, ##$7ff
0061c 17f f5074bff 
00620 180 f4072c04                 bitl    hstatus, #TXN_LIMITB            ' Bus ready for traffic
00624 181 fb3bfff5                 reti1
00628 182          .no_txn_zone
00628 182 ff000034                 addct1  hct1, ##NO_TXN_ZONE - 7         ' Refresh the "no txn zone" timespan
0062c 183 fa672609 
00630 184 f4272c04                 bith    hstatus, #TXN_LIMITB
00634 185 fb3bfff5                 reti1
                   ' */
                   ' /* hmemcpy
                   '------------------------------------------------------------------------------
                   ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: source address.
                   '           Reg PB: destination address.
                   '           Reg hr0: length of copy, in bytes.
                   ' On exit:
                   '------------------------------------------------------------------------------
00638 186          hmemcpy
00638 186 fac75d61                 rdbyte  htmp, ptra++
0063c 187 fc435df7                 wrbyte  htmp, pb
00640 188 f107ee01                 add     pb, #1
00644 189 fb6f1dfc                 djnz    hr0, #hmemcpy
00648 18a fd64002d                 ret
                   ' */
                   ' /* memset
                   '------------------------------------------------------------------------------
                   ' Write a single byte value to sequential hub memory locations.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: start address.
                   '           Reg hr0: length of the memory block, in bytes.
                   '           Reg hr1: byte value to write.
                   ' On exit:
                   '------------------------------------------------------------------------------
0064c 18b          memset
0064c 18b fc471f61                 wrbyte  hr1, ptra++
00650 18c fb6f1dfe                 djnz    hr0, #memset
00654 18d fd64002d                 ret
                   ' */
                   ' /* Host common registers
00658 18e          hreg_init_start
00658 18e 00000000 hr0             long    0                               ' Multi-purpose registers
0065c 18f 00000000 hr1             long    0
00660 190 00000000 hpar1           long    0                               ' Routine entry/exit parameters
00664 191 00000000 hpar2           long    0
00668 192 00000000 hpar3           long    0
0066c 193 00000000 hct1            long    0                               ' Timer for the 1ms frame generator interrupt service routine
00670 194 00000000 hct2            long    0                               ' Function response bus turn-around timer
00674 195 00000000 hct3            long    0                               ' DEBUG: used to do the blinky thing on Prop123-A9 USER_LEDs
00678 196 00000000 hstatus         long    0                               ' Host status flags
0067c 197 00000000 hctwait         long    0                               ' Poll-based wait clocks
00680 198 00000000 ip_delay        long    0                               ' Inter-packet delay in bit periods for connected device speed
00684 199 00000000 tat_wait        long    0                               ' Maximum bus turn-around time in bit periods for connected device speed
00688 19a 00000000 nak_retry       long    0                               ' NAK retry count, unlimited retries if zero
0068c 19b 00000000 xfer_retry      long    0                               ' Control transfer retry count
00690 19c 00000000 retry           long    0                               ' Transaction retry count
00694 19d 00000000 utx             long    0                               ' Byte to transmit on USB
00698 19e 00000000 urx             long    0                               ' Written by ISR only. LSByte receiver status flags, MSByte received data
0069c 19f 00000000 newb_flg        long    0                               ' Receive "new byte" bit toggle detector
006a0 1a0 00000000 hevent          long    0                               ' Command/request eventID posted by the driver cog
006a4 1a1 00000000 max_pkt_size    long    0                               ' Maximum payload bytes allowed, likely to change on device connect.
006a8 1a2 00000000 total_data      long    0                               ' Total bytes to tx/rx in a transfer data stage
006ac 1a3 00000000 stage_data      long    0                               ' Count of bytes sent/received so far during a data stage.
006b0 1a4 00000000 pkt_data        long    0                               ' Payload size of an OUT packet or bytes received on IN
006b4 1a5 00000000 frame           long    0                               ' USB 1ms frame counter value
006b8 1a6 00000000 sof_pkt         long    0                               ' ISR frame# packet and CRC5
006bc 1a7 00000000 icrc            long    0                               ' Only used by the 1ms frame output ISR routine
006c0 1a8 00000000 pkt_cnt         long    0                               ' Count of DATAx packet payload bytes
006c4 1a9 00000000 dbgc            long    0                               ' Debug count/index
006c8 1aa 00000000 crc             long    0                               ' Used for CRC16 calculation
006cc 1ab 00000000 ep_addr_pid     long    0                               ' Endpoint and device addresses for connected device
006d0 1ac 00000000 retval          long    0                               ' Global success/fail return parameter
006d4 1ad 00000000 context_retval  long    0                               ' Operation contextual return parameter
006d8 1ae 00000000 htmp            long    0                               ' Scratch registers whose context remains within the same code block
006dc 1af 00000000 isr_tmp         long    0
006e0 1b0 00000000 pkt_tmp         long    0                               ' Tmp storage for routines that deal with datax packets
006e4 1b1          hreg_init_end
006e4 1b1 efbeedfe                 long    DBG_FEEDBEEF                    ' End of used cog space marker
006e8 1b2 ffffffff                 long    -1[$1f0 - $]                    ' Fill remaining free cog space with $FFs
007e0 1f0                          fit     $1f0
                   ' */
                   ' #endregion DAT (Host Cog)
                   ' #region (Boot Protocol Mouse/Keyboard Hub Interface)
                   con
                   '------------------------------------------------------------------------------
                   ' Refrence: Device Class Definition for Human Interace Devices (HID), v1.11,
                   ' Appendix B: Boot Interface.
                   '------------------------------------------------------------------------------
                   ' Boot protocol mouse constants:
                   '------------------------------------------------------------------------------
                   ' Mouse button bit assignments (left, right, center):
                           #0, MOUSE_LBTNB, MOUSE_RBTNB, MOUSE_CBTNB       ' Button bits 3..7 device specific
                   ' Mouse button bitflags:
                           MOUSE_LBTNF     = |< MOUSE_LBTNB
                           MOUSE_RBTNF     = |< MOUSE_RBTNB
                           MOUSE_CBTNF     = |< MOUSE_CBTNB
                   '------------------------------------------------------------------------------
                   ' The mouse data should be treated as read-only.
                   ' Whenever the driver processes a mouse event, it will refresh the mouse
                   ' position/button data and increment the mouse_count location. The client
                   ' should poll this location to determine when to read new data.
                   '------------------------------------------------------------------------------
                   dat
007e0                              orgh
                   
007e0     00000000 mouse_count     long    0                               ' Count is incremented at every mouse event posted by the driver
007e4     00000000 mouse_x         long    0                               ' Signed X displacement min -127, max 127
007e8     00000000 mouse_y         long    0                               ' Signed Y displacement min -127, max 127
007ec     00000000 mouse_btnflgs   long    0                               ' See above "Mouse button bit assignments" constants
                   
                   con
                   '------------------------------------------------------------------------------
                   ' Boot protocol keyboard constants:
                   '------------------------------------------------------------------------------
                   ' Keyboard LED output report toggle key bit postions:
                           #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
                           LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
                   ' Keyboard LED output report toggle key bitflags:
                           LED_NUMLKF   = |< LED_NUMLKB
                           LED_CAPSLKF  = |< LED_CAPSLKB
                           LED_SCRLKF   = |< LED_SCRLKB
                           LED_COMPOSEF = |< LED_COMPOSEB
                           LED_KANAF    = |< LED_KANAB
                           LED_CONST0F  = |< LED_CONST0B
                           LED_CONST1F  = |< LED_CONST1B
                           LED_CONST2F  = |< LED_CONST2B
                   ' Keyboard modifier key bit positions:
                           #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
                           RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
                   ' Keyboard modifier bitflags
                           LEFT_CTRLF   = |< LEFT_CTRLB
                           LEFT_SHIFTF  = |< LEFT_SHIFTB
                           LEFT_ALTF    = |< LEFT_ALTB
                           LEFT_GUIF    = |< LEFT_GUIB
                           RIGHT_CTRLF  = |< RIGHT_CTRLB
                           RIGHT_SHIFTF = |< RIGHT_SHIFTB
                           RIGHT_ALTF   = |< RIGHT_ALTB
                           RIGHT_GUIF   = |< RIGHT_GUIB
                   ' Keyboard modifier flag combinations:
                           KEY_SHIFT = LEFT_SHIFTF | RIGHT_SHIFTF
                           KEY_ALT   = LEFT_ALTF | RIGHT_ALTF
                   '------------------------------------------------------------------------------
                   ' The keyboard data should be treated as read-only.
                   ' Whenever the driver processes a keyboard event, it will refresh the keyboard
                   ' key/flags data and increment kbd_count location. The client should poll this
                   ' location to determine when to read new data.
                   ' FIXME: Need a real keypress buffer...
                   '------------------------------------------------------------------------------
                   dat
007f0                              orgh
                   
007f0     00000000 kbd_count       long    0                               ' Count is incremented at every keyboard event posted by the driver
007f4     00000000 kbd_keypress    long    0                               ' ASCII keycode of keypress
007f8     00000000 kbd_modkeys     long    0                               ' See above "Keyboard modifier key bit positions" constants
007fc     00000000 kbd_ledstate    long    0                               ' See above "Keyboard LED output report toggle key bit postions" constants
                   ' #endregion DAT (Boot protocol mouse/keyboard hub interface)
                   ' #region DAT (Host HubExec)
                   ' /* usb_start
                   '------------------------------------------------------------------------------
                   ' Subroutine to start the USB host/driver by using the COGINIT option to locate
                   ' and start an unused even/odd cog pair.
                   ' README: Call this subroutine to start the USB host and device driver code
                   ' from your program. THIS ROUTINE ALTERS THE CONTENT OF THE PA REGISTER.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  PA register set to zero on success, non-zero if COGINIT error.
                   '------------------------------------------------------------------------------
                   dat
00800                              orgh
00800                              alignl
00800              usb_start
00800     f607ec11                 mov     pa, #%0_1_0001                  ' COGINIT option to find even/odd stopped/unallocated cog pair
00804     ff000000                 coginit pa, ##@usb_host         wc
00808     fcf7ec20 
0080c     3607ec00         if_nc   mov     pa, #0                          ' Clear PA to signal COGINIT success
00810     fd64002d                 ret
                   ' */
                   ' /* host_reset
00814              host_reset
00814     fd640025                 setint1 #0
00818     fd644258                 drvl    #DP
0081c     fd644058                 drvl    #DM
00820     fc0c0021                 wrpin   #0, #DP                         ' Disable smart pins
00824     fc0c0020                 wrpin   #0, #DM
00828     fd64c81f                 waitx   #100
0082c     fd644250                 fltl    #DP                             ' Passively read DP and DM lines
00830     fd644050                 fltl    #DM
00834     f607ed8e                 mov     pa, #hreg_init_start            ' Reset all host common registers
00838              .loop
00838     f98fec00                 altd    pa
0083c     f6040000                 mov     0-0, #0
00840     f107ec01                 add     pa, #1
00844     f20fedb1                 cmp     pa, #hreg_init_end      wz
00848     5d9fffec         if_nz   jmp     #.loop
0084c     fed0197f                 loc     ptra, #@cache_start             ' Clear the USB descriptor buffer area
00850     ff000011                 mov     hr0, ##cache_end
00854     f6071d60 
00858     f1831df8                 sub     hr0, ptra
0085c     f6071e00                 mov     hr1, #0                         ' Clear the host request result cache in hub RAM
00860     fda0018b                 call    #memset                         ' memset(PTRA, hr0, hr1)
00864     fc3c01fc                 wrlut   #H_READY, #H_EVENT
00868     fdb00478                 call    #hpulse_led                     ' DEBUG: initialize the host connect wait loop blinking LED
                   '-----------------------------------------------------------------------------------------------------------------
                   ' Device connect handling (Section 7.1.7.3).
                   '-----------------------------------------------------------------------------------------------------------------
                   ' The smart pin transceiver is not configured at this stage. The 15K pull-down resistors on D+ and D- allow the
                   ' host to passively monitor the bus lines while waiting for a device to connect (Section 7.1.7.3).
                   '-----------------------------------------------------------------------------------------------------------------
0086c              disconnected
0086c     fd700624                 pollct3                         wc
00870     cdb00470         if_c    call    #hpulse_led                     ' Toggle the host wait for connect USER_LED
00874     fd744240                 testp   #DP                     wc      ' Wait for rise of DP or DM, mutually exclusive
00878     fd6c4040                 testp   #DM                     wz
0087c     1d9fffec   if_nc_and_nz  jmp     #disconnected                   ' DP and DM still low, so keep waiting for connect
00880     4d90003c   if_c_and_nz   jmp     #.connect_test                  ' DP or DM high is LS/FS connect state
00884     2d900038   if_nc_and_z   jmp     #.connect_test
00888              .se1_test
00888     ff803d09                 waitx   ##_1ms * 100                    ' In illegal SE1 state, so wait and retest
0088c     fd64001f 
00890     fd744240                 testp   #DP                     wc
00894     fd6c4040                 testp   #DM                     wz
00898     8d900008   if_c_and_z    jmp     #.se1                           ' Still in illegal SE1 state, so throw error and stop
0089c     f6075800                 mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
008a0     fd9fffc8                 jmp     #disconnected                   ' Back to connect detection loop
008a4     fed01787 .se1            loc     ptra, #@sz_err_se1
008a8     f6075802                 mov     retval, #ERR_SE1
                                   ' DEBUG: SE1 is error condition
008ac     fdb003ec                 call    #htx_result_to_con
008b0     ff803d09                 waitx   ##_1ms * 100
008b4     fd64001f 
008b8     f6035996                 mov     retval, hstatus
008bc     fd9003f4                 jmp     #dbg_break                      ' Seeing SE1 for any length of time is not good...
008c0              .connect_test                                           ' Test lines until stable J/K state seen
008c0     ff803d09                 waitx   ##_1ms * 100                    ' Total of 100ms debounce interval (Section 7.1.7.3)
008c4     fd64001f 
008c8     fd744240                 testp   #DP                     wc
008cc     fd6c4040                 testp   #DM                     wz
008d0     1d9fff98   if_nc_and_nz  jmp     #disconnected                   ' DP and DM low
008d4     8d9fffb0   if_c_and_z    jmp     #.se1_test                      ' DP and DM high
008d8              connected
008d8     f4272c01                 bith    hstatus, #CONNECTEDB            ' Device plugged in
008dc     fd645059                 drvh    #HOST_WAIT_LED                  ' DEBUG: stays lit while device connected
008e0     fdb00400                 call    #hpulse_led                     ' Initialize the main loop activity USER_LED pulse timer
008e4     fdb000b8                 call    #on_connect                     ' Initial device configuration
                   ' Fall through to idle/processing loop
                   ' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
008e8              hidle
008e8     fd700624                 pollct3                         wc
008ec     cdb003f4         if_c    call    #hpulse_led                     ' Toggle the main loop activity indicator USER_LED
008f0     fd700824                 pollse1                         wc
008f4     cda0000c         if_c    call    #do_hevent
008f8     fa873c20                 rqpin   urx, #DM
008fc     f4173c02                 testb   urx, #SE0_RESETB        wc
00900     cd900004         if_c    jmp     #.se0_test
00904     fd9fffe0                 jmp     #hidle
                   ' Check for extended SE0 state on the bus
00908              .se0_test
00908     ff00009c                 mov     hctwait, ##_1ms
0090c     f6072e80 
00910     fda00151                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
00914     fa873c20                 rqpin   urx, #DM
00918     f4173c02                 testb   urx, #SE0_RESETB        wc
0091c     3d9fffc8         if_nc   jmp     #hidle                          ' Bus still IDLE
00920     fd640025                 setint1 #0                              ' Turn off frame strobe interrupt
00924     fd645050                 fltl    #HOST_WAIT_LED                  ' DEBUG
00928     fd645250                 fltl    #HOST_ACTIVITY_LED              ' DEBUG
0092c     f6074006                 mov     hevent, #DINF_DISCONNECT
00930     f60321ab                 mov     hpar1, ep_addr_pid
00934     fda00017                 call    #post_devent                    ' Inform HID driver of reset/disconnect
00938     ff82625a                 waitx   ##_1ms * 1000
0093c     fd64001f 
00940     fd9ffed0                 jmp     #host_reset                     ' Device disconnected
                   ' */
                   ' /* load_lut
                   '------------------------------------------------------------------------------
                   ' The host owns LUT cells 256..511.
                   '------------------------------------------------------------------------------
00944              load_host_lut
00944     fd64002d                 ret
                   ' */
                   ' /* dev_reset
                   '------------------------------------------------------------------------------
                   ' Reset connected device FIXME: speed selection should be POST RESET?
                   ' If it's initial connect, start the transceiver and set it to detected speed
                   '------------------------------------------------------------------------------
00948              dev_reset
00948     fd744040                 testp   #DM                     wc
0094c     c4272c02         if_c    bith    hstatus, #LOW_SPEEDB            ' DM pulled high, so it's a Low-Speed device
00950     cdb00324         if_c    call    #set_speed_low                  ' Configure pins for detected speed
00954     3db002fc         if_nc   call    #set_speed_full
00958     fd644241                 dirh    #DP                             ' Crank them smart pins up
0095c     fd644041                 dirh    #DM
00960     fd64c81f                 waitx   #100
00964              reset
00964     fd640025                 setint1 #0                              ' Don't want frame interrupt at reset
00968     fc2c0220                 wypin   #OUT_SE0, #DM                   ' Assert bus reset
0096c     ff800927                 waitx   ##RESET_HOLD                    ' Spec is >= 10ms
00970     fd67001f 
00974     fc2c0020                 wypin   #OUT_IDLE, #DM
00978     f4072c04                 bitl    hstatus, #TXN_LIMITB            ' Reset the frame txn OK/!OK flag
0097c     f6074a00                 mov     frame, #0                       ' Reset the frame count
00980     fd63261a                 getct   hct1                            ' Reset the frame timer
00984     ff000068                 addct1  hct1, ##TXN_OK_ZONE
00988     fa672670 
0098c     fd640225                 setint1 #1                              ' Set ISR event trigger to CT1-equals-CT
00990     ff000cd1                 mov     hctwait, ##_1ms * 21
00994     f6072e80 
00998     fda00151                 call    #poll_waitx                     ' Allow reset recovery time (Section 9.2.6.2)
0099c     fd64002d                 ret
                   ' */
                   ' /* on_connect
                   '------------------------------------------------------------------------------
                   ' Perform configuration stuff required when a device intitially connects.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
009a0              on_connect
009a0     f6071c02                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
009a4     fdbfffa0                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
009a8              .retry
009a8     f6074005                 mov     hevent, #DINF_CONNECT           ' Prepare to inform driver a device has connected
009ac     f4172c02                 testb   hstatus, #LOW_SPEEDB    wc
009b0     c6072001         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
009b4     36072002         if_nc   mov     hpar1, #USB_SPEED_FULL
009b8     fda00017                 call    #post_devent
009bc     ff000800                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
009c0     f6075600 
009c4     fed017a4                 loc     ptra, #@get_dev_desc            ' Hub start address of GetDeviceDescriptor SETUP struct
009c8     fc5c8103                 wrword  #$40, ptra[wLength]             ' Request IN data stage max of 64 bytes will test actual < requested logic
009cc     feb0187f                 loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct for IN data
009d0     fda0001d                 call    #control_read                   ' Execute GetDeviceDescriptor()
009d4     fed01353                 loc     ptra, #@sz_getdev_result
009d8     fdb002c0                 call    #htx_result_to_con              ' Route results to terminal
009dc     f20f58d2                 cmp     retval, #PID_ACK        wz
009e0     ad900020         if_z    jmp     #.get_dev_desc
009e4     ff02625a                 mov     hctwait, ##_1ms * 1000          ' If the first GetDescriptor() fails, reset and try again
009e8     f6072e00 
009ec     fda00151                 call    #poll_waitx
009f0     f18f1c01                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
009f4     ad635c2b         if_z    pop     htmp                            ' This POP should empty the hardware stack
009f8     ad9ffe18         if_z    jmp     #host_reset                     ' Re-initialize everything if reset retry limit exceeded
009fc     fdbfff64                 call    #reset                          ' Try another reset to see if the device responds
00a00     fd9fffa4                 jmp     #.retry
00a04              .get_dev_desc
00a04     fe901847                 loc     pa, #@dev_desc_buff             ' Fetch the max packet size for control transactions from the
00a08     f107ec07                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
00a0c     fac343f6                 rdbyte  max_pkt_size, pa
00a10     ff00009c                 mov     hctwait, ##_1ms
00a14     f6072e80 
00a18     fda00151                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
00a1c     fdbfff44                 call    #reset
00a20     fed01760                 loc     ptra, #@set_address             ' Hub start address of SetAddress SETUP struct
00a24     fc5c0301                 wrword  #1, ptra[wValue]                ' Only support one device port at this time
00a28     fda0006a                 call    #control_write                  ' Execute SetAddress()
00a2c     fed01337                 loc     ptra, #@sz_setaddr_result
00a30     fdb00268                 call    #htx_result_to_con              ' Route results to terminal
00a34     f20f58d2                 cmp     retval, #PID_ACK        wz
00a38     5d64002d         if_nz   ret                                     ' Back to idle if not ACK
00a3c     ff0004e2                 mov     hctwait, ##_1ms * 8
00a40     f6072e00 
00a44     fda00151                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
00a48     ff000000                 mov     ep_addr_pid, ##1 << 8           ' Device ep/addr now #1 and endpoint zero
00a4c     f6075700 
00a50     fdb001b8                 call    #calc_crc5
00a54     fed01714                 loc     ptra, #@get_dev_desc            ' Repeat SETUP for GetDeviceDescriptor()
00a58     feb017f3                 loc     pb, #@dev_desc_buff             ' Start address of DeviceDescriptor struct has exact descriptor length
00a5c     fac345f7                 rdbyte  total_data, pb
00a60     fc574503                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
00a64     fda0001d                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
00a68     f20f58d2                 cmp     retval, #PID_ACK        wz
00a6c     ad900008         if_z    jmp     #.ack0
00a70     fed012b7                 loc     ptra, #@sz_getdev_result
00a74     fd900224                 jmp     #htx_result_to_con              ' Route error result to terminal and back to idle state
00a78              .ack0
00a78     f6074007                 mov     hevent, #DINF_DEV_DESC          ' Notify driver cog that the device descriptor is cached
00a7c     f60321ab                 mov     hpar1, ep_addr_pid
00a80     ff000011                 mov     hpar2, ##dev_desc_buff
00a84     f607224f 
00a88     f60325ac                 mov     hpar3, retval
00a8c     fda00017                 call    #post_devent
00a90     ff00004e                 mov     hctwait, ##_1us * 500
00a94     f6072e40 
00a98     fda00151                 call    #poll_waitx
00a9c     fed016d4                 loc     ptra, #@get_config_desc         ' Hub start address of GetConfigurationDescriptor SETUP struct
00aa0     fc5dff03                 wrword  #$ff, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
00aa4     feb017b9                 loc     pb, #@con_desc_buff             ' Hub start address of ConfigurationDescriptor structure
00aa8     fda0001d                 call    #control_read                   ' Execute GetConfigurationDescriptor()
00aac     f20f58d2                 cmp     retval, #PID_ACK        wz
00ab0     ad900008         if_z    jmp     #.ack1
00ab4     fed01291                 loc     ptra, #@sz_getconf_result
00ab8     fd9001e0                 jmp     #htx_result_to_con              ' Route error result to terminal and go back to idle state
00abc              .ack1
00abc     fed017a1                 loc     ptra, #@con_desc_buff           ' Check the config descriptor struct for expected data
00ac0     fac71d61                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
00ac4     fac71f61                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
00ac8     fae75d00                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= byte count actually received
00acc     f21f1c09                 cmp     hr0, #CON_DESC_LEN      wcz
00ad0     321f1e02         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
00ad4     a21b5da2         if_z    cmp     htmp, total_data        wcz
00ad8     cd900018         if_b    jmp     #.err_config
00adc     f6074008                 mov     hevent, #DINF_CON_DESC          ' Notify driver cog that the configuration descriptor is cached
00ae0     f60321ab                 mov     hpar1, ep_addr_pid
00ae4     ff000011                 mov     hpar2, ##con_desc_buff
00ae8     f6072261 
00aec     f60325ac                 mov     hpar3, retval
00af0     fd800017                 jmp     #post_devent                    ' From now on the host idles and waits for class driver IRPs
00af4              .err_config
00af4     fed01251                 loc     ptra, #@sz_getconf_result
00af8     f6075803                 mov     retval, #ERR_PACKET
00afc     fd90019c                 jmp     #htx_result_to_con              ' Error to terminal and back to idle state
                   ' */
                   ' /* do_ctrl_read
                   '------------------------------------------------------------------------------
                   ' Execute a ControlRead transaction on behalf of the class driver via the
                   ' event mechanism and post the result.
                   ' TODO: The function address should really be cached by the host and not the
                   '       class driver.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hevent: H_CTRL_READ eventID.
                   ' On exit:  Reports the result of the transaction to the class driver via the
                   '           event mechanism.
                   '------------------------------------------------------------------------------
00b00              do_ctrl_read
00b00     faa757f6                 rdlut   ep_addr_pid, #H_PAR1            ' Function address and control endpoint zero
00b04     faa7f1f7                 rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
00b08     faa7eff8                 rdlut   pb, #H_PAR3                     ' Start address of the IN data buffer
00b0c     fda0001d                 call    #control_read                   ' Execute ControlRead() txn
00b10     f6074009                 mov     hevent, #DTXN_RESULT
00b14     f60321ab                 mov     hpar1, ep_addr_pid              ' Confirm USB target
00b18     f60323ac                 mov     hpar2, retval                   ' Transaction overall result
00b1c     f60325ad                 mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
00b20     fd800017                 jmp     #post_devent                    ' Post results to the class driver and return to caller
                   ' */
                   ' /* do_ctrl_write
                   '------------------------------------------------------------------------------
                   ' Execute a ControlWrite transaction on behalf of the class driver via the
                   ' event mechanism.
                   ' TODO: The function address should really be cached by the host and not the
                   '       class driver.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hevent: HCTRL_WRITE eventID.
                   ' On exit:  Reports the result of the transaction to the class driver via the
                   '           event mechanism.
                   '------------------------------------------------------------------------------
00b24              do_ctrl_write
00b24     faa757f6                 rdlut   ep_addr_pid, #H_PAR1            ' Function address and control endpoint zero
00b28     faa7f1f7                 rdlut   ptra, #H_PAR2                   ' Start address of the SETUP struct to use
00b2c     faa7eff8                 rdlut   pb, #H_PAR3                     ' Start address of the OUT data buffer
00b30     fda0006a                 call    #control_write                  ' Execute ControlWrite() txn
00b34     f6074009                 mov     hevent, #DTXN_RESULT
00b38     f60321ab                 mov     hpar1, ep_addr_pid              ' Confirm USB target
00b3c     f60323ac                 mov     hpar2, retval                   ' Transaction overall result
00b40     f60325ad                 mov     hpar3, context_retval           ' If non-zero, an error code for the specific error encountered
00b44     fd800017                 jmp     #post_devent                    ' Post results to the class driver and return to caller
                   ' */
                   ' /* do_int_in
                   '------------------------------------------------------------------------------
                   ' Execute an IN interrupt transaction on behalf of the class driver via the
                   ' event mechanism.
                   ' FIXME: The function address, endpoint and data toggle info should be cached
                   '        and maintained by the host and not the class driver.
                   '        Need to handle IN data lengths > max_pkt_size.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hevent: HINT_IN eventID.
                   ' On exit:  Reports the result of the transaction to the class driver via the
                   '           host<->driver event mechanism.
                   '------------------------------------------------------------------------------
00b48              do_int_in
00b48     faa757f6                 rdlut   ep_addr_pid, #H_PAR1            ' Function address and endpoint
00b4c     faa725f8                 rdlut   hpar3, #H_PAR3                  ' Word1 max_pkt, word0 DATAx to expect
00b50     ff0003ff                 testn   ep_addr_pid, ##EP_ADDR_MASK wz
00b54     f7ef57ff 
00b58     adb000b0         if_z    call    #calc_crc5                      ' Calculate CRC5 if not yet done
00b5c     f9335d92                 getword htmp, hpar3, #0
00b60     f20f5cc3                 cmp     htmp, #PID_DATA0        wz
00b64     f4a72c03                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
00b68     f6073806                 mov     retry, #TXN_RETRIES
00b6c              .retry
00b6c     f93b4992                 getword pkt_data, hpar3, #1             ' IN max packet length
00b70     fda000a6                 call    #txn_in
00b74     f20f58d2                 cmp     retval, #PID_ACK        wz
00b78     ad90001c         if_z    jmp     #.commit
00b7c     f20f585a                 cmp     retval, #PID_NAK        wz
00b80     520f581e         if_nz   cmp     retval, #PID_STALL      wz
00b84     ad900028         if_z    jmp     #.post_ret                      ' IRP poster must handle NAK or STALL
00b88     fdb0003c                 call    #retry_wait
00b8c     f20f5805                 cmp     retval, #ERR_TXN_RETRY  wz
00b90     ad90001c         if_z    jmp     #.post_ret
00b94     fd9fffd4                 jmp     #.retry
00b98              .commit
00b98     f20f5000                 cmp     pkt_cnt, #0             wz
00b9c     ad900010         if_z    jmp     #.post_ret                      ' Skip copy if it's an empty packet
00ba0     fed0162b                 loc     ptra, #@urx_buff                ' Copy DATAx in rx buffer to dest buffer
00ba4     faa7eff7                 rdlut   pb, #H_PAR2                     ' Start address of buffer for the IN data
00ba8     f6031da8                 mov     hr0, pkt_cnt
00bac     fda00186                 call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
00bb0              .post_ret
00bb0     f6074009                 mov     hevent, #DTXN_RESULT
00bb4     f60321ab                 mov     hpar1, ep_addr_pid              ' Confirm USB target
00bb8     f60323ac                 mov     hpar2, retval                   ' Transaction result
00bbc     f60325a8                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
00bc0     fd800017                 jmp     #post_devent                    ' Post results to the class driver and return to caller
                   ' */
                   ' /* do_int_out
                   '------------------------------------------------------------------------------
                   ' Execute an OUT interrupt transaction on behalf of the class driver via the
                   ' event mechanism.
                   '------------------------------------------------------------------------------
00bc4              do_int_out
00bc4     fd64002d                 ret
                   ' */
                   ' /* retry_wait
                   '------------------------------------------------------------------------------
                   ' Transaction retry handling for NAK/STALL or bus error.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg retval: transaction response PID or error code.
                   ' On exit:
                   '------------------------------------------------------------------------------
00bc8              retry_wait
00bc8     f20f585a                 cmp     retval, #PID_NAK        wz
00bcc     af000002         if_z    mov     hctwait, ##_1us * 17            ' This seems to be a decent IN/OUT-NAK delay period
00bd0     a6072f50 
00bd4     5f000007         if_nz   mov     hctwait, ##_1us * 51            ' More time for TAT and other errors
00bd8     56072ff0 
00bdc     fda00151                 call    #poll_waitx                     ' poll_waitx doesn't touch Z flag
00be0     ad900014         if_z    jmp     #.nak
00be4     f20f581e                 cmp     retval, #PID_STALL      wz
00be8     ad64002d         if_z    ret                                     ' STALL is special case
00bec              .dec
00bec     f18f3801                 sub     retry, #1               wz
00bf0     a6075805         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
00bf4     fd64002d                 ret                                     ' Retry result to caller
00bf8              .nak
00bf8     f20f3400                 cmp     nak_retry, #NAK_NOLIMIT wz
00bfc     ad64002d         if_z    ret                                     ' Indefinite NAK retries
00c00     f18f3401                 sub     nak_retry, #1           wz
00c04     a6075807         if_z    mov     retval, #ERR_NAK
00c08     fd64002d                 ret
                   ' */
                   ' /* calc_crc5
                   '------------------------------------------------------------------------------
                   ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
                   ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
                   ' length, and the PID is not included in the CRC calculation:
                   '  CRC5  FRAME_NUMBER SOF (full-speed)
                   '  CRC5  ENDP ADDRESS PID
                   ' %00000_1111_1111111_xxxxxxxx
                   '------------------------------------------------------------------------------
                   ' On entry: Reg ep_addr_pid: stuffed with the function endpoint, address and
                   '           SETUP/IN/OUT/SOF PID according to the USB standard.
                   ' On exit:  Reg ep_addr_pid: CRC value appended to the packet.
                   '------------------------------------------------------------------------------
00c0c              calc_crc5
00c0c     ff0003ff                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
00c10     f50757ff 
00c14     f6035dab                 mov     htmp, ep_addr_pid
00c18     f0475c08                 shr     htmp, #8                        ' PID not included in CRC calc
00c1c     f607541f                 mov     crc, #$1f                       ' Initial CRC5 value
00c20     fd635c69                 rev     htmp                            ' Input data reflected
00c24     fd635c28                 setq    htmp                            ' CRCNIB setup for data bits 0..7
00c28     f9df5414                 crcnib  crc, #USB5_POLY
00c2c     f9df5414                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
00c30     f0775c09                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
00c34     f9d75414                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
00c38     f0775c01                 shl     htmp, #1                wc
00c3c     f9d75414                 crcbit  crc, #USB5_POLY
00c40     f0775c01                 shl     htmp, #1                wc
00c44     f9d75414                 crcbit  crc, #USB5_POLY
00c48     f567541f                 xor     crc, #$1f                       ' Final XOR value
00c4c     f0675413                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
00c50     054357aa         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
                   ' */
                   ' /* set_speed_full
                   '------------------------------------------------------------------------------
                   ' Configure smart pins for USB host, Full-Speed
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
00c54              set_speed_full
00c54     fc0ce421                 wrpin   #%1_11001_0, #DP                ' Configure DP pin (passive)
00c58     fc0ce420                 wrpin   #%1_11001_0, #DM                ' Configure DM pin (the brain)
00c5c     ff800013                 wxpin   ##_12Mbps, #DM                  ' Set 12Mbps Full-Speed mode
00c60     fc1ccc20 
00c64     f6074240                 mov     max_pkt_size, #64               ' Maximum full-speed control read/write DATAx packet size
00c68     ff000001                 mov     tat_wait, ##TAT_WAIT_FS         ' Bus turn-around time in full-speed bit periods
00c6c     f6073298 
00c70     ff000000         _ret_   mov     ip_delay, ##IP_DELAY_FS         ' Inter-packet delay in full-speed bit periods
00c74     06073017 
                   ' */
                   ' /* set_speed_low
                   '------------------------------------------------------------------------------
                   ' Configure smart pins for USB host, Low-Speed
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
00c78              set_speed_low
00c78     fc0ce021                 wrpin   #%1_11000_0, #DP                ' Configure DP pin (passive)
00c7c     fc0ce020                 wrpin   #%1_11000_0, #DM                ' Configure DM pin (the brain)
00c80     ff800002                 wxpin   ##_1_5Mbps, #DM                 ' Set 1.5Mbs Low-Speed mode
00c84     fc1d9a20 
00c88     f6074208                 mov     max_pkt_size, #8                ' Maximum low-speed control read/write DATAx packet size
00c8c     ff000003                 mov     tat_wait, ##TAT_WAIT_LS         ' Bus turn-around time in low-speed bit periods
00c90     f6073241 
00c94     ff000000         _ret_   mov     ip_delay, ##IP_DELAY_LS         ' Inter-packet delay in low-speed bit periods
00c98     060730bb 
                   ' */
                   ' /* htx_result_to_con
                   '------------------------------------------------------------------------------
                   ' Send USB transaction or other event results to the serial terminal via the
                   ' host->class driver event mechanism. If the "verbose" output option is active,
                   ' output is unfiltered, otherwise ACK/SUCCESS result codes are suppressed.
                   '
                   ' NOTE: only call this routine prior to the class driver being notified that
                   '       the device and configuration descriptors have been successfully read.
                   '       After that happens, all USB I/O is done using the class driver->host
                   '       IRP mechanism, which does its own transaction result handling.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: address of the transaction/event zero-terminated
                   '           description string. If zero, a generic description will be used.
                   '           Reg retval: value of the result.
                   ' On exit:
                   '------------------------------------------------------------------------------
00c9c              htx_result_to_con
00c9c     f60321f8                 mov     hpar1, ptra
00ca0     f60323ac                 mov     hpar2, retval
00ca4     f6072440                 mov     hpar3, #RXERRF
00ca8     f5032596                 and     hpar3, hstatus                  ' RXERRF is never good
00cac     f607400a                 mov     hevent, #DTXN_HRESULT
00cb0     fd800017                 jmp     #post_devent
                   ' */
                   ' /* dbg_break
                   '------------------------------------------------------------------------------
                   ' Output a debug value and stop the host.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg retval: whatever debug info that fits into a long.
                   ' On exit:  You can check in any time you like, but you will never leave...
                   '------------------------------------------------------------------------------
00cb4              dbg_break
00cb4     f60321ac                 mov     hpar1, retval
00cb8     f6074002                 mov     hevent, #DREQ_BREAK
00cbc     fda00017                 call    #post_devent
00cc0     fd604224                 stalli
00cc4     ff81312d                 waitx   ##_1ms * 500
00cc8     fd64001f 
00ccc     fd9ffffc .halt           jmp     #.halt
                   ' */
                   ' /* dbg_hexdump
                   '------------------------------------------------------------------------------
                   ' Dump hex byte data to the terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg hpar1: start address of data.
                   '           Reg hpar2: length of data, in bytes.
                   '------------------------------------------------------------------------------
00cd0              dbg_hexdump
00cd0     f6074004                 mov     hevent, #DREQ_HEXDUMP
00cd4     fd800017                 jmp     #post_devent
                   ' */
                   ' /* dbg_data
                   '------------------------------------------------------------------------------
                   ' Dump hex byte data to the terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg retval: arbitrary debug value.
                   ' On exit:
                   '------------------------------------------------------------------------------
00cd8              dbg_data
00cd8     f6074003                 mov     hevent, #DREQ_DBG_DATA
00cdc     f60321ac                 mov     hpar1, retval
00ce0     fd800017                 jmp     #post_devent
                   ' */
                   ' /* hpulse_led
                   '------------------------------------------------------------------------------
                   ' Toggle a Prop123-A9 USER_LED when the host is the connect wait loop or the
                   ' main USB processing loop.
                   '------------------------------------------------------------------------------
00ce4              hpulse_led
00ce4     fd632a1a                 getct   hct3
00ce8     ff01312d                 addct3  hct3, ##PULSE_TIME
00cec     fa772a00 
00cf0     f4172c01                 testb   hstatus, #CONNECTEDB    wc
00cf4     3d64505f         if_nc   drvnot  #HOST_WAIT_LED
00cf8     cd64525f         if_c    drvnot  #HOST_ACTIVITY_LED
00cfc     fd64002d                 ret
                   ' */
                   ' #endregion DAT (Host HubExec)
                   ' #region DAT (Class Driver HubExec)
                   '------------------------------------------------------------------------------
                   ' USB Class Driver hub exec routines. Save the cog space for time critical
                   ' stuff.
                   '------------------------------------------------------------------------------
                   dat
00d00                              orgh
                   ' /* parse_dev_desc
                   '------------------------------------------------------------------------------
                   ' Parse the Device Descriptor. For now just parse out the string indexes. Root
                   ' out additional info as needed.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg devent: eventID.
                   '           Reg dpar1: device address and control pipe endpoint (0).
                   '           Reg dpar2: start address of the cached device descriptor struct.
                   ' On exit:
                   '------------------------------------------------------------------------------
00d00              parse_dev_desc
00d00     f603a9c2                 mov     ctrl_ep_addr, dpar1             ' Save the ctrlep/addr of the device
00d04     f603adc3                 mov     device_base, dpar2              ' Save start address of device descriptor
00d08     fed0101f                 loc     ptra, #@sz_getdev_result        ' Since the intent is to parse the device
00d0c     f60387c4                 mov     dpar2, dpar3                    ' descriptor, the result *should* always be ACK
00d10     fd900548                 jmp     #dtx_result_to_con
                   ' */
                   ' /* parse_con_desc
                   '------------------------------------------------------------------------------
                   ' Parse a configuration descriptor chain to see if the device is a recognized
                   ' one. If it is, start the task progression that will configure the device for
                   ' use.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg devent: eventID.
                   '           Reg dpar1: device address and control pipe endpoint (0).
                   '           Reg dpar2: start address of the cached config descriptor chain.
                   ' On exit:
                   '------------------------------------------------------------------------------
00d14              parse_con_desc
00d14     f603a9c2                 mov     ctrl_ep_addr, dpar1             ' Get ctrlep/addr of the device
00d18     f603afc3                 mov     config_base, dpar2              ' Save start address of config chain
00d1c     fed01029                 loc     ptra, #@sz_getconf_result       ' Since the intent is to parse the configuration
00d20     f60387c4                 mov     dpar2, dpar3                    ' descriptor, the result *should* always be ACK
00d24     fdb00534                 call    #dtx_result_to_con
00d28     fdb0060c                 call    #init_kbd_data                  ' Reset keyboard/mouse data area to start-up values
00d2c     f607ec02                 mov     pa, #CON_wTotalLen
00d30     f103edd7                 add     pa, config_base
00d34     fae39ff6                 rdword  con_tot_len, pa                 ' Keep config chain size handy
00d38     fdb00008                 call    #search_boot_triad              ' The heavy lifting is done here
00d3c     f607aa01                 mov     dtask, #DT_SET_CONF             ' Direct to configuration decision
00d40     fd64002d                 ret
                   ' */
                   ' /* search_boot_triad
                   '------------------------------------------------------------------------------
                   ' Search the configuration descriptor chain looking for the interface
                   ' Class/SubClass/Protocol "triad" that defines a keyboard and/or mouse.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg config_base: start address of the config descriptor chain.
                   '           Reg con_tot_len: total length of the config descriptor chain.
                   ' On exit:  Reg kbd_ep_addr will be non-zero if a boot keyboard found.
                   '           Reg mouse_ep_addr will be non-zero if a boot mouse found.
                   '------------------------------------------------------------------------------
00d44              search_boot_triad
00d44     fac3a5d7                 rdbyte  next_desc, config_base          ' Config desc size is offset to first desc in chain
00d48              .next_intf
00d48     f607a204                 mov     search_key, #TYPE_INTERFACE
00d4c     fdb000f0                 call    #search_desc_type
00d50     f20ff200                 cmp     ptrb, #0                wz
00d54     ad64002d         if_z    ret                                     ' No more interface descs
00d58     fac79780                 rdbyte  dtmp, ptrb
00d5c     f103a5cb                 add     next_desc, dtmp                 ' Get offset to next desc, if any
00d60     fac7a182                 rdbyte  hid_intf_idx, ptrb[INTF_bIntfNum]
00d64     fac79785                 rdbyte  dtmp, ptrb[INTF_bIntfClass]
00d68     f20f9603                 cmp     dtmp, #CLASS_HID        wz      ' Only interested in the HID class interface descriptors
00d6c     5d9fffd8         if_nz   jmp     #.next_intf                     ' Search next interface in chain, if any
00d70     fac79786                 rdbyte  dtmp, ptrb[INTF_bSubClass]      ' Look for a boot interface sub-class
00d74     f20f9601                 cmp     dtmp, #SUBCLASS_INTF_BOOT wz
00d78     5d9fffcc         if_nz   jmp     #.next_intf
00d7c     facf8387                 rdbyte  dr3, ptrb[INTF_bProtocol] wz    ' Protocol must be non-zero
00d80     ad9fffc4         if_z    jmp     #.next_intf
00d84              .endp
00d84     fd63f22a                 push    ptrb
00d88     fd63a42a                 push    next_desc
00d8c     f607a205                 mov     search_key, #TYPE_ENDPOINT
00d90     fdb000ac                 call    #search_desc_type               ' Endpoint descs always follow interface descs
00d94     f20ff200                 cmp     ptrb, #0                wz
00d98     5d90000c         if_nz   jmp     #.get_ep
00d9c              .bad_ep
00d9c     fd63a42b                 pop     next_desc
00da0     fd63f22b                 pop     ptrb
00da4     fd9fffa0                 jmp     #.next_intf
00da8              .get_ep
00da8     fac77f82                 rdbyte  dr1, ptrb[ENDP_bAddress]
00dac     f4177e07                 testb   dr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
00db0     3d9fffe8         if_nc   jmp     #.bad_ep                        ' Not an IN endpoint
00db4     f5077e0f                 and     dr1, #$0f                       ' FIXME: define constant for IN endpoint address mask
00db8     f0677e0f                 shl     dr1, #8 + 7
00dbc     f107f204                 add     ptrb, #ENDP_wMaxPktSize
00dc0     fae781e1                 rdword  dr2, ptrb++
00dc4     ff000003                 and     dr2, ##$7ff                     ' Bits 10..0 define the max packet size
00dc8     f50781ff 
00dcc     fac77d80                 rdbyte  dr0, ptrb                       ' Fetch the bInterval member (min poll interval, in milliseconds)
00dd0     fd63a42b                 pop     next_desc
00dd4     fd63f22b                 pop     ptrb
00dd8     f20f8201                 cmp     dr3, #INTF_PROTO_KBD    wz
00ddc     5d90002c         if_nz   jmp     #.mouse
00de0              .keyboard
00de0     ff000010                 wrbyte  hid_intf_idx, ##kbd_intf_num    ' Save interface index and poll interval values
00de4     fc47a1a4 
00de8     ff000010                 wrbyte  dr0, ##kbd_interval
00dec     fc477da5 
00df0     f603b1d4                 mov     kbd_ep_addr, ctrl_ep_addr
00df4     ff00003f                 and     kbd_ep_addr, ##ADDR_MASK
00df8     f507b100 
00dfc     f543b1bf                 or      kbd_ep_addr, dr1                ' IN endpoint address
00e00     ff000010                 wrbyte  dr2, ##kbd_in_max_pkt
00e04     fc4781a6 
00e08     fd9fff3c                 jmp     #.next_intf                     ' See if there's a mouse subclass
00e0c              .mouse
00e0c     f20f8202                 cmp     dr3, #INTF_PROTO_MOUSE  wz
00e10     5d9fff34         if_nz   jmp     #.next_intf
00e14     ff000010                 wrbyte  hid_intf_idx, ##mouse_intf_num  ' Save interface index and poll interval values
00e18     fc47a1bb 
00e1c     ff000010                 wrbyte  dr0, ##mouse_interval
00e20     fc477dbc 
00e24     f603b9d4                 mov     mouse_ep_addr, ctrl_ep_addr
00e28     ff00003f                 and     mouse_ep_addr, ##ADDR_MASK
00e2c     f507b900 
00e30     f543b9bf                 or      mouse_ep_addr, dr1              ' IN endpoint address
00e34     ff000010                 wrbyte  dr2, ##mouse_in_max_pkt
00e38     fc4781bd 
00e3c     fd9fff08                 jmp     #.next_intf                     ' See if there's a keyboard protocol
                   ' */
                   ' /* search_desc_type
                   '------------------------------------------------------------------------------
                   ' Search the configuration descriptor chain for a specific descriptor type.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg con_tot_len: total length of the config descriptor chain.
                   '           Reg next_desc: offset from the configuration descriptor to start
                   '           the search. It is assumed that the offset will point to the start
                   '           of a USB standard descriptor.
                   '           Reg search_key: descriptor type to match.
                   ' On exit:  Reg PTRB: if a match is found, the descriptor start address,
                   '           otherwise zero.
                   '           Reg next_desc: descriptor offset if found, otherwise unchanged.
                   '------------------------------------------------------------------------------
00e40              search_desc_type
00e40     fd63a42a                 push    next_desc
00e44              .next
00e44     f21ba5cf                 cmp     next_desc, con_tot_len  wcz
00e48     3607f200         if_ae   mov     ptrb, #0
00e4c     3d63a42b         if_ae   pop     next_desc
00e50     3d64002d         if_ae   ret
00e54     f603f3d7                 mov     ptrb, config_base
00e58     f103f3d2                 add     ptrb, next_desc
00e5c     fac79781                 rdbyte  dtmp, ptrb[DESC_bDescType]
00e60     f20b97d1                 cmp     dtmp, search_key        wz
00e64     ad63962b         if_z    pop     dtmp                            ' Toss the old next_desc value
00e68     ad64002d         if_z    ret
00e6c     fac79780                 rdbyte  dtmp, ptrb
00e70     f103a5cb                 add     next_desc, dtmp                 ' Get offset of next desc to check
00e74     fd9fffcc                 jmp     #.next
                   ' */
                   ' /* dset_config
                   '------------------------------------------------------------------------------
                   ' If a newly-connected device is recognized, do whatever is needed to configure
                   ' it according to its function, or functions. In the case of this boot protocol
                   ' keyboard/mouse class driver:
                   ' - SetConfiguration(config_num)
                   ' - SetProtocol(boot)
                   ' - SetIdle(indefinite)
                   ' - Enter the device interrupt IN polling task stage.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
00e78              dset_config
                   '               mov     kbd_ep_addr, #0                 ' DEBUG
                   '               mov     mouse_ep_addr, #0               ' DEBUG
00e78     f20fb000                 cmp     kbd_ep_addr, #0         wz
00e7c     a20fb800         if_z    cmp     mouse_ep_addr, #0       wz
00e80     5d90000c         if_nz   jmp     #.config                        ' Did we find a boot protocol keyboard and/or mouse?
00e84     fed00fa6                 loc     ptra, #@sz_bummer               ' Unknown device
00e88     f607aa00                 mov     dtask, #DT_IDLE
00e8c     fd800137                 jmp     #dtx_asciiz                     ' Don't bother to configure unknown device
00e90              .config
00e90     fed012e8                 loc     ptra, #@set_config
00e94     f607ec05                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
00e98     f103edd7                 add     pa, config_base
00e9c     fac385f6                 rdbyte  dpar1, pa
00ea0     fc578501                 wrword  dpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
00ea4     f6079802                 mov     devent, #HCTRL_WRITE
00ea8     f60385d4                 mov     dpar1, ctrl_ep_addr
00eac     f60387f8                 mov     dpar2, ptra                     ' SETUP struct addr
00eb0     f6078800                 mov     dpar3, #0                       ' SetConfiguration() has no data stage
00eb4     f607aa00                 mov     dtask, #DT_IDLE                 ' Into task idle until configuration IRP done
00eb8     ff000007                 mov     dres_handler, ##res_conf        ' Label is akin to a callback routine for the IRP result
00ebc     f6079ac4 
00ec0     fd80001f                 jmp     #post_hevent                    ' Post ControlWrite() event
00ec4              res_conf
00ec4     fed00eeb                 loc     ptra, #@sz_setcon_result
00ec8     fdb00390                 call    #dtx_result_to_con
00ecc     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00ed0     5d64002d         if_nz   ret                                     ' FIXME: should try to recover instead of punting to idle
00ed4              kbd_setup
00ed4     f20fb000                 cmp     kbd_ep_addr, #0         wz
00ed8     ad9000a0         if_z    jmp     #mouse_setup                    ' No keyboard, so setup the mouse, if detected
00edc     fed00fcf                 loc     ptra, #@sz_woohoo_kbd
00ee0     fda00137                 call    #dtx_asciiz
00ee4     f6078400                 mov     dpar1, #BOOT_PROTOCOL
00ee8     ff000010                 rdbyte  dpar2, ##kbd_intf_num
00eec     fac787a4 
00ef0     ff000007                 mov     dres_handler, ##res_proto_kbd
00ef4     f6079afc 
00ef8     fd90011c                 jmp     #dset_protocol
00efc              res_proto_kbd
00efc     fed00ec9                 loc     ptra, #@sz_setprot_result
00f00     fdb00358                 call    #dtx_result_to_con
00f04     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00f08     5d900070         if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
00f0c     f6078400                 mov     dpar1, #0                       ' SetIdle() duration 0 = indefinite
00f10     ff000010                 rdbyte  dpar2, ##kbd_intf_num
00f14     fac787a4 
00f18     ff000007                 mov     dres_handler, ##res_kbd_idle
00f1c     f6079b24 
00f20     fd90011c                 jmp     #dset_idle
00f24              res_kbd_idle
00f24     fed00eb2                 loc     ptra, #@sz_setidle_result
00f28     fdb00330                 call    #dtx_result_to_con
00f2c     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00f30     5d900048         if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
00f34     ff800138                 waitx   ##_1ms * 2
00f38     fd66001f 
00f3c     ff000007                 mov     dres_handler, ##res_kbdled0     ' Set the keyboard LED indicators to their startup states
00f40     f6079b48 
00f44     fd900120                 jmp     #dset_kbdled_report
00f48              res_kbdled0
00f48     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00f4c     5d90002c         if_nz   jmp     #mouse_setup                    ' FIXME: should try to recover
00f50     f6079600                 mov     dtmp, #KEY_NO_KEY
00f54     ff000010                 wrbyte  dtmp, ##kbd_last_key
00f58     fc4797ba 
00f5c     f607b400                 mov     kbd_poll_cnt, #0                ' Initialize key auto-repeat counters
00f60     ff000000                 mov     kbd_repeat, ##KBD_REPEAT_DELAY
00f64     f607b63e 
00f68     fed00f64                 loc     ptra, #@sz_kbd_ready            ' DEBUG: to terminal with keyboard ready message
00f6c     fda00137                 call    #dtx_asciiz
00f70     fd638a1a                 getct   dct1
00f74     ff0004e2                 addct1  dct1, ##KBD_POLL_INTERVAL       ' Wait an interval before the first IN poll
00f78     fa678a00 
00f7c              mouse_setup
00f7c     f20fb800                 cmp     mouse_ep_addr, #0       wz
00f80     ad90008c         if_z    jmp     #conf_exit
00f84     fed00f75                 loc     ptra, #@sz_woohoo_mouse
00f88     fda00137                 call    #dtx_asciiz
00f8c     f6078400                 mov     dpar1, #BOOT_PROTOCOL
00f90     ff000010                 rdbyte  dpar2, ##mouse_intf_num
00f94     fac787bb 
00f98     ff000007                 mov     dres_handler, ##res_proto_mouse
00f9c     f6079ba4 
00fa0     fd900074                 jmp     #dset_protocol
00fa4              res_proto_mouse
00fa4     fed00e21                 loc     ptra, #@sz_setprot_result
00fa8     fdb002b0                 call    #dtx_result_to_con
00fac     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00fb0     5607b800         if_nz   mov     mouse_ep_addr, #0
00fb4     5d900058         if_nz   jmp     #conf_exit                      ' FIXME: should try to recover
00fb8     f20fb000                 cmp     kbd_ep_addr, #0         wz
00fbc     5d90002c         if_nz   jmp     #mouse_timer                    ' Skip SetIdle() if it's already been done
00fc0     f6078400                 mov     dpar1, #0                       ' SetIdle() duration 0 = indefinite
00fc4     ff000010                 rdbyte  dpar2, ##mouse_intf_num
00fc8     fac787bb 
00fcc     ff000007                 mov     dres_handler, ##res_mouse_idle
00fd0     f6079bd8 
00fd4     fd900068                 jmp     #dset_idle
00fd8              res_mouse_idle
00fd8     fed00dfe                 loc     ptra, #@sz_setidle_result
00fdc     fdb0027c                 call    #dtx_result_to_con
00fe0     f20f86d2                 cmp     dpar2, #PID_ACK         wz
00fe4     5607b800         if_nz   mov     mouse_ep_addr, #0
00fe8     5d900024         if_nz   jmp     #conf_exit                      ' FIXME: should try to recover
00fec              mouse_timer
00fec     fed00f2b                 loc     ptra, #@sz_mouse_ready          ' DEBUG: to terminal with keyboard ready message
00ff0     fda00137                 call    #dtx_asciiz
00ff4     f20fb000                 cmp     kbd_ep_addr, #0         wz
00ff8     56038dc5         if_nz   mov     dct2, dct1                      ' Keyboard/mouse combo, so stagger poll intervals
00ffc     5f000271         if_nz   addct2  dct2, ##KBD_POLL_INTERVAL / 2
01000     5a6f8c00 
01004     ad638c1a         if_z    getct   dct2                            ' Mouse is the only connected device
01008     af0004e2         if_z    addct2  dct2, ##MOUSE_POLL_INTERVAL     ' Set first poll interval
0100c     aa6f8c00 
01010              conf_exit
01010     f607aa02                 mov     dtask, #DT_POLL_DATA
01014     fd800143                 jmp     #dtx_newline                    ' Make sure keyboard/mouse output starts on a new line
                   ' */
                   ' /* dset_protocol
                   '------------------------------------------------------------------------------
                   ' Post a ControlWrite() request to the host that will perform the HID-specific
                   ' SET_PROTOCOL function.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: protocol to set: 0 = Boot Protocol, 1 = Report Protocol.
                   '           Reg dpar2: index number of the interface to configure.
                   ' On exit:
                   '------------------------------------------------------------------------------
01018              dset_protocol
01018     ff800138                 waitx   ##_1ms * 2
0101c     fd66001f 
01020     fed01168                 loc     ptra, #@set_protocol
01024     fc578501                 wrword  dpar1, ptra[wValue]
01028     fc578702                 wrword  dpar2, ptra[wIndex]
0102c     f6079802                 mov     devent, #HCTRL_WRITE
01030     f60385d4                 mov     dpar1, ctrl_ep_addr
01034     f60387f8                 mov     dpar2, ptra                     ' SETUP struct addr
01038     f6078800                 mov     dpar3, #0                       ' SetProtocol() has no data stage
0103c     fd80001f                 jmp     #post_hevent                    ' Post ControlWrite() event
                   ' */
                   ' /* dset_idle
                   '------------------------------------------------------------------------------
                   ' Post a ControlWrite() request to the host that will perform the HID-specific
                   ' HID_SET_IDLE function.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
                   '           Reg dpar2: index number of the target interface.
                   ' On exit:
                   '------------------------------------------------------------------------------
01040              dset_idle
01040     ff800138                 waitx   ##_1ms * 2
01044     fd66001f 
01048     fed01148                 loc     ptra, #@set_idle
0104c     fc578501                 wrword  dpar1, ptra[wValue]
01050     fc578702                 wrword  dpar2, ptra[wIndex]
01054     f6079802                 mov     devent, #HCTRL_WRITE
01058     f60385d4                 mov     dpar1, ctrl_ep_addr
0105c     f60387f8                 mov     dpar2, ptra                     ' SETUP struct addr
01060     f6078800                 mov     dpar3, #0                       ' SetIdle() has no data stage
01064     fd80001f                 jmp     #post_hevent                    ' Post ControlWrite() event
                   ' */
                   ' /* dset_kbd_report
                   '------------------------------------------------------------------------------
                   ' Post a ControlWrite() request to the host that will perform the HID-specific
                   ' HID_SET_REPORT function to set keyboard CapsLk, ScrLk and NumLk indicators.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
01068              dset_kbdled_report
01068     fed01130                 loc     ptra, #@set_report
0106c     ff000010                 rdbyte  dtmp, ##kbd_intf_num
01070     fac797a4 
01074     ff800001                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
01078     fc5c0101 
0107c     fc579702                 wrword  dtmp, ptra[wIndex]
01080     fc5c0303                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
01084     f6079802                 mov     devent, #HCTRL_WRITE
01088     f60385d4                 mov     dpar1, ctrl_ep_addr
0108c     f60387f8                 mov     dpar2, ptra                     ' SETUP struct addr
01090     ff000010                 mov     dpar3, ##kbd_led_states         ' Start address of OUT data
01094     f60789a9 
01098     fd80001f                 jmp     #post_hevent                    ' Post ControlWrite(SET_REPORT) event
                   ' */
                   ' /* kbd_compare
                   '------------------------------------------------------------------------------
                   ' Compare current and previous keyboard data buffers for keypress changes.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg dpar1: keycode of the last key in the down state, otherwise
                   '           zero (KEY_NO_KEY) if no keys were in the down state.
                   '           Reg dpar2: the current (possibly changed) modifier key states.
                   '------------------------------------------------------------------------------
0109c              kbd_compare
0109c     f6078800                 mov     dpar3, #KEY_NO_KEY
010a0     fef01108                 loc     ptrb, #@kbd_cur_report + 2      ' Start of keycode array
010a4     fac785e1                 rdbyte  dpar1, ptrb++                   ' First array byte tells us if no keys down or keyboard error
010a8     f21f8403                 cmp     dpar1, #KEY_ERR_UNDEF   wcz     ' First four key values in lookup table are "special" keycodes
010ac     1d900014         if_a    jmp     #.get_keys                      ' Process normal keycode
010b0     f20f8400                 cmp     dpar1, #KEY_NO_KEY      wz
010b4     ad900038         if_z    jmp     #.end_keys                      ' No key activity or key up event, so commit current to previous
010b8     fed010f6                 loc     ptra, #@kbd_prev_report         ' Keyboard rollover overflow or other error
010bc     f6079c08                 mov     drep, #KBD_IN_RPT_LEN           ' This data can't be used for compare purposes in the future
010c0     fd900140                 jmp     #dmemcpy                        ' So make the previous data the current data and return to caller
                   ' Walk the keycode array looking for pressed keys
010c4              .get_keys
010c4     ff000010                 rdbyte  dr0, ##kbd_max_index
010c8     fac77da8 
010cc     f60383be                 mov     dr3, dr0
010d0     ff000010                 add     dr3, ##kbd_cur_report           ' Last keycode array element
010d4     f10783aa 
010d8              .next_key
010d8     f20f8400                 cmp     dpar1, #KEY_NO_KEY      wz
010dc     ad900010         if_z    jmp     #.end_keys                      ' No more pressed keys in the current report
010e0     fdb0003c                 call    #check_key                      ' Process this keycode
010e4     f20bf3c1                 cmp     ptrb, dr3               wz      ' Check for array end
010e8     5ac785e1         if_nz   rdbyte  dpar1, ptrb++
010ec     5d9fffe8         if_nz   jmp     #.next_key
010f0              .end_keys
010f0     ff000010                 rdbyte  dtmp, ##kbd_last_key
010f4     fac797ba 
010f8     f20b89cb                 cmp     dpar3, dtmp             wz
010fc     5f000000         if_nz   mov     kbd_repeat, ##KBD_REPEAT_DELAY  ' Key down event was a different key than last,
01100     5607b63e 
01104     5607b400         if_nz   mov     kbd_poll_cnt, #0                ' so reset auto-repeat
01108     5f000010         if_nz   wrbyte  dpar3, ##kbd_last_key
0110c     5c4789ba 
01110              .end
01110     fed01096                 loc     ptra, #@kbd_cur_report          ' Done processing current IN report
01114     fef0109a                 loc     ptrb, #@kbd_prev_report
01118     f6079c08                 mov     drep, #KBD_IN_RPT_LEN
0111c     fd9000e4                 jmp     #dmemcpy                        ' So it becomes the previous report for future compare
                   ' */
                   ' /* check_key (boot protocol specific)
                   '------------------------------------------------------------------------------
                   ' See if the given keycode exists in the previously read keyboard data. If
                   ' found it means the key is still pressed and can be ignored. If not found it's
                   ' a new keypress to process.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: keycode to check.
                   '           Reg dpar2: current CapsLock, NumLock and ScrollLock bitflags.
                   ' On exit:  Reg dpar1: input keycode if matched (still in the down state).
                   '           otherwise the input keycode (new keypress).
                   '           Reg dpar2: possibly modified toggle key state
                   '           Reg dpar3: keycode of the last key found in the down state
                   '------------------------------------------------------------------------------
01120              check_key
01120     fed01090                 loc     ptra, #@kbd_prev_report + 2
01124     ff000010                 mov     dr1, ##kbd_prev_report
01128     f6077fb2 
0112c     f1037fbe                 add     dr1, dr0                        ' Last keycode array element
01130              .loop
01130     fac79761                 rdbyte  dtmp, ptra++
01134     f20b97c2                 cmp     dtmp, dpar1             wz
01138     a60389c2         if_z    mov     dpar3, dpar1
0113c     ad64002d         if_z    ret                                     ' Key still in down state, so done with this key
01140     f20bf1bf                 cmp     ptra, dr1               wz
01144     5d9fffe8         if_nz   jmp     #.loop
                   ' The previous key report has been searched and no match found, so this is a
                   ' newly-pressed key. Check first for a toggle key.
01148     f60397e6                 mov     dtmp, dkbd_ledstates
0114c     f20f8439                 cmp     dpar1, #KEY_CAPSLK      wz
01150     a4e79601         if_z    bitnot  dtmp, #LED_CAPSLKB
01154     f20f8447                 cmp     dpar1, #KEY_SCRLK       wz
01158     a4e79602         if_z    bitnot  dtmp, #LED_SCRLKB
0115c     f20f8453                 cmp     dpar1, #KEY_NUMLK       wz
01160     a4e79600         if_z    bitnot  dtmp, #LED_NUMLKB
01164     f20b97e6                 cmp     dtmp, dkbd_ledstates    wz
01168     5603cdcb         if_nz   mov     dkbd_ledstates, dtmp
0116c     56078800         if_nz   mov     dpar3, #KEY_NO_KEY              ' Toggle key pressed cancels auto-repeat
01170     5d64002d         if_nz   ret                                     ' Done if toggle key processed
                   ' Fall through to sendkey with new keypress
                   ' vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
                   ' */
                   ' /* sendkey
                   '------------------------------------------------------------------------------
                   ' Process a newly-pressed key using the keycode table in LUT.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: the keycode to send to the terminal.
                   ' On exit:
                   '------------------------------------------------------------------------------
01174              sendkey
01174     f60389c2                 mov     dpar3, dpar1                    ' Save keycode for repeat evaluation
                   '                mov     dtmp, #LSHARE_TOP
                   '                add     dtmp, dpar1
                   '                rdlut   dpar2, dtmp                     ' Lookup ASCII character pair (byte1 shifted, byte0 un-shifted)
01178     faa387c2                 rdlut   dpar2, dpar1                    ' Lookup ASCII character pair (byte1 shifted, byte0 un-shifted)
0117c     ff000010                 rdbyte  dtmp, ##kbd_cur_report          ' Key array zero is shift/alt/ctrl/gui modifier bits
01180     fac797aa 
01184     f417cc01                 testb   dkbd_ledstates, #LED_CAPSLKB wc
01188     3d900018         if_nc   jmp     #.chk_shift                     ' CapsLock not active, so we can evaluate shift now
                   ' Active CapsLock key only affects the alpha keys
                   ' FIXME: Ctrl/Alt keys not handled
0118c     f21f841d                 cmp     dpar1, #KEY_Z_z         wcz     ' The first valid keycode is KEY_A_a
01190     1d900010         if_a    jmp     #.chk_shift                     ' So if it's above KEY_Z_z it's not an alpha key
01194     f7cf9622                 test    dtmp, #KEY_SHIFT        wz
01198     58e395c3         if_nz   getbyte dtx, dpar2, #0                  ' CapsLock AND Shift is lowercase alpha
0119c     a8eb95c3         if_z    getbyte dtx, dpar2, #1
011a0     fd90000c                 jmp     #.out_key
011a4              .chk_shift
011a4     f7cf9622                 test    dtmp, #KEY_SHIFT        wz      ' Determine upper/lower case keycode to send
011a8     a8e395c3         if_z    getbyte dtx, dpar2, #0
011ac     58eb95c3         if_nz   getbyte dtx, dpar2, #1
011b0              .out_key
                   ' Publish the updated keyboard keypress and modifier flags to the public interface in hub RAM
011b0     f603c9ca                 mov     dkbd_keypress, dtx
011b4     f107c601                 add     dkbd_count, #1
011b8     fd640628                 setq    #4 - 1                          ' Two cog registers in fast block write
011bc     ff000003                 wrlong  dkbd_count,##@kbd_count
011c0     fc67c7f0 
011c4     fd80013b                 jmp     #dtx_char
                   ' */
                   ' /* mouse_compare
                   '------------------------------------------------------------------------------
                   ' Compare current and previous mouse data buffers for changes.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg drep: zero if a change was detected.
                   '------------------------------------------------------------------------------
011c8              mouse_compare
011c8     fed00ff3                 loc     ptra, #@mouse_cur_report
011cc     fef00ff7                 loc     ptrb, #@mouse_prev_report
011d0     f6079c00                 mov     drep, #0
011d4              .loop
011d4     fac77d61                 rdbyte  dr0, ptra++
011d8     fac77fe1                 rdbyte  dr1, ptrb++
011dc     f20b7dbf                 cmp     dr0, dr1                wz
011e0     5d900010         if_nz   jmp     #.change
011e4     f1079c01                 add     drep, #1
011e8     f20f9c08                 cmp     drep, #MOUSE_RPT_LEN    wz
011ec     ad64002d         if_z    ret                                     ' No changes detected
011f0     fd9fffe0                 jmp     #.loop
011f4              .change
011f4     fed00fc7                 loc     ptra, #@mouse_cur_report
011f8     fef00fcb                 loc     ptrb, #@mouse_prev_report
011fc     f6079c08                 mov     drep, #MOUSE_RPT_LEN
01200     fd900000                 jmp     #dmemcpy
                   ' */
                   ' /* dmemcpy
                   '------------------------------------------------------------------------------
                   ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: source address.
                   '           Reg PTRB: destination address.
                   '           Reg drep: length of copy, in bytes.
                   ' On exit:
                   '------------------------------------------------------------------------------
01204              dmemcpy
01204     fac79761                 rdbyte  dtmp, ptra++
01208     fc4797e1                 wrbyte  dtmp, ptrb++
0120c     fb6f9dfd                 djnz    drep, #dmemcpy
01210     fd64002d                 ret
                   ' */
                   ' /* htx_hexdump
                   '------------------------------------------------------------------------------
                   ' Serial output of raw data in hexadecimal byte format.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: start address of data header string.
                   '           Reg PB: start address of the data blob.
                   '           Reg dr0: count of data bytes to output.
                   ' On exit:
                   '------------------------------------------------------------------------------
01214              htx_hexdump
01214     faa7eff9                 rdlut   pb, #D_PAR1
01218     faa77dfa                 rdlut   dr0, #D_PAR2
0121c              dtx_unknown
0121c     fed00a7d                 loc     ptra, #@sz_unknown_data
01220              dtx_raw_data
01220     fda00137                 call    #dtx_asciiz
01224     f6077e10                 mov     dr1, #16                        ' Column count
01228              .loop
01228     f20f7e10                 cmp     dr1, #16                wz
0122c     a6077e00         if_z    mov     dr1, #0
01230     ada00143         if_z    call    #dtx_newline
                   ' At 3MBaud on PST some data was getting dropped, so delay between rows
01234     af80004e         if_z    waitx   ##_1us * 500
01238     ad64801f 
0123c     f6079420                 mov     dtx, #" "
01240     fda0013b                 call    #dtx_char
01244     fac395f7                 rdbyte  dtx, pb
01248     f107ee01                 add     pb, #1
0124c     fda0017a                 call    #dtx_hexbyte
01250     f1077e01                 add     dr1, #1
01254     fb6f7df4                 djnz    dr0, #.loop
01258     fd64002d                 ret
                   {
                   .offset_header
                                   call    #dtx_newline
                                   mov     dtx, #" "
                                   call    #dtx_char
                                   mov     dtx, dpar3
                                   bith    dtxopts, #PREPEND_0XB
                                   call    #dtx_hexword
                                   bitl    dtxopts, #PREPEND_0XB
                                   add     dpar3, #16                      ' Next row offset
                                   mov     dpar2, #0                       ' Reset column count
                                   mov     dtx, #" "
                                   mov     drep, #2
                                   jmp     #dtx_rptchar
                   }
                   ' */
                   ' /* dtx_result_to_con
                   '------------------------------------------------------------------------------
                   ' Output detailed transaction results to the terminal. If reg dtxopts has the
                   ' TX_VERBOSEB bitflag cleared, transactions with an ACK result will not be
                   ' output.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: address of the zero-terminated string that describes the
                   '           transaction, zero if no string defined.
                   '           Reg dpar2: return code for the transaction.
                   '           Reg dpar3: If not ERR_NONE, a contextual error code.
                   ' On exit:  Reg dpar2: unchanged.
                   '           Reg dpar3: unchanged.
                   '------------------------------------------------------------------------------
0125c              dtx_result_to_con
0125c     fd7c006f                 modcz   _clr, _clr              wcz     ' Ensure both C and Z clear before tests
01260     f4179004                 testb   dtxopts, #TX_VERBOSEB   wc      ' Suppress ACK/ERR_NONE/ERR_ACK_RETRY when not verbose
01264     320f86d2         if_nc   cmp     dpar2, #PID_ACK         wz
01268     120f8600   if_nc_and_nz  cmp     dpar2, #ERR_NONE        wz
0126c     120f8608   if_nc_and_nz  cmp     dpar2, #ERR_ACK_RETRY   wz
01270     2d64002d   if_nc_and_z   ret
01274              dtx_result_code
01274     f20ff000                 cmp     ptra, #0                wz
01278     aed00a99         if_z    loc     ptra, #@sz_generic_result
0127c     fda00137                 call    #dtx_asciiz
01280     f21f860b                 cmp     dpar2, #ERR_END         wcz
01284     cd900034         if_b    jmp     #.extended_code                 ' The error has bus and transfer/transaction context
                   '------------------------------------------------------------------------------
                   ' Fetch a pointer to the text string for a USB response PID.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar2: USB response PID type.
                   '------------------------------------------------------------------------------
01288              .code_text
01288     f607f000                 mov     ptra, #0
0128c     f20f86d2                 cmp     dpar2, #PID_ACK         wz      ' Get text equivalent of USB result PID
01290     aed00bfe         if_z    loc     ptra, #@sz_ack
01294     f20f865a                 cmp     dpar2, #PID_NAK         wz
01298     aed00bfa         if_z    loc     ptra, #@sz_nak
0129c     f20f861e                 cmp     dpar2, #PID_STALL       wz
012a0     aed00bf6         if_z    loc     ptra, #@sz_stall
012a4     f20ff000                 cmp     ptra, #0                wz
012a8     5d800137         if_nz   jmp     #dtx_asciiz                     ' If known PID response, output text and back to caller
012ac              .hex
012ac     f60395c3                 mov     dtx, dpar2                      ' Output the USB result as a hex value
012b0     f4279001                 bith    dtxopts, #PREPEND_0XB
012b4     fda0017e                 call    #dtx_hexlong
012b8     04079001         _ret_   bitl    dtxopts, #PREPEND_0XB
012bc              .extended_code
012bc     fd63862a                 push    dpar2                           ' Transfer/transaction context is a pointer offset to an error description string
012c0     f60387c4                 mov     dpar2, dpar3                    ' Reg dpar3 has the USB error code encountered within the transfer/transaction
012c4     fdbfffc0                 call    #.code_text                     ' Output USB error as text
012c8     fed00bd4                 loc     ptra, #@sz_list_break
012cc     fda00137                 call    #dtx_asciiz
012d0     fd63f02b                 pop     ptra                            ' Retrieve saved transfer/transaction context pointer offset
012d4     f067f002                 shl     ptra, #2                        ' Table offset in longs
012d8     ff000010                 add     ptra, ##err_code_text
012dc     f107f140 
012e0     fb07f100                 rdlong  ptra, ptra
012e4     fd800137                 jmp     #dtx_asciiz                     ' Concatenate transfer/transaction result text and back to caller
                   ' */
                   ' /* dtx_txn_result
                   '------------------------------------------------------------------------------
                   ' Raw data for transaction results posted by the host.
                   '------------------------------------------------------------------------------
012e8              dtx_txn_result
012e8     f4279000                 bith    dtxopts, #APPEND_CRB
012ec     fda00143                 call    #dtx_newline
012f0     f60395c2                 mov     dtx, dpar1
012f4     fda0017e                 call    #dtx_hexlong
012f8     f60395c3                 mov     dtx, dpar2
012fc     fda0017e                 call    #dtx_hexlong
01300     f60395c4                 mov     dtx, dpar3
01304     fda0017e                 call    #dtx_hexlong
01308     04079000         _ret_   bitl    dtxopts, #APPEND_CRB
                   ' */
                   ' /* htx_dbg_data
                   '------------------------------------------------------------------------------
                   ' Output a single host debug value to the terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar2: whatever the host put there.
                   ' On exit:
                   '------------------------------------------------------------------------------
0130c              htx_dbg_data
0130c     fed00c72                 loc     ptra, #@sz_dbg_data
01310     f60387c2                 mov     dpar2, dpar1                    ' FIXME: need consistent parameter types
01314     fd9fff5c                 jmp     #dtx_result_code                ' Debug data overrides OPT_VERBOSE setting
                   ' */
                   ' /* htx_break
                   '------------------------------------------------------------------------------
                   ' Output host breakpoint info and debug value. The host halts after posting
                   ' this request, so the driver does too.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: whatever the host put there.
                   ' On exit:
                   '------------------------------------------------------------------------------
01318              htx_break
01318     fed00c74                 loc     ptra, #@sz_breakh
0131c     fda00137                 call    #dtx_asciiz
01320     f60395c2                 mov     dtx, dpar1
01324     fda0017e                 call    #dtx_hexlong
01328     fed00c3f                 loc     ptra, #@sz_host_stopped         ' Host halts
0132c     fda00143                 call    #dtx_newline
01330     fda00137                 call    #dtx_asciiz
01334     fd9ffffc .halt           jmp     #.halt                          ' Driver halts
                   ' */
                   ' /* init_kdb_data
                   '------------------------------------------------------------------------------
                   ' Initialize the keyboard/mouse data area to start-up values.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
01338              init_kbd_data
01338     f607b000                 mov     kbd_ep_addr, #0
0133c     f607b800                 mov     mouse_ep_addr, #0
01340     ff000010                 mov     pa, ##kbd_mouse_start
01344     f607eda4 
01348              .loop
01348     fc4801f6                 wrbyte  #0, pa
0134c     f107ec01                 add     pa, #1
01350     ff000010                 cmp     pa, ##kbd_mouse_end     wz
01354     f20fedcf 
01358     5d9fffec         if_nz   jmp     #.loop
0135c     ff000010                 wrbyte  #PID_DATA0, ##kbd_next_datax    ' Reset interrupt IN datax sequence
01360     fc4d87a7 
01364     ff000010         _ret_   wrbyte  #PID_DATA0, ##mouse_next_datax
01368     0c4d87be 
                   ' */
                   ' /* serial_init
                   '------------------------------------------------------------------------------
                   ' Initialize smart pins for asynchronout serial I/O.
                   '------------------------------------------------------------------------------
0136c              serial_init
0136c     fc0cf83e                 wrpin   #%1_11110_0, #TX                ' Initialize the asynchronous serial smart pin
                   '                wxpin   ##_115_200_8b, #TX
                   '                wxpin   ##_1M_8b, #TX
                   '                wxpin   ##_1_5M_8b, #TX
01370     ff801400                 wxpin   ##_2M_8b, #TX
01374     fc1c0e3e 
                   '                wxpin   ##_3M_8b, #TX
01378     fd647c41                 dirh    #TX                             ' Enable serial tx
0137c     ff800001                 waitx   ##1000
01380     fd67d01f 
01384     fc2c203e                 wypin   #CLS, #TX                       ' Prime the async buffer by outputting the PST clear screen byte
01388     fed007d7                 loc     ptra, #@dcog_started
0138c     fd800137                 jmp     #dtx_asciiz
                   ' */
                   {
                   ' /* htx_retstat
                   '------------------------------------------------------------------------------
                   ' Output USB host receiver status word (data:flags) plus one debug value.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: rx status word.
                   '           Reg dpar2: optional arbitrary debug value.
                   ' On exit:
                   '------------------------------------------------------------------------------
                   htx_retstat
                                   mov     drep, #12                       ' Format the output
                                   mov     dtx, #" "
                                   call    #dtx_rptchar
                                   loc     ptra, #@sz_stathdr
                                   call    #dtx_asciiz
                                   loc     ptra, #@sz_stat
                                   call    #dtx_asciiz
                                   mov     dtx, dpar1                      ' Fetch the USB rx status word
                                   push    dtx
                                   mov     drep, #8
                                   call    #dtx_bin                        ' Output USB rx status bits
                                   mov     drep, #2
                                   mov     dtx, #" "
                                   call    #dtx_rptchar
                                   mov     dtx, #"$"
                                   call    #dtx_char
                                   pop     dtx
                                   shr     dtx, #8
                                   call    #dtx_hexbyte                    ' Output USB rx data byte
                                   call    #dtx_newline
                                   loc     ptra, #@sz_ret
                                   call    #dtx_asciiz
                                   mov     dtx, dpar2                      ' Fetch the debug data
                                   call    #dtx_hexlong
                                   call    #dtx_newline
                                   ret
                   ' */
                   }
                   ' /* dpulse_led
                   '------------------------------------------------------------------------------
                   ' Blink Prop123-A9 LED12 while the driver is in the disconnected/idle state.
                   '------------------------------------------------------------------------------
01390              dpulse_led
01390     fd64585f                 drvnot  #DRIVER_WAIT_LED
01394     fd638e1a                 getct   dct3
01398     ff01312d         _ret_   addct3  dct3, ##PULSE_TIME
0139c     0a778e00 
                   ' */
                   ' #endregion DAT (Class Driver HubExec)
                   ' #region CON (Class Driver)
                   con
                   '------------------------------------------------------------------------------
                   ' Serial I/O, if required, is part of the class driver. Default output text
                   ' newline behavior is that every carriage return (CR) code encountered implies
                   ' that a line feed character will follow.
                   ' NOTE: The Parallax Serial Terminal (PST) treats the carriage return character
                   ' as newline. In the Preferences->Functions Tab you can deselect the Line Feed
                   ' character to prevent the double spacing of output text lines.
                   '------------------------------------------------------------------------------
                           _3M_8b       = round(SYSCLOCK / 3_000_000.0 * 65536.0) & $fffffc00 | 7
                           _2M_8b       = round(SYSCLOCK / 2_000_000.0 * 65536.0) & $fffffc00 | 7
                           _1_5M_8b     = round(SYSCLOCK / 1_500_000.0 * 65536.0) & $fffffc00 | 7
                           _1M_8b       = round(SYSCLOCK / 1_000_000.0 * 65536.0) & $fffffc00 | 7
                           _115_200_8b  = round(SYSCLOCK / 115_200.0 * 65536.0) & $fffffc00 | 7
                           TX           = 62                       ' Standard P2 tx/rx pins
                           RX           = 63
                   ' ASCII control codes.
                           BELL  = $07
                           BSP   = $08
                           TAB   = $09
                           LF    = $0a
                           CR    = $0d                             ' PST: single CR is newline
                           GOTOX = $0e                             ' PST: position cursor to column X
                           GOTOY = $0f                             ' PST: position cursor to row Y
                           CLS   = $10                             ' PST: clear screen cmd
                           ESC   = $1b
                           USE_GOTOX = 1   ' If non-zero use the PST GOTOX cursor positioning function to update
                                           ' mouse position data without line scrolling, otherwise a carriage
                                           ' return without a line feed will be transmitted.
                   '------------------------------------------------------------------------------
                   ' Serial text output option bit positions:
                   '------------------------------------------------------------------------------
                           #0, APPEND_CRB, PREPEND_0XB, IN_PARENSB, UNI_TXTB, TX_VERBOSEB, MSCROLLB
                   ' Option bitflags (active high):
                           APPEND_CRF   = |< APPEND_CRB            ' Value->text append CR char
                           PREPEND_0XF  = |< PREPEND_0XB           ' Prepend "0x" to hexadecimal output, "0b" to binary output
                           IN_PARENSF   = |< IN_PARENSB            ' Enclose the value in parentheses
                           UNI_TXTF     = |< UNI_TXTB              ' Unicode text word
                           TX_VERBOSEF  = |< TX_VERBOSEB           ' Parse connected device descriptor and config descriptor chain
                           MSCROLLF     = |< MSCROLLB              ' Enable line scrolling of mouse button states and X/Y direction/velocity
                   ' Pushbutton option startup defaults:
                           OPT_VERBOSE = TX_VERBOSEF               ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
                   '        OPT_VERBOSE = 0                         ' Set to TX_VERBOSEF for verbose output to the terminal, zero for off
                   '        OPT_MSCROLL = MSCROLLF                  ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
                           OPT_MSCROLL = 0                         ' Set to MSCROLLF to scroll mouse button & X/Y data, zero to inhibit scrolling
                   '------------------------------------------------------------------------------
                   ' USB HID keyboard and/or mouse class driver using the boot protocol.
                   ' Constants specific to the HID Class driver:
                   '------------------------------------------------------------------------------
                   ' A task progression list that is specific to this type of class driver. When
                   ' the host cog enumerates a device, the class driver is notified when the
                   ' Device Descriptor and the Configuration Descriptor have been read, always in
                   ' that order. After both notifications have been received, the class driver
                   ' must define the tasks that will parse the descriptor(s) to determine if the
                   ' device is compatible with the class driver. If not, the host should be
                   ' notified that the device is "unknown" FIXME: unknown not yet handled.
                   '
                   ' If the device is compatible, the task list is used as a way for the class
                   ' driver to do what is necessary to configure the device for its intended
                   ' function. Each task routine in the list is responsible for setting the task
                   ' that follows it, if there is one. The final task in the list is typically
                   ' akin to a "main" processing routine that calls other routines which post the
                   ' relevant USB transactions needed to implement the device's functions. This
                   ' task runs until the host cog notifies the class driver that the device has
                   ' been reset or disconnected.
                   '------------------------------------------------------------------------------
                           #0, DT_IDLE, DT_SET_CONF, DT_POLL_DATA
                   ' Mark end of task list.
                           DT_END = DT_POLL_DATA
                   '------------------------------------------------------------------------------
                   ' Keyboard interrupt endpoint poll interval and auto-repeat timing. Since the
                   ' interrupt IN transactions are executed on a timed basis, use that to
                   ' calculate auto-repeat initial delay and repeat rate.
                   '------------------------------------------------------------------------------
                           KBD_POLL_INTERVAL = _1ms * 8            ' Interrupt IN txn timespan
                           KBD_REPEAT_DELAY  = 62                  ' 62 * 8ms = 496ms initial delay
                           KBD_REPEAT_RATE   = 5                   ' 5 * 8ms = 40ms repeat rate
                   '------------------------------------------------------------------------------
                   ' Mouse interrupt endpoint poll interval:
                   '------------------------------------------------------------------------------
                           MOUSE_POLL_INTERVAL = _1ms * 8          ' Interrupt IN txn timespan
                           MOUSE_NAK_DELAY     = 62                ' USER_LED feedback blink delay uses the NAK count
                   ' #endregion CON (Class Driver)
                   ' #region DAT (Class Driver Cog)
                   dat
013a0                              orgh
013a0                              alignl
013a0 000                          org
                   ' /* hid_driver
                   '------------------------------------------------------------------------------
                   ' The USB HID driver cog.
                   '------------------------------------------------------------------------------
013a0 000          hid_driver
013a0 000 fd644659                 drvh    #LED3                           ' DEBUG
013a4 001 ff8bebc2                 waitx   ##_1ms * 5000                   ' Delay to allow time to get the serial terminal ready to receive
013a8 002 fd64001f 
013ac 003 fd644650                 fltl    #LED3                           ' DEBUG
013b0 004 fda0136c                 call    #serial_init                    ' Init serial output and send startup splash text to terminal
013b4 005 fdb006c0                 call    #load_kbd_lut                   ' Copy keyboard conversion table to LUT
013b8 006 fc3c01fd                 wrlut   #D_READY, #D_EVENT              ' Reset shared LUT eventID
013bc 007 fd640237                 setluts #LSHARE_WRITE                   ' Allow host cog to write this LUT
013c0 008 fd641a20                 setse1  #D_EVENT_WR1FD                  ' Host write to LUT location D_EVENT triggers this event
013c4 009 fd647240                 dirl    #PB3
013c8 00a f6078410                 mov     dpar1, #OPT_VERBOSE             ' Default verbose terminal output option flag
013cc 00b f54391c2                 or      dtxopts, dpar1
013d0 00c f6078404                 mov     dpar1, #TX_VERBOSEB
013d4 00d fec01c52                 loc     ptra, #@sz_verbose_opt
013d8 00e fdb00104                 call    #dtx_opt_toggle
013dc 00f fd647040                 dirl    #PB2
013e0 010 f6078400                 mov     dpar1, #OPT_MSCROLL             ' Default mouse button and X/Y position/velocity scroll option flag
013e4 011 f54391c2                 or      dtxopts, dpar1
013e8 012 f6078405                 mov     dpar1, #MSCROLLB
013ec 013 fec01c70                 loc     ptra, #@sz_mscroll_opt
013f0 014 fdb000ec                 call    #dtx_opt_toggle
013f4 015 fda01390                 call    #dpulse_led
                   '------------------------------------------------------------------------------
013f8 016          hid_main
013f8 016 fd700624                 pollct3                         wc
013fc 017 cda01390         if_c    call    #dpulse_led
01400 018 fd700824                 pollse1                         wc
01404 019 cdb0002c         if_c    call    #do_devent                      ' The host cog has posted an event
01408 01a f20faa00                 cmp     dtask, #DT_IDLE         wz
0140c 01b 5db00074         if_nz   call    #do_task                        ' Process the current task
01410 01c f20fac00                 cmp     device_base, #0         wz
01414 01d adb00084         if_z    call    #check_buttons                  ' Option buttons only active when a device is not connected
01418 01e fd9fffdc                 jmp     #hid_main
                   ' */
                   ' /* post_hevent
                   '------------------------------------------------------------------------------
                   ' Post an eventID to the host cog.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg devent: eventID to post.
                   '           Regs dpar1, dpar2 and dpar3: required parameters, if any.
                   ' On exit:
                   '------------------------------------------------------------------------------
0141c 01f          post_hevent
0141c 01f faaf97fc                 rdlut   dtmp, #H_EVENT          wz      ' Wait for any pending host event to complete
01420 020 5d9ffff8         if_nz   jmp     #post_hevent
01424 021 fc3785f6                 wrlut   dpar1, #H_PAR1
01428 022 fc3787f7                 wrlut   dpar2, #H_PAR2
0142c 023 fc3789f8                 wrlut   dpar3, #H_PAR3
01430 024 0c3799fc         _ret_   wrlut   devent, #H_EVENT                ' This LUT location is a write event trigger
                   ' */
                   ' /* do_devent
                   '------------------------------------------------------------------------------
                   ' Handler jump table for events posted to the driver by the host cog.
                   '------------------------------------------------------------------------------
01434 025          do_devent
01434 025 faaf99fd                 rdlut   devent, #D_EVENT        wz
01438 026 ad64002d         if_z    ret                                     ' Zero is a nop
0143c 027 faa785f9                 rdlut   dpar1, #D_PAR1
01440 028 faa787fa                 rdlut   dpar2, #D_PAR2
01444 029 faa789fb                 rdlut   dpar3, #D_PAR3
01448 02a f327960a                 fle     dtmp, #D_END
0144c 02b fd64702a                 push    #devent_exit                    ' Event handlers return here
01450 02c fd639830                 jmprel  devent
01454 02d          devent_jmp
01454 02d fd64002d                 ret                                     ' EventID zero is a NOP
01458 02e fd900608                 jmp     #htx_asciiz                     ' Host requested string output to terminal
0145c 02f fd801318                 jmp     #htx_break                      ' Send host debug data to terminal, then halt
01460 030 fd80130c                 jmp     #htx_dbg_data                   ' Send host debug data to terminal
01464 031 fd801214                 jmp     #htx_hexdump                    ' Dump raw data to terminal
01468 032 fd9000b0                 jmp     #connect_info
0146c 033 fd9000e8                 jmp     #dev_disconnect
01470 034 fd800d00                 jmp     #parse_dev_desc                 ' Parse string data in the device descriptor
01474 035 fd800d14                 jmp     #parse_con_desc                 ' Parse config descriptor to determine if it's a known device class
01478 036 fd9003dc                 jmp     #get_dtxn_result                ' Get DTXN_RESULT event data and jump to IRP result handler routine
0147c 037 fd9003c0                 jmp     #get_dtxn_hresult               ' DTXN_HRESULT is a way for the host to route processing results directly to the terminal
01480 038          devent_exit
01480 038 0c3c01fd         _ret_   wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
                   ' */
                   ' /* do_task
                   '------------------------------------------------------------------------------
                   ' Handler jump table for tasks that this class driver understands. All jump
                   ' targets are implemented as CALL targets.
                   '------------------------------------------------------------------------------
01484 039          do_task
01484 039 f327aa02                 fle     dtask, #DT_END
01488 03a fd63aa30                 jmprel  dtask
0148c 03b          .dtask_jmp
0148c 03b fd64002d                 ret                                     ' TaskID zero is a NOP
01490 03c fd800e78                 jmp     #dset_config                    ' Configure (or not) a newly-connected device
01494 03d fd9000e0                 jmp     #dpoll_data                     ' Manage required data I/O for this class driver
01498 03e          dtask_idle
01498 03e 0607aa00         _ret_   mov     dtask, #DT_IDLE
                   ' */
                   ' /* check_buttons
                   '------------------------------------------------------------------------------
                   ' Prop123-A9 board pushbutton options.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
0149c 03f          check_buttons
0149c 03f fdb00054                 call    #scan_buttons
014a0 040 f20f7c00                 cmp     dr0, #0                 wz
014a4 041 ad64002d         if_z    ret                                     ' No button pressed
014a8 042 f20f7c39                 cmp     dr0, #PB3               wz
014ac 043 ad90000c         if_z    jmp     #.pb3
014b0 044          .pb2
014b0 044 fec01c70                 loc     ptra, #@sz_mscroll_opt
014b4 045 f6078405                 mov     dpar1, #MSCROLLB
014b8 046 fd900008                 jmp     #.exit
014bc 047          .pb3
014bc 047 fec01c52                 loc     ptra, #@sz_verbose_opt
014c0 048 f6078404                 mov     dpar1, #TX_VERBOSEB
014c4 049          .exit
014c4 049 f4e391c2                 bitnot  dtxopts, dpar1
014c8 04a fdb00014                 call    #dtx_opt_toggle
014cc 04b          .wait_up
014cc 04b fd737c40                 testp   dr0                     wc
014d0 04c 3d9ffff8         if_nc   jmp     #.wait_up                       ' Button still pressed (active low)
014d4 04d ff80009c                 waitx   ##_1ms
014d8 04e fd65001f 
014dc 04f 06077c00         _ret_   mov     dr0, #0
                   '------------------------------------------------------------------------------
                   ' Output a pushbutton description and on/off state to the serial terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg ptra: the address of the option description string.
                   '           Reg dpar1: the bitflag state of the option.
                   ' On exit:
                   '------------------------------------------------------------------------------
014e0 050          dtx_opt_toggle
014e0 050 fdb00398                 call    #dtx_asciiz
014e4 051 f41391c2                 testb   dtxopts, dpar1          wc
014e8 052 3ec01c8e         if_nc   loc     ptra, #@sz_off
014ec 053 cec01c93         if_c    loc     ptra, #@sz_on
014f0 054 fd900388                 jmp     #dtx_asciiz
                   ' */
                   ' /* scan_buttons
                   '------------------------------------------------------------------------------
                   ' Poll monitored buttons for pressed state (active low).
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg dr0: pin# of the pressed button, otherwise zero.
                   '------------------------------------------------------------------------------
014f4 055          scan_buttons
014f4 055 fec01b60                 loc     ptra, #@button_list
014f8 056          .next
014f8 056 facf7d61                 rdbyte  dr0, ptra++             wz
014fc 057 ad64002d         if_z    ret                                     ' No more buttons to check
01500 058 fd737c40                 testp   dr0                     wc
01504 059 cd9ffff0         if_c    jmp     #.next                          ' Not pressed
01508 05a ff80061a                 waitx   ##_1ms * 10                     ' Debounce press
0150c 05b fd66001f 
01510 05c fd737c40                 testp   dr0                     wc
01514 05d cd60ac2c         if_c    jmp     .next                           ' No longer pressed, so treat as false press and test next button
01518 05e fd64002d                 ret                                     ' Process the pressed button
                   ' */
                   ' /* connect_info
                   '------------------------------------------------------------------------------
                   ' Host notification that a device has connected. Initialize whatever is
                   ' required prior to configuring the device.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg devent: eventID.
                   '           Reg dpar1: speed of the connected device.
                   ' On exit:
                   '------------------------------------------------------------------------------
0151c 05f          connect_info
0151c 05f fd645859                 drvh    #DRIVER_WAIT_LED                ' DEBUG: show that the driver sees the device connect
01520 060 f20f8401                 cmp     dpar1, #USB_SPEED_LOW   wz
01524 061 aec01cc5         if_z    loc     ptra, #@sz_lowspeed
01528 062 5ec01ca5         if_nz   loc     ptra, #@sz_fullspeed
0152c 063 fdb0034c                 call    #dtx_asciiz
01530 064 f607edd5                 mov     pa, #dreg_init_start            ' First cog register address of consecutive
01534 065          .loop                                                   ' registers to reset to zero
01534 065 f98fec00                 altd    pa                              ' Use pointer-based register indirection
01538 066 f6040000                 mov     0-0, #0                         ' Reset register content to zero
0153c 067 f107ec01                 add     pa, #1
01540 068 f20fede7                 cmp     pa, #dreg_init_end      wz
01544 069 5d9fffec         if_nz   jmp     #.loop                          ' Until end of register block reached
                   ' Reset the USB mouse/keyboard interface in hub RAM
01548 06a fd640e28                 setq    #8 - 1                          ' Interface is 4 mouse and 4 keyboard longs
0154c 06b ff000003                 wrlong  dmouse_count, ##@mouse_count    ' Use registers reset in above loop for cog->hub block write
01550 06c fc67bfe0 
01554 06d fd64002d                 ret
                   ' */
                   ' /* dev_disconnect
                   '------------------------------------------------------------------------------
                   ' Host notification that a device was reset or has disconnected.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
01558 06e          dev_disconnect
01558 06e fda01390                 call    #dpulse_led                     ' DEBUG: show that the driver sees the device disconnect
0155c 06f fd645a50                 fltl    #DRIVER_MOUSE_LED
01560 070 fd645c50                 fltl    #DRIVER_KBD_LED
01564 071 fc3c01fd                 wrlut   #D_READY, #D_EVENT              ' Reset shared LUT eventID
01568 072 f607aa00                 mov     dtask, #DT_IDLE                 ' Disconnect means nothing to do
0156c 073 f607ac00                 mov     device_base, #0                 ' Invalidate current device
01570 074 fec01ce4                 loc     ptra, #@sz_disconnect
01574 075 fd900304                 jmp     #dtx_asciiz                     ' Send disconnect message to the terminal
                   ' */
                   ' /* dpoll_data
                   '------------------------------------------------------------------------------
                   ' Post interrupt IN transactions at configured intervals.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
01578 076          dpoll_data
01578 076 f20fb000                 cmp     kbd_ep_addr, #0         wz
0157c 077 ad900014         if_z    jmp     #.mouse                         ' No keyboard connected
01580 078 fbcc2204                 jnct1   #.mouse                         ' Nothing to do yet
01584 079 fd638a1a                 getct   dct1
01588 07a ff0004e2                 addct1  dct1, ##KBD_POLL_INTERVAL       ' Set the timer for next poll interval
0158c 07b fa678a00 
01590 07c fd900030                 jmp     #dget_kbd_in_report             ' Post IN txn and return to caller
01594 07d          .mouse
01594 07d f20fb800                 cmp     mouse_ep_addr, #0       wz
01598 07e ad64002d         if_z    ret                                     ' No mouse connected
0159c 07f fd700424                 pollct2                         wc
015a0 080 3d64002d         if_nc   ret                                     ' Nothing to do
015a4 081 f20fb000                 cmp     kbd_ep_addr, #0         wz
015a8 082 56038dc5         if_nz   mov     dct2, dct1                      ' Keyboard/mouse combo, so stagger poll intervals
015ac 083 5f000271         if_nz   addct2  dct2, ##_1ms * 4                ' Try to keep 4ms timespan between them
015b0 084 5a6f8c00 
015b4 085 ad638c1a         if_z    getct   dct2
015b8 086 af0004e2         if_z    addct2  dct2, ##MOUSE_POLL_INTERVAL     ' Mouse is the only connected device
015bc 087 aa6f8c00 
015c0 088 fd900118                 jmp     #dget_mouse_in_report           ' Post IN txn and return to caller
                   ' */
                   ' /* dget_kbd_in_report
                   '------------------------------------------------------------------------------
                   ' Post an IN interrupt request to the host to poll for keyboard activity.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
015c4 089          dget_kbd_in_report
015c4 089 f607aa00                 mov     dtask, #DT_IDLE
015c8 08a f6079803                 mov     devent, #HINT_IN
015cc 08b f60385d8                 mov     dpar1, kbd_ep_addr
015d0 08c ff000010                 mov     dpar2, ##kbd_cur_report
015d4 08d f60787aa 
015d8 08e ff000010                 rdbyte  dtmp, ##kbd_in_max_pkt          ' Always ask for max report size
015dc 08f fac797a6 
015e0 090 ff000010                 rdbyte  dpar3, ##kbd_next_datax
015e4 091 fac789a7 
015e8 092 f92b89cb                 setword dpar3, dtmp, #1                 ' Max IN packet size to expect
015ec 093 ff000000                 mov     dres_handler, ##res_kbd_in
015f0 094 f6079a96 
015f4 095 fd9ffe24                 jmp     #post_hevent
015f8 096          res_kbd_in
                   ' DEBUG: rarely, a zero-length packet shows up with ACK, which shouldn't happen.
                   ' I don't yet know why, but the short term fix is to just ignore it...
015f8 096 f603b1c2                 mov     kbd_ep_addr, dpar1              ' Get address with calculated CRC
015fc 097 f20f8800                 cmp     dpar3, #0               wz
01600 098 a20f86d2         if_z    cmp     dpar2, #PID_ACK         wz
01604 099 5d900004         if_nz   jmp     #.do_in
01608 09a 0607aa02         _ret_   mov     dtask, #DT_POLL_DATA
                   '                mov     dtask, #DT_POLL_DATA            ' DEBUG
                   '                jmp     #dtx_txn_result                 ' DEBUG
0160c 09b          .do_in
0160c 09b f20f86d2                 cmp     dpar2, #PID_ACK         wz
01610 09c ad90005c         if_z    jmp     #.data
01614 09d f20f865a                 cmp     dpar2, #PID_NAK         wz
01618 09e ad900008         if_z    jmp     #.nak
0161c 09f fec01de7                 loc     ptra, #@sz_intin_result
01620 0a0 fd80125c                 jmp     #dtx_result_to_con              ' Something other than ACK/NAK, so likely fatal
                   ' The NAK count is used to determine when key auto-repeat kicks in.
01624 0a1          .nak
01624 0a1 f607aa02                 mov     dtask, #DT_POLL_DATA
01628 0a2 f107b401                 add     kbd_poll_cnt, #1
0162c 0a3 f21bb5db                 cmp     kbd_poll_cnt, kbd_repeat wcz
01630 0a4 cd64002d         if_b    ret                                     ' No auto-repeat action
01634 0a5 ff000000                 cmp     kbd_poll_cnt, ##KBD_REPEAT_DELAY wz
01638 0a6 f20fb43e 
0163c 0a7 ad645c5f         if_z    drvnot  #DRIVER_KBD_LED                 ' DEBUG: pulse USER_LED when keyboard activity
01640 0a8 ff000010                 rdbyte  dpar1, ##kbd_last_key           ' Peek at the last key-down keycode
01644 0a9 fac785ba 
01648 0aa f20f8439                 cmp     dpar1, #KEY_CAPSLK      wz
0164c 0ab a6078400         if_z    mov     dpar1, #KEY_NO_KEY
01650 0ac f20f8400                 cmp     dpar1, #KEY_NO_KEY      wz
01654 0ad af000000         if_z    mov     kbd_repeat, ##KBD_REPEAT_DELAY  ' Key repeat delay reset on KEY_NO_KEY
01658 0ae a607b63e 
0165c 0af a607b400         if_z    mov     kbd_poll_cnt, #0
01660 0b0 ad64002d         if_z    ret
01664 0b1 ff000000                 add     kbd_repeat, ##KBD_REPEAT_RATE   ' Set the next repeat interval
01668 0b2 f107b605 
0166c 0b3 fd801174                 jmp     #sendkey                        ' Repeat the key being held down and return to caller
01670 0b4          .data
01670 0b4 fd645c5f                 drvnot  #DRIVER_KBD_LED                 ' DEBUG: pulse USER_LED when keyboard activity
01674 0b5 ff000010                 rdbyte  dpar1, ##kbd_next_datax
01678 0b6 fac785a7 
0167c 0b7 f20f84c3                 cmp     dpar1, #PID_DATA0       wz
01680 0b8 a607844b         if_z    mov     dpar1, #PID_DATA1               ' Txn success, so toggle DATAx
01684 0b9 560784c3         if_nz   mov     dpar1, #PID_DATA0
01688 0ba ff000010                 wrbyte  dpar1, ##kbd_next_datax
0168c 0bb fc4785a7 
01690 0bc ff000010                 wrbyte  dpar3, ##kbd_max_index          ' Save actual bytes read
01694 0bd fc4789a8 
01698 0be fda0109c                 call    #kbd_compare                    ' Check keypress activity since last IN
0169c 0bf          .led_check
0169c 0bf ff000010                 rdbyte  dtmp, ##kbd_led_states
016a0 0c0 fac797a9 
016a4 0c1 f20bcdcb                 cmp     dkbd_ledstates, dtmp    wz
016a8 0c2 a607aa02         if_z    mov     dtask, #DT_POLL_DATA
016ac 0c3 ad64002d         if_z    ret                                     ' No toggle key indicator changes, so we're done
016b0 0c4 ff000010                 wrbyte  dkbd_ledstates, ##kbd_led_states' Update toggle key indicator states
016b4 0c5 fc47cda9 
016b8 0c6 ff000000                 mov     dres_handler, ##res_kbdled1     ' Send USB transaction to set/clear keyboard LEDs affected
016bc 0c7 f6079ac9 
016c0 0c8 fd801068                 jmp     #dset_kbdled_report
016c4 0c9          res_kbdled1
016c4 0c9 f20f86d2                 cmp     dpar2, #PID_ACK         wz
016c8 0ca 5ec01e0a         if_nz   loc     ptra, #@sz_setrept_output
016cc 0cb 5d80125c         if_nz   jmp     #dtx_result_to_con              ' FIXME: on !ACK try to recover instead of punting to idle state
016d0 0cc f607aa02                 mov     dtask, #DT_POLL_DATA            ' ACK, so back to device poll task
016d4 0cd f6079407                 mov     dtx, #BELL
016d8 0ce fd9001b0                 jmp     #dtx_char
                   {
                   dtx_kbd_data
                   .loop
                                   rdbyte  dtx, ptrb++
                                   call    #dtx_hexbyte
                                   mov     dtx, #" "
                                   call    #dtx_char
                                   djnz    dpar3, #.loop                   ' Txn result reg dpar3 has actual bytes in report
                                   ret
                   }
                   ' */
                   ' /* dget_mouse_in_report
                   '------------------------------------------------------------------------------
                   ' Post an IN interrupt request to the host to poll for mouse activity.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
016dc 0cf          dget_mouse_in_report
016dc 0cf f607aa00                 mov     dtask, #DT_IDLE
016e0 0d0 f6079803                 mov     devent, #HINT_IN
016e4 0d1 f60385dc                 mov     dpar1, mouse_ep_addr
016e8 0d2 ff000010                 mov     dpar2, ##mouse_cur_report
016ec 0d3 f60787bf 
016f0 0d4 ff000010                 rdbyte  dtmp, ##mouse_in_max_pkt        ' Always ask for max report size
016f4 0d5 fac797bd 
016f8 0d6 ff000010                 rdbyte  dpar3, ##mouse_next_datax       ' Word0 DATAx PID to expect
016fc 0d7 fac789be 
01700 0d8 f92b89cb                 setword dpar3, dtmp, #1                 ' Word1 max IN packet size to expect
01704 0d9 ff000000                 mov     dres_handler, ##res_mouse_in
01708 0da f6079adc 
0170c 0db fd9ffd0c                 jmp     #post_hevent
01710 0dc          res_mouse_in
01710 0dc f603b9c2                 mov     mouse_ep_addr, dpar1            ' Get address with calculated CRC
01714 0dd f20f86d2                 cmp     dpar2, #PID_ACK         wz
01718 0de ad900030         if_z    jmp     #.data
0171c 0df f20f865a                 cmp     dpar2, #PID_NAK         wz
01720 0e0 ad900010         if_z    jmp     #.nak
01724 0e1 fec01de7                 loc     ptra, #@sz_intin_result
01728 0e2 f20f8605                 cmp     dpar2, #ERR_TXN_RETRY   wz      ' FIXME: full-speed will sometimes miss > 3 packets
0172c 0e3 ad900004         if_z    jmp     #.nak                           ' FIXME: shouldn't ignore this error when > 80MHz
01730 0e4 fd80125c                 jmp     #dtx_result_to_con              ' Something other than ACK/NAK, so likely fatal
01734 0e5          .nak
01734 0e5 f107bc01                 add     mouse_poll_cnt, #1
01738 0e6 ff000000                 cmp     mouse_poll_cnt, ##MOUSE_NAK_DELAY  wcz
0173c 0e7 f21fbc3e 
01740 0e8 3d645a5f         if_ae   drvnot  #DRIVER_MOUSE_LED               ' DEBUG: pulse USER_LED when mouse activity
01744 0e9 3607bc00         if_ae   mov     mouse_poll_cnt, #0
01748 0ea 0607aa02         _ret_   mov     dtask, #DT_POLL_DATA
                   '------------------------------------------------------------------------------
                   ' Serial output of the mouse data packet. Uses the Propeller Serial Terminal
                   ' screen control codes to refresh the output without scrolling the screen.
                   '------------------------------------------------------------------------------
0174c 0eb          .data
                   ' DEBUG: some devices may return a zero-length packet with ACK, which I'm not
                   ' sure is "legal" or not. The easiest fix is to just treat it as a NAK...
0174c 0eb f20f8800                 cmp     dpar3, #0               wz
01750 0ec ad9fffe0         if_z    jmp     #.nak                           ' FIXME: ignore empty packet
01754 0ed f607bc00                 mov     mouse_poll_cnt, #0
01758 0ee fd645a5f                 drvnot  #DRIVER_MOUSE_LED               ' DEBUG: pulse USER_LED when mouse activity
0175c 0ef ff000010                 rdbyte  dpar1, ##mouse_next_datax
01760 0f0 fac785be 
01764 0f1 f20f84c3                 cmp     dpar1, #PID_DATA0       wz
01768 0f2 a607844b         if_z    mov     dpar1, #PID_DATA1               ' ACK, so toggle DATAx
0176c 0f3 560784c3         if_nz   mov     dpar1, #PID_DATA0
01770 0f4 ff000010                 wrbyte  dpar1, ##mouse_next_datax
01774 0f5 fc4785be 
01778 0f6 fda011c8                 call    #mouse_compare
0177c 0f7 f20f9c00                 cmp     drep, #0                wz
01780 0f8 5d9fffb0         if_nz   jmp     #.nak                           ' No changes, so we're done
01784 0f9 f4179005                 testb   dtxopts, #MSCROLLB      wc
01788 0fa cd900014         if_c    jmp     #.data_out
                   ' Inhibit scrolling of mouse data output text
0178c 0fb f60f9401                 mov     dtx, #USE_GOTOX         wz      ' Do we use PST GOTOX command or not?
01790 0fc a607940d         if_z    mov     dtx, #CR
01794 0fd adb0011c         if_z    call    #dtx_rawchar                    ' For most terminals, a lone CR does what we want
01798 0fe 56079400         if_nz   mov     dtx, #0                         ' Use PST GOTOX function to position cursor at column zero
0179c 0ff 5db00138         if_nz   call    #dtx_gotox
017a0 100          .data_out
017a0 100 fec01f2b                 loc     ptra, #@sz_mouse_hdrd0          ' DEBUG
017a4 101 fdb000d4                 call    #dtx_asciiz                     ' DEBUG
017a8 102 fd63922a                 push    min_digits                      ' DEBUG
017ac 103 f607920a                 mov     min_digits, #10                 ' DEBUG
017b0 104 f60395df                 mov     dtx, dmouse_count               ' DEBUG
017b4 105 fdb00150                 call    #dtx_decimal                    ' DEBUG
017b8 106 fd63922b                 pop     min_digits                      ' DEBUG
017bc 107 fec01f33                 loc     ptra, #@sz_mouse_hdrd1          ' DEBUG
                   '                loc     ptra, #@sz_mouse_hdr0
017c0 108 fdb000b8                 call    #dtx_asciiz
017c4 109 fee021bf                 loc     ptrb, #@mouse_cur_report
017c8 10a fac7c5e1                 rdbyte  dmouse_btnflgs, ptrb++          ' Button bitflags
017cc 10b f60395e2                 mov     dtx, dmouse_btnflgs             ' Output mouse button states
017d0 10c f6079c08                 mov     drep, #8                        ' Show all eight button flags
017d4 10d fdb00230                 call    #dtx_bin
017d8 10e fec01f4b                 loc     ptra, #@sz_mouse_hdr1
017dc 10f fdb0009c                 call    #dtx_asciiz
017e0 110 fac7c1e1                 rdbyte  dmouse_x, ptrb++                ' X direction/velocity
017e4 111 f767c007                 signx   dmouse_x, #7                    ' Sign extend, min -127, max 127
017e8 112 ff7fffff                 fges    dmouse_x, ##-127                ' -128 is considered an invalid value
017ec 113 f347c181 
017f0 114 f6079203                 mov     min_digits, #3
017f4 115 f60395e0                 mov     dtx, dmouse_x
017f8 116 fdb000f0                 call    #dtx_decimal_s
017fc 117 fec01f51                 loc     ptra, #@sz_mouse_hdr2
01800 118 fdb00078                 call    #dtx_asciiz
01804 119 fac7c3e1                 rdbyte  dmouse_y, ptrb++                ' Y direction/velocity
01808 11a f767c207                 signx   dmouse_y, #7
0180c 11b ff7fffff                 fges    dmouse_y, ##-127
01810 11c f347c381 
01814 11d f6079203                 mov     min_digits, #3
01818 11e f60395e1                 mov     dtx, dmouse_y
0181c 11f fdb000cc                 call    #dtx_decimal_s                  ' Y value to terminal
                   ' Publish the updated mouse position and button flags to the public interface in hub RAM
01820 120 f107be01                 add     dmouse_count, #1                ' Increment to signal client(s) there's a new mouse event
01824 121 fd640628                 setq    #4 - 1                          ' Four cog registers in fast block write
01828 122 ff000003                 wrlong  dmouse_count, ##@mouse_count
0182c 123 fc67bfe0 
01830 124 f607aa02                 mov     dtask, #DT_POLL_DATA
01834 125 f4179005                 testb   dtxopts, #MSCROLLB      wc
01838 126 cd900070         if_c    jmp     #dtx_newline                    ' Scroll the mouse data output and back to caller
0183c 127 fd64002d                 ret
                   {
                                   sub     dpar3, #3               wz      ' Bytes 0..2 in boot protocol interpreted the same for all
                           if_z    jmp     #.eol                           ' Report bytes 3..N are allowed but device specific
                                   loc     ptra, #@sz_mouse_hdr3
                                   call    #dtx_asciiz
                                   call    #dtx_kbd_data                   ' Use keyboard routine to dump remaining data and return to caller
                   .eol
                                   mov     drep, #4
                                   mov     dtx, #" "                       ' Pad end of line as X/Y output is not a constant width
                                   call    #dtx_rptchar                    ' Propeller Serial Terminal code to prohibit line scroll
                   }
                   ' */
                   ' /* get_dtxn_hresult
                   '------------------------------------------------------------------------------
                   ' Retrieve the results of a USB transaction submitted via the event mechanism.
                   ' NOTE: The host must use this eventID BEFORE the device has been configured.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg dpar1: CRC5/ep/addr for the txn.
                   '           Reg dpar2: result code for the txn or error code.
                   '           Reg dpar3: content depends on the result context.
                   '------------------------------------------------------------------------------
01840 128          get_dtxn_hresult
01840 128 faa785f9                 rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
01844 129 faa787fa                 rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
01848 12a faa789fb                 rdlut   dpar3, #D_PAR3                  ' Host active/idle state
0184c 12b fc3c01fd                 wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
01850 12c f603f1c2                 mov     ptra, dpar1
01854 12d fd80125c                 jmp     #dtx_result_to_con              ' Result routed to the terminal
                   ' */
                   ' /* get_dtxn_result
                   '------------------------------------------------------------------------------
                   ' Retrieve the results of a USB transaction submitted via the event mechanism.
                   ' NOTE: The host must use this eventID AFTER the device has been configured.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:  Reg dpar1: CRC5/ep/addr for the txn.
                   '           Reg dpar2: result code for the txn.
                   '           Reg dpar3: content depends on the result context.
                   '------------------------------------------------------------------------------
01858 12e          get_dtxn_result
01858 12e faa785f9                 rdlut   dpar1, #D_PAR1                  ' The CRC5/ep/addr for the txn
0185c 12f faa787fa                 rdlut   dpar2, #D_PAR2                  ' Txn result: PIDs ACK/NAK/STALL or error code
01860 130 faa789fb                 rdlut   dpar3, #D_PAR3                  ' Context dependent value
01864 131 fc3c01fd                 wrlut   #D_READY, #D_EVENT              ' Ready for next event posting
01868 132 fd639a2c                 jmp     dres_handler                    ' Off to the result handler
                   ' */
                   ' /* dtx_dbgval
                   '------------------------------------------------------------------------------
                   ' Output class driver debug value (driver does not halt).
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar3: arbitrary debug value.
                   ' On exit:
                   '------------------------------------------------------------------------------
0186c 133          dtx_dbgval
0186c 133 fec01fa7                 loc     ptra, #@sz_breakd
01870 134 fdb00008                 call    #dtx_asciiz
01874 135 f60395c4                 mov     dtx, dpar3
01878 136 fd90011c                 jmp     #dtx_hexlong
                   ' */
                   ' /* dtx_asciiz
                   '------------------------------------------------------------------------------
                   ' Output an ASCIIZ string to the terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg PTRA: address of first byte of the string.
                   ' On exit:
                   '------------------------------------------------------------------------------
0187c 137          dtx_asciiz
0187c 137 facf9561                 rdbyte  dtx, ptra++             wz
01880 138 ad64002d         if_z    ret
01884 139 fdb00004                 call    #dtx_char
01888 13a fd9ffff0                 jmp     #dtx_asciiz
                   ' */
                   ' /* dtx_char
                   '------------------------------------------------------------------------------
                   ' Output a character to the terminal. A carriage return character ($0D)
                   ' encountered here should be translated to whatever your particular terminal
                   ' expects as a newline sequence.
                   '------------------------------------------------------------------------------
0188c 13b          dtx_char
0188c 13b fd747c40                 testp   #TX                     wc
01890 13c 3d9ffff8         if_nc   jmp     #dtx_char
01894 13d f50794ff                 and     dtx, #$ff                       ' Ensure limited to extended ASCII space
01898 13e fc27943e                 wypin   dtx, #TX
0189c 13f f20f940d                 cmp     dtx, #CR                wz
018a0 140 5d64002d         if_nz   ret
018a4 141 f607940a                 mov     dtx, #LF                        ' Translate CR to CRLF
018a8 142 fd9fffe0                 jmp     #dtx_char
                   ' /* dtx_newline
                   '------------------------------------------------------------------------------
                   ' For those times you just want to start a new line.
                   '------------------------------------------------------------------------------
018ac 143          dtx_newline
018ac 143 f607940d                 mov     dtx, #CR
018b0 144 fd9fffd8                 jmp     #dtx_char
                   ' */
                   ' /* dtx_rawchar
                   '------------------------------------------------------------------------------
                   ' Output a single byte to the serial port without any translation.
                   '------------------------------------------------------------------------------
018b4 145          dtx_rawchar
018b4 145 fd747c40                 testp   #TX                     wc
018b8 146 3d9fffd0         if_nc   jmp     #dtx_char
018bc 147 f50794ff                 and     dtx, #$ff                       ' Ensure limited to extended ASCII space
018c0 148 0c27943e         _ret_   wypin   dtx, #TX
                   ' */
                   ' /* dtx_rptchar
                   '------------------------------------------------------------------------------
                   ' Output character, repeated n times.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: character to transmit.
                   '           Reg drep: contains the repeat count.
                   ' On exit:
                   '------------------------------------------------------------------------------
018c4 149          dtx_rptchar
018c4 149 fdbfffc4                 call    #dtx_char
018c8 14a fb6f9dfe                 djnz    drep, #dtx_rptchar
018cc 14b fd64002d                 ret
                   ' */
                   ' /* dtx_cls
                   '------------------------------------------------------------------------------
                   ' Clear the terminal screen (PST specific).
                   '------------------------------------------------------------------------------
018d0 14c          dtx_cls
018d0 14c f6079410                 mov     dtx, #CLS
018d4 14d fd9fffb4                 jmp     #dtx_char
                   ' */
                   ' /* dtx_gotox
                   '------------------------------------------------------------------------------
                   ' Position the cursor at column X of the terminal screen (PST specific).
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: the new column position for the cursor.
                   '------------------------------------------------------------------------------
018d8 14e          dtx_gotox
018d8 14e fd63942a                 push    dtx                             ' Save new column position
018dc 14f f607940e                 mov     dtx, #GOTOX
018e0 150 fdbfffa8                 call    #dtx_char                       ' Send GOTOX command to PST
018e4 151 fd63942b                 pop     dtx
018e8 152 fd9fffc8                 jmp     #dtx_rawchar                    ' Send byte as-is and return to caller
                   ' */
                   ' /* dtx_decimal_s, dtx_decimal
                   '------------------------------------------------------------------------------
                   ' Convert a signed/unsigned 32-bit decimal value to text. Leading zeros are
                   ' skipped on output. Based on a routine written by Ozpropdev.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert to decimal characters.
                   '           Reg min_digits: if the value has fewer than min_digits, pad with
                   '           leading zeroes.
                   ' On exit:
                   '------------------------------------------------------------------------------
018ec 153          dtx_decimal_s
018ec 153 f60397ca                 mov     dtmp, dtx
018f0 154 f417941f                 testb   dtx, #31                wc
018f4 155 c607942d         if_c    mov     dtx, #"-"
018f8 156 3607942b         if_nc   mov     dtx, #"+"
018fc 157 f68397cb                 negc    dtmp                            ' If negative, back to positive for output
01900 158 fdbfff88                 call    #dtx_char
01904 159 f60395cb                 mov     dtx, dtmp
01908 15a          dtx_decimal
01908 15a ff1dcd65                 mov     dr0, ##1_000_000_000            ' Divisor
0190c 15b f6077c00 
01910 15c f6077e00                 mov     dr1, #0                         ' Reg dr1 holds digit postions 7..0
01914 15d f6079c0a                 mov     drep, #10                       ' Max of 10 digit output
01918 15e f327920a                 fle     min_digits, #10                 ' FIXME: should throw out-of-range error
0191c 15f f3079201                 fge     min_digits, #1
01920 160 f6078200                 mov     dr3, #0
01924 161 fcdc140a                 rep     @.end, #10
01928 162 fd1395be                 qdiv    dtx, dr0
0192c 163 fd6b9618                 getqx   dtmp                    wz
01930 164 51078201         if_nz   add     dr3, #1                         ' Becomes non-zero at first leading non-zero digit
01934 165 f20f8200                 cmp     dr3, #0                 wz
01938 166 a1879c01         if_z    sub     drep, #1                        ' Decrement digit count if it's a leading zero
0193c 167          .getqy
0193c 167 fd639419                 getqy   dtx
01940 168 f8bb81bf                 rolnib  dr2, dr1, #7                    ' Reg dr2 holds digit postions 9..8
01944 169 f8837fcb                 rolnib  dr1, dtmp, #0
01948 16a fd177c0a                 qdiv    dr0, #10
0194c 16b fd637c18                 getqx   dr0
01950 16c          .end
01950 16c f3039dc9                 fge     drep, min_digits                ' Pad with zeroes as necessary to meet minimum digit count
01954 16d f21f9c09                 cmp     drep, #9                wcz
01958 16e cd900014         if_b    jmp     #.r1out
0195c 16f f60383ce                 mov     dr3, drep
01960 170 f1879c08                 sub     drep, #8                        ' Get count of digits > 8
01964 171 f60395c0                 mov     dtx, dr2
01968 172 fdb00034                 call    #dtx_hex
0196c 173 f6039dc1                 mov     drep, dr3
01970 174          .r1out
01970 174 f6079201                 mov     min_digits, #1                  ' Reset to minimum digit count default
01974 175 f3279c08                 fle     drep, #8
01978 176 f60395bf                 mov     dtx, dr1                        ' Output remaining digits
0197c 177 fd900020                 jmp     #dtx_hex
                   ' */
                   ' /* Output hex nibble/byte/word/long
                   '------------------------------------------------------------------------------
                   ' Convert to text a 4-bit value as hexadecimal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
01980 178          dtx_hexnib
01980 178 f6079c01                 mov     drep, #1
01984 179 fd900018                 jmp     #dtx_hex
                   '------------------------------------------------------------------------------
                   ' Convert to text an 8-bit value as hexadecimal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
01988 17a          dtx_hexbyte
01988 17a f6079c02                 mov     drep, #2
0198c 17b fd900010                 jmp     #dtx_hex
                   '------------------------------------------------------------------------------
                   ' Convert to text a 16-bit value as hexadecimal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
01990 17c          dtx_hexword
01990 17c f6079c04                 mov     drep, #4
01994 17d fd900008                 jmp     #dtx_hex
                   '------------------------------------------------------------------------------
                   ' Convert to text a 32-bit value as hexadecimal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
01998 17e          dtx_hexlong
01998 17e f6079c08                 mov     drep, #8
0199c 17f fd900000                 jmp     #dtx_hex
                   ' */
                   ' /* dtx_hex
                   '------------------------------------------------------------------------------
                   ' Convert to text one to 8 hexadecimal/decimal digits.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to send.
                   '           Reg drep: count of nibbles to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
019a0 180          dtx_hex
019a0 180 f3079c01                 fge     drep, #1
019a4 181 f3279c08                 fle     drep, #8
019a8 182 f60397ce                 mov     dtmp, drep
019ac 183 f0679602                 shl     dtmp, #2
019b0 184 f2c79620                 subr    dtmp, #32
019b4 185 f06395cb                 shl     dtx, dtmp                       ' Left justify for output
019b8 186 f60397ca                 mov     dtmp, dtx
019bc 187 f4179002                 testb   dtxopts, #IN_PARENSB    wc
019c0 188 c6079428         if_c    mov     dtx, #"("
019c4 189 cdbffec4         if_c    call    #dtx_char
019c8 18a f4179001                 testb   dtxopts, #PREPEND_0XB   wc
019cc 18b cec01c97         if_c    loc     ptra, #@sz_0x
019d0 18c cdbffea8         if_c    call    #dtx_asciiz
019d4 18d          .loop
019d4 18d f87b95cb                 getnib  dtx, dtmp, #7
019d8 18e f21f9409                 cmp     dtx, #9                 wcz
019dc 18f e1079430         if_be   add     dtx, #"0"
019e0 190 11079437         if_a    add     dtx, #"A" - 10
019e4 191 fdbffea4                 call    #dtx_char
019e8 192 f0679604                 shl     dtmp, #4                        ' Left justify next nibble
019ec 193 fb6f9df9                 djnz    drep, #.loop
019f0 194 f4179002                 testb   dtxopts, #IN_PARENSB    wc
019f4 195 c6079429         if_c    mov     dtx, #")"
019f8 196 cdbffe90         if_c    call    #dtx_char
019fc 197 f4179000                 testb   dtxopts, #APPEND_CRB    wc
01a00 198 cd9ffea8         if_c    jmp     #dtx_newline
01a04 199 fd64002d                 ret
                   ' */
                   ' /* dtx_bin
                   '------------------------------------------------------------------------------
                   ' Convert to text one to 32 binary digits. Bits are sent MSb first.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dtx: value to convert.
                   '           Reg drep: count of bits to convert.
                   ' On exit:
                   '------------------------------------------------------------------------------
01a08 19a          dtx_bin
01a08 19a f3279c20                 fle     drep, #32
01a0c 19b f3079c01                 fge     drep, #1
01a10 19c f60397ca                 mov     dtmp, dtx
01a14 19d f4179002                 testb   dtxopts, #IN_PARENSB    wc
01a18 19e c6079428         if_c    mov     dtx, #"("
01a1c 19f cdbffe6c         if_c    call    #dtx_char
01a20 1a0 f4179001                 testb   dtxopts, #PREPEND_0XB   wc
01a24 1a1 cec01c9a         if_c    loc     ptra, #@sz_0b
01a28 1a2 cdbffe50         if_c    call    #dtx_asciiz                     ' Option prepend "0x" to output
01a2c 1a3 f6079420                 mov     dtx, #32
01a30 1a4 f18395ce                 sub     dtx, drep
01a34 1a5 f06397ca                 shl     dtmp, dtx                       ' Left justify to get to MSb
01a38 1a6          .next
01a38 1a6 f0779601                 shl     dtmp, #1                wc      ' Tx MSb->LSb
01a3c 1a7 36079430         if_nc   mov     dtx, #"0"
01a40 1a8 c6079431         if_c    mov     dtx, #"1"
01a44 1a9 fdbffe44                 call    #dtx_char
01a48 1aa fb6f9dfb                 djnz    drep, #.next
01a4c 1ab f4179002                 testb   dtxopts, #IN_PARENSB    wc
01a50 1ac c6079429         if_c    mov     dtx, #")"
01a54 1ad cdbffe34         if_c    call    #dtx_char
01a58 1ae f4179000                 testb   dtxopts, #APPEND_CRB    wc
01a5c 1af cd9ffe4c         if_c    jmp     #dtx_newline
01a60 1b0 fd64002d                 ret
                   ' */
                   ' /* htx_asciiz
                   '------------------------------------------------------------------------------
                   ' Read LUT request queue and output an ASCIIZ string to the terminal.
                   '------------------------------------------------------------------------------
                   ' On entry: Reg dpar1: start address of string to output.
                   ' On exit:
                   '------------------------------------------------------------------------------
01a64 1b1          htx_asciiz
01a64 1b1 f603f1c2                 mov     ptra, dpar1
01a68 1b2          .next
01a68 1b2 facf9561                 rdbyte  dtx, ptra++             wz
01a6c 1b3 ad64002d         if_z    ret                                     ' Done with string output
01a70 1b4 fdbffe18                 call    #dtx_char
01a74 1b5 fd9ffff0                 jmp     #.next
                   ' */
                   ' /* load_kdb_lut
                   '------------------------------------------------------------------------------
                   ' Cells 0..255 of the shared LUT cells are allocated to the driver cog.
                   '------------------------------------------------------------------------------
                   ' Copy the keyboard conversion table to LUT at startup.
                   '------------------------------------------------------------------------------
                   ' On entry:
                   ' On exit:
                   '------------------------------------------------------------------------------
01a78 1b6          load_kbd_lut
01a78 1b6 ff000012                 mov     drep, ##@kbd_end - 4            ' Hub RAM is byte-aligned
01a7c 1b7 f6079cf8 
01a80 1b8 ff000011                 sub     drep, ##@kbd_table
01a84 1b9 f1879d64 
01a88 1ba f0479c02                 shr     drep, #2                        ' SETQ2 N - 1 LUT cell count in longs
01a8c 1bb fd639c29                 setq2   drep
01a90 1bc ff000011         _ret_   rdlong  0, ##@kbd_table
01a94 1bd 0b040164 
                   ' */
                   ' /* Class driver registers
01a98 1be 00000000 dr0             long    0                               ' Multi-purpose registers
01a9c 1bf 00000000 dr1             long    0
01aa0 1c0 00000000 dr2             long    0
01aa4 1c1 00000000 dr3             long    0
01aa8 1c2 00000000 dpar1           long    0                               ' Routine entry/exit parameters
01aac 1c3 00000000 dpar2           long    0
01ab0 1c4 00000000 dpar3           long    0
01ab4 1c5 00000000 dct1            long    0                               ' Keyboard interrupt IN interval timer
01ab8 1c6 00000000 dct2            long    0                               ' Mouse interrupt IN interval timer
01abc 1c7 00000000 dct3            long    0                               ' Driver main loop blinking LED timer
01ac0 1c8 00000000 dtxopts         long    0                               ' Value->text conversion option bitflags
01ac4 1c9 00000000 min_digits      long    0                               ' Pad with leading zeros if value has fewer than min_digits
01ac8 1ca 00000000 dtx             long    0                               ' Character to output
01acc 1cb 00000000 dtmp            long    0
01ad0 1cc 00000000 devent          long    0                               ' Command/request eventID posted by the host cog
01ad4 1cd 00000000 dres_handler    long    0                               ' Address of an IRP result handler routine
01ad8 1ce 00000000 drep            long    0                               ' Repeat count
01adc 1cf 00000000 con_tot_len     long    0                               ' Size of the complete config descriptor chain
01ae0 1d0 00000000 hid_intf_idx    long    0                               ' Used during verbose descriptor terminal output
01ae4 1d1 00000000 search_key      long    0                               ' Descriptor type to search for in the config chain
01ae8 1d2 00000000 next_desc       long    0                               ' Offset from the config descriptor start address to the next descriptor in the chain
01aec 1d3 00000000 langid          long    0                               ' Keep LangID stickey
01af0 1d4 00000000 ctrl_ep_addr    long    0                               ' Ep/addr for control transactions
                   '------------------------------------------------------------------------------
                   ' Define registers you want initialized to zero at device reset/disconnect
                   ' between labels dreg_init_start/dreg_init_end.
                   '------------------------------------------------------------------------------
01af4 1d5          dreg_init_start
01af4 1d5 00000000 dtask           long    0                               ' Class driver's current task focus
01af8 1d6 00000000 device_base     long    0                               ' Base address for the device descriptor buffer
01afc 1d7 00000000 config_base     long    0                               ' Base address for config descriptor chain buffer
01b00 1d8 00000000 kbd_ep_addr     long    0
01b04 1d9 00000000 kbd_report      long    0                               ' Address of report descriptor data for the keyboard interface
01b08 1da 00000000 kbd_poll_cnt    long    0                               ' Poll interval counter used for key auto-repeat
01b0c 1db 00000000 kbd_repeat      long    0                               ' Key auto-repeat delay threshold
01b10 1dc 00000000 mouse_ep_addr   long    0
01b14 1dd 00000000 mouse_report    long    0                               ' Address of report descriptor data for the mouse interface
01b18 1de 00000000 mouse_poll_cnt  long    0
                   ' The following registers must match the layout of the "public" mouse/keyboard
                   ' interface that's in hub RAM.
01b1c 1df 00000000 dmouse_count    long    0                               ' mouse_count
01b20 1e0 00000000 dmouse_x        long    0                               ' mouse_x
01b24 1e1 00000000 dmouse_y        long    0                               ' mouse_y
01b28 1e2 00000000 dmouse_btnflgs  long    0                               ' mouse_btnflgs
01b2c 1e3 00000000 dkbd_count      long    0                               ' kbd_count
01b30 1e4 00000000 dkbd_keypress   long    0                               ' kbd_keypress
01b34 1e5 00000000 dkbd_modkeys    long    0                               ' kbd_modkeys
01b38 1e6 00000000 dkbd_ledstates  long    0                               ' kbd_ledstates
01b3c 1e7          dreg_init_end
                   ' */
01b3c 1e7 efbeedfe                 long    DBG_FEEDBEEF                    ' End of used cog space marker
01b40 1e8 ffffffff                 long    -1[$1f0 - $]                    ' Fill remaining free space with $FFs
01b60 1f0                          fit     $1f0                            ' Not using interrupt registers
                   ' #endregion DAT (Class Driver Cog)
                   ' #region CON (USB Descriptor Definitions)
                   con
                   '------------------------------------------------------------------------------
                   ' USB References:
                   ' Universal Serial Bus Specification, Revision 2.0
                   '   www.usb.org/developers/docs/usb20_docs/
                   ' Device Class Definition for Human Interface Devices (HID), Version 1.11
                   '   www.usb.org/developers/hidpage/
                   '------------------------------------------------------------------------------
                   ' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
                   ' Use TYPE_STANDARD for all USB Standard Device Request codes.
                   '------------------------------------------------------------------------------
                   ' D7 Data direction  | D6:5 Type    | D4:0 Recipient
                   '------------------------------------------------------------------------------
                   ' 0 - Host-to-device | 0 = Standard | 0 = Device
                   ' 1 - Device-to-host | 1 = Class    | 1 = Interface
                   '                    | 2 = Vendor   | 2 = Endpoint
                   '                    | 3 = Reserved | 3 = Other
                   '                    |              | 4 -31 = Reserved
                   '------------------------------------------------------------------------------
                           DIR_HOST_TO_DEV = 0 << 7
                           DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
                           TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
                           TYPE_CLASS      = %01 << 5
                           TYPE_VENDOR     = %10 << 5
                           TYPE_RESERVED   = %11 << 5
                           RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
                           RECIP_INTERFACE = %0_0001
                           RECIP_ENDPOINT  = %0_0010
                           RECIP_OTHER     = %0_0011
                   '       RECIP 4 - 31 = Reserved
                   '------------------------------------------------------------------------------
                   ' Standard Device Request codes (Section 9.4, Table 9-4):
                   '------------------------------------------------------------------------------
                           #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
                           REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
                           REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
                   '------------------------------------------------------------------------------
                   ' Standard descriptor types (Section 9.4, Table 9-5):
                   '------------------------------------------------------------------------------
                           #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
                           TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
                   '------------------------------------------------------------------------------
                   ' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
                   '------------------------------------------------------------------------------
                           #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
                           CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
                           CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
                           CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
                           CLASS_DIAGNOSTIC_DEV  = $dc
                           CLASS_WIRELESS_CTRL   = $e0
                           CLASS_MISCELLANEOUS   = $ef
                           CLASS_APP_SPECIFIC    = $fe
                           CLASS_VENDOR_SPECIFIC = $ff
                   '------------------------------------------------------------------------------
                   ' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
                   '------------------------------------------------------------------------------
                           #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
                           HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
                   ' HID Descriptor types:
                           #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
                   '------------------------------------------------------------------------------
                   ' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
                   '------------------------------------------------------------------------------
                           #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
                   '------------------------------------------------------------------------------
                   ' HID Interface SubClasses:
                   '------------------------------------------------------------------------------
                           #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
                   '------------------------------------------------------------------------------
                   ' HID Protocol codes:
                   '------------------------------------------------------------------------------
                           #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
                           #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
                   '------------------------------------------------------------------------------
                   ' Other HID buffer lengths:
                   '------------------------------------------------------------------------------
                           MAX_HID_REPTS   = 4             ' We have this many HID report buffers
                           REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
                           REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
                           LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
                           USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
                   '------------------------------------------------------------------------------
                   ' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
                   '------------------------------------------------------------------------------
                           LANG_ENG_US  = $0409            ' English (United States)
                           LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
                   '------------------------------------------------------------------------------
                   ' SETUP structure member offsets.
                   ' NOTE: These offsets are defined in terms of the structure member's data type,
                   '       to take advantage of PTRA/B scaled indexing, e.g.:
                   '         RDBYTE D,   PTRA[bRequest]
                   '         WRWORD D/#, PTRA[wLength]
                   '------------------------------------------------------------------------------
                           bmRequestType = 0
                           bRequest      = 1
                           wValue        = 1
                           wIndex        = 2
                           wLength       = 3
                   ' SETUP bmRequestType combinations:
                   {
                           HTD_STD_DEV = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
                           DTH_STD_DEV = (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
                           HTD_STD_INT = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_INTERFACE)
                           HTD_STD_EP  = (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_ENDPOINT)
                   }
                   '------------------------------------------------------------------------------
                   ' Standard USB descriptor structure sizes in bytes. The values defined are the
                   ' minimum size of the descriptor:
                   '------------------------------------------------------------------------------
                           SETUP_TXN_LEN = 8
                           DEV_DESC_LEN  = 18
                           CON_DESC_LEN  = 9
                           INTF_DESC_LEN = 9
                           ENDP_DESC_LEN = 7
                           STR0_DESC_LEN = 4
                           USTR_DESC_LEN = 4
                   '------------------------------------------------------------------------------
                   ' Other USB-related buffer sizes:
                   '------------------------------------------------------------------------------
                           URX_BUFF_LEN = 128      ' USB receiver scratch buffer
                           CON_BUFF_LEN = 255      ' Entire configuration descriptor chain
                   '------------------------------------------------------------------------------
                   ' CON_bmAttrs member bit positions:
                   '------------------------------------------------------------------------------
                           ATTR_RESVB     = 7      ' Reserved (should always be one)
                           ATTR_SELF_PWRB = 6      ' Device Self-Powered
                           ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
                   '       bmAttributes bits 4..0 reserved and reset to zero
                   '------------------------------------------------------------------------------
                   ' Standard USB descriptor struct member offset and member size, in bytes. Note
                   ' that the DESC_bLength and DESC_bDescType members are defined in all of the
                   ' descriptors (including HID) at the offsets shown.
                   '------------------+
                   ' !!! IMPORTANT !!!|
                   '------------------+
                   ' All standard descriptor member offsets are defined in bytes, so if you want
                   ' to use PTRA/B indexing, it is best to use the unscaled PTRx[##index20] syntax
                   ' so the compiler will invoke AUGS with RDxxxx/WRxxxx, e.g.:
                   '       RDBYTE D,   PTRA[##DEV_bMaxPktSize0]
                   '       WRWORD D/#, PTRA[##DEV_bIdProduct]
                   ' It goes without saying that if PTRA/B unscaled indexing is used with pre/post
                   ' increment/decrement, one must be very careful...
                   '------------------------------------------------------------------------------
                   '       Member          Offset  Size    Value           Description
                   '------------------------------------------------------------------------------
                           DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
                           DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
                   ' Device Descriptor (Section 9.6.1, Table 9-8):
                           DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
                           DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
                           DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
                           DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
                           DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
                           DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
                           DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
                           DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
                           DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
                           DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
                           DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
                           DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
                   ' Configuration Descriptor (Section 9.6.3, Table 9-10):
                   '       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
                   '       DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
                           CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
                           CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
                           CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
                           CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
                           CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
                           CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
                   ' Interface Descriptor (Section 9.6.5, Table 9-12):
                   '       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
                   '       DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
                           INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
                           INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
                           INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
                           INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
                           INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
                                                   '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
                                                   '                       reserved for assignment by the USB-IF.
                           INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
                                                   '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
                                                   '                       vendor-specific protocol for this interface.
                           INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
                   ' Endpoint Descriptor (Section 9.6.6, Table 9-13):
                   '       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
                   '       DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
                           ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
                           ENDP_bmAttrs     = 3    ' 1     Bitmap
                           ENDP_wMaxPktSize = 4    ' 2     Number
                           ENDP_bInterval   = 6    ' 1     Number
                   ' String Descriptor Zero (Section 9.6.7, Table 9-15):
                   '       DESC_bLength     = 0    ' 1     N + 2
                   '       DESC_bDescType   = 1    ' 1     Constant
                           STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
                   ' Unicode String Descriptor (Section 9.6.7, Table 9-16):
                   '       DESC_bLength     = 0    ' 1     N + 2
                   '       DESC_bDescType   = 1    ' 1     Constant
                           USTR_wString     = 2    ' N     wString[(N - 2) / 2]
                   ' HID Descriptor (Section 6.2.1)
                   '       DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
                   '       DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
                           HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
                           HID_bCountryCode = 4    ' 1     Number          Hardware target country
                           HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
                           HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
                           HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
                   ' Keyboard and mouse report data buffer lengths (boot protocol):
                           KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
                           KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
                           MOUSE_RPT_LEN   = 8     ' Maximum mouse boot protocol IN data packet size
                   '------------------------------------------------------------------------------
                   ' USB HID Keyboard/Keypad Page (0x07). The keycodes below are indexes into
                   ' the keycode->character look-up table.
                   '------------------------------------------------------------------------------
                   ' First four entries in the key lookup table are info/error indicators:
                           #0,   KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
                   ' Alpha keycodes are contiguous in the lookup table, and if caps lock key is
                   ' toggled on, these are the only keycodes affected by it:
                           KEY_A_a    = $04
                           KEY_Z_z    = $1d
                   ' The toggle keys:
                           KEY_CAPSLK = $39
                           KEY_SCRLK  = $47
                           KEY_NUMLK  = $53
                   '------------------------------------------------------------------------------
                   ' #endregion Con (USB Descriptor Definitions)
                   ' #region DAT (Hub RAM Strings & Buffers)
                   dat
01b60                                      orgh
                   ' Static data:
01b60     003839   button_list             byte    PB3, PB2, 0                     ' Prop123-A9 pushbuttons in use
                   ' #region Strings
                   ' /* Startup splash text:
01b63     20425355 dcog_started            byte    "USB low/full speed host & HID boot protocol keyboard/mouse driver v0.16."
01bab     42202d0d                         byte    CR, "- Button PB3 toggles verbose terminal output on/off."
01be0     42202d0d                         byte    CR, "- Button PB2 toggles mouse data scrolling on/off."
01c12     6568540d                         byte    CR, "The device must be disconnected before options can be changed.", 0
01c52     6265440d sz_verbose_opt          byte    CR, "Debug output to terminal is ", 0
01c70     756f4d0d sz_mscroll_opt          byte    CR, "Mouse data scroll option is ", 0
01c8e     2e66666f sz_off                  byte    "off.", 0
01c93     002e6e6f sz_on                   byte    "on.", 0
01c97     007830   sz_0x                   byte    "0x", 0
01c9a     006230   sz_0b                   byte    "0b", 0
01c9d     6144200d sz_unknown_data         byte    CR, " Data:", 0
                   ' */
                   ' /* Status messages:
01ca5     75463c0d sz_fullspeed            byte    CR, "<Full-Speed device connected.>", 0
01cc5     6f4c3c0d sz_lowspeed             byte    CR, "<Low-Speed device connected.>", 0
01ce4     65443c0d sz_disconnect           byte    CR, "<Device disconnected>.", 0
01cfc     6961570d sz_no_txn               byte    CR, "Waiting for txn slot...", 0
01d15     6172540d sz_generic_result       byte    CR, "Transaction result: ", 0
01d2b     7465470d sz_getdev_result        byte    CR, "GetDescriptor(TYPE_DEVICE): ", 0
01d49     7465470d sz_getconf_result       byte    CR, "GetDescriptor(TYPE_CONFIG): ", 0
01d67     7465530d sz_setaddr_result       byte    CR, "SetAddress(): ", 0
01d77     7465470d sz_getrpt_result        byte    CR, "GetDescriptor(TYPE_REPORT): ", 0
01d95     7465470d sz_getstr_result        byte    CR, "GetDescriptor(TYPE_STRING): ", 0
01db3     7465530d sz_setcon_result        byte    CR, "SetConfiguration(): ", 0
01dc9     7465530d sz_setprot_result       byte    CR, "SetProtocol(): ", 0
01dda     7465530d sz_setidle_result       byte    CR, "SetIdle(): ", 0
01de7     746e490d sz_intin_result         byte    CR, "InterruptIN(): ", 0
01df8     746e490d sz_intout_result        byte    CR, "InterruptOUT(): ", 0
01e0a     7465530d sz_setrept_output       byte    CR, "SetReport(TYPE_OUTPUT): ", 0
01e24     6375530d sz_success              byte    CR, "Success!", 0
01e2e     6d75420d sz_bummer               byte    CR, "Bummer! I don't know what to do with this device.", 0
01e61     6f727245 sz_txn_err              byte    "Error ", 0
01e68     6568540d sz_omit_strs            byte    CR, "The device offers no string descriptors.", 0
01e92     004b4341 sz_ack                  byte    "ACK", 0
01e96     004b414e sz_nak                  byte    "NAK", 0
01e9a     4c415453 sz_stall                byte    "STALL", 0
01ea0     00202c   sz_list_break           byte    ", ", 0
01ea3     4e495b0d sz_nak_count            byte    CR, "[IN-NAK]: ", 0
01eaf     6f6f570d sz_woohoo_kbd           byte    CR, "Woo-hoo, found a boot keyboard!", 0
01ed0     79654b0d sz_kbd_ready            byte    CR, "Keyboard ready...", 0
01ee3     44454c0d sz_kbd_leds             byte    CR, "LED bits: 0b", 0
01ef1     64624b0d sz_kbd_data             byte    CR, "Kbd Data: ", 0
01efd     6f6f570d sz_woohoo_mouse         byte    CR, "Woo-hoo, found a boot mouse!", 0
01f1b     756f4d0d sz_mouse_ready          byte    CR, "Mouse ready...", 0
01f2b     6e756f43 sz_mouse_hdrd0          byte    "Count: ", 0
01f33     7542202c sz_mouse_hdrd1          byte    ", Buttons: ", 0
01f3f     7542202c sz_mouse_hdr0           byte    ", Buttons: ", 0
01f4b     3a58202c sz_mouse_hdr1           byte    ", X: ", 0
01f51     3a59202c sz_mouse_hdr2           byte    ", Y: ", 0
01f57     6544202c sz_mouse_hdr3           byte    ", Device specific: ", 0
                   ' */
                   ' /* Host debug stuff
                   'sz_stathdr             byte    CR, "NeES10KJ  Data", CR, 0
                   'sz_stat                        byte    CR, "USB Status: ", 0
01f6b     4821210d sz_host_stopped         byte    CR, "!!Host has stopped!!", CR, 0
01f82     6265440d sz_dbg_data             byte    CR, "Debug Data: ", 0
01f90     6265440d sz_breakh               byte    CR, "Debug Break (Host): $", 0
01fa7     6265440d sz_breakd               byte    CR, "Debug Value (Driver): $", 0
01fc0     6d754a0d sz_jmptbl_err           byte    CR, "Jump table overrun!", 0
                   ' */
                   ' /* Error code descriptions:
01fd5     20656854 sz_err_none             byte    "The operation completed successfully.", 0
01ffb     20746942 sz_err_urx              byte    "Bit unstuff error, EOP or SE0 > 3 bit-times or SE1.", 0
0202f     42535521 sz_err_se1              byte    "!USB in illegal SE1 state!", 0
0204a     6b636150 sz_err_packet           byte    "Packet missing or corrupt.", 0
02065     20737542 sz_err_tat              byte    "Bus turn-around time exceeded.", 0
02084     72746552 sz_err_txn_retry        byte    "Retry limit exceeded, transaction canceled.", 0
020b0     72746552 sz_err_xfer_retry       byte    "Retry limit exceeded, transfer canceled.", 0
020d9     2d54554f sz_err_out_nak          byte    "OUT-NAK retry limit exceeded.", 0
020f7     44204e49 sz_err_ack_retry        byte    "IN DATAx sync recovery.", CR, 0
02110     78656e55 sz_err_empty_pkt        byte    "Unexpected empty packet.", CR, 0
0212a     31435243 sz_err_crc              byte    "CRC16 verify failed.", CR, 0
                   ' String pointer table for error code descriptions:
02140     00001fd5 err_code_text           long    sz_err_none, sz_err_urx, sz_err_se1, sz_err_packet
02150     00002065                         long    sz_err_tat, sz_err_txn_retry, sz_err_xfer_retry
0215c     000020d9                         long    sz_err_out_nak, sz_err_ack_retry, sz_err_empty_pkt, sz_err_crc
                   ' */
                   ' #endregion Strings
                   ' #region Partially populated SETUP packets
                   '------------------------------------------------------------------------------
0216c     80       get_dev_desc            byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
0216d     06                               byte    REQ_GET_DESC
0216e     0100                             word    TYPE_DEVICE << 8
02170     0000                             word    0       ' Zero or Language ID (Section 9.6.7)
02172     0000                             word    0       ' Number of bytes to transfer if there is a data stage
02174     80       get_config_desc         byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
02175     06                               byte    REQ_GET_DESC
02176     0200                             word    TYPE_CONFIG << 8
02178     0000                             word    0       ' Zero or Language ID (Section 9.6.7)
0217a     0000                             word    0       ' Number of bytes to transfer if there is a data stage
0217c     00       set_config              byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
0217d     09                               byte    REQ_SET_CONFIG
0217e     0000                             word    0       ' Configuration value
02180     0000                             word    0       ' Zero
02182     0000                             word    0       ' Zero, as REQ_SET_CONFIG has no data stage
02184     00       set_address             byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
02185     05                               byte    REQ_SET_ADDR
02186     0000                             word    0       ' Zero
02188     0000                             word    0       ' Zero
0218a     0000                             word    0       ' Zero, as REQ_SET_ADDR has no data stage
                   '------------------------------------------------------------------------------
                   ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
                   ' wValue field dictates which protocol should be used.
                   '
                   ' When initialized, all devices default to report protocol. However the host
                   ' should not make any assumptions about the device state and should set the
                   ' desired protocol whenever initializing a device.
                   '------------------------------------------------------------------------------
0218c     21       set_protocol            byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0218d     0b                               byte    HID_SET_PROTO
0218e     0000                             word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
                                                                   ' (HID 1.11 Section 7.2.6).
02190     0000                             word    0               ' Interface index number.
02192     0000                             word    0               ' Zero, as HID_SET_PROTO has no data stage.
                   '------------------------------------------------------------------------------
02194     21       set_idle                byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02195     0a                               byte    HID_SET_IDLE
02196     0000                             word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
                                                           ' reporting until a change is detected in the report data
                   
                                                           ' (HID 1.11 Section 7.2.4).
02198     0000                             word    0       ' Interface index number.
0219a     0000                             word    0       ' Zero, as HID_SET_IDLE has no data stage.
0219c     21       set_report              byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0219d     09                               byte    HID_SET_REPORT
0219e     0000                             word    0       ' Byte1 = report type, byte0 = ReportID.
                                                           ' (HID 1.11 Section 7.2.2).
021a0     0000                             word    0       ' Interface index number.
021a2     0000                             word    0       ' Size of the report, in bytes.
                   ' #endregion Partially populated SETUP packets
                   ' #region Data buffers and structures
                   '------------------------------------------------------------------------------
                   ' Class driver data structure for boot protocol keyboard.
                   ' FIXME: Device endpoint/address and DATAx toggle state probably should be
                   '        maintained by the host and not the class driver.
                   '------------------------------------------------------------------------------
021a4              kbd_mouse_start
021a4     00       kbd_intf_num            byte    0                       ' Keyboard interface index (zero-based)
021a5     00       kbd_interval            byte    0                       ' Minimum poll interval, in milliseconds
021a6     00       kbd_in_max_pkt          byte    0                       ' Boot protocol IN report max is 8 bytes
021a7     00       kbd_next_datax          byte    0                       ' DATAx PID expected on the next IN transaction
021a8     00       kbd_max_index           byte    0                       ' Actual length of the current IN interrupt packet
021a9     00       kbd_led_states          byte    0                       ' Output report for keyboard toggle key indicator LED states
021aa     00000000 kbd_cur_report          byte    0[KBD_IN_RPT_LEN]       ' Compare buffers for key down/up detection
021b2     00000000 kbd_prev_report         byte    0[KBD_IN_RPT_LEN]
021ba     00       kbd_last_key            byte    0                       ' Used for key auto-repeat
                   ' Class driver data structure for boot protocol mouse:
021bb     00       mouse_intf_num          byte    0                       ' Mouse interface index (zero based)
021bc     00       mouse_interval          byte    0                       ' Minimum poll interval, in milliseconds
021bd     00       mouse_in_max_pkt        byte    0                       ' Boot protocol IN report min of three bytes, max of 8
021be     00       mouse_next_datax        byte    0                       ' DATAx PID expected on the next IN transaction
021bf     00000000 mouse_cur_report        byte    0[MOUSE_RPT_LEN]        ' Max mouse IN data buffer
021c7     00000000 mouse_prev_report       byte    0[MOUSE_RPT_LEN]
021cf              kbd_mouse_end                                           ' End of keyboard/mouse data block
                   ' The USB data cache area gets zero-filled at every device disconnect.
021cf              cache_start
021cf     00000000 urx_buff                byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
0224f     00000000 dev_desc_buff           byte    0[DEV_DESC_LEN]         ' Device descriptor
02261     00000000 con_desc_buff           byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
02360              cache_end
02360                              alignl
02360     dec0adde                 long    DBG_DEADC0DE    ' Marker for top of hub RAM in use
                   ' #endregion Data buffers and structures
                   ' #endregion DAT (Hub RAM Strings & Buffers)
                   ' #region Data loaded to LUT at startup
                   '------------------------------------------------------------------------------
                   ' USB HID "boot protocol" mouse/keyboard driver cog data.
                   '------------------------------------------------------------------------------
                   ' Keyboard/Keypad lookup table.
                   ' Keyboard data gets copied to the class driver cog's LUT at startup, after
                   ' which the block is available for general use.
                   '------------------------------------------------------------------------------
                   ' HID keyboard/keypad usage page conversion table. This example converts to US
                   ' 7-bit ASCII, intended for serial terminals. Byte1 is the shifted character,
                   ' byte0 is the unshifted character.
                   '------------------------------------------------------------------------------
                   dat
02364                              orgh
02364                              alignl
02364              kbd_table
02364     00000000           {$00} long    KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF      ' $03
02374     00004161           {$04} long    $4161, $4262, $4363, $4464                                      ' $07: Aa Bb Cc Dd
02384     00004565           {$08} long    $4565, $4666, $4767, $4868, $4969, $4A6A, $4B6B, $4C6C          ' $0f: Ee Ff Gg Hh Ii Jj Kk Ll
023a4     00004d6d           {$10} long    $4D6D, $4E6E, $4F6F, $5070, $5171, $5272, $5373, $5474          ' $17: Mm Nn Oo Pp Qq Rr Ss Tt
023c4     00005575           {$18} long    $5575, $5676, $5777, $5878, $5979, $5A7A, $2131, $4032          ' $1f: Uu Vv Ww Xx Yy Zz !1 @2
023e4     00002333           {$20} long    $2333, $2434, $2535, $5E36, $2637, $2A38, $2839, $2930          ' $27: #3 $4 %5 ^6 &7 *8 (9 )0
02404     00000d0d           {$28} long    $0D0D, $1B1B, $0808, $0909, $2020, $5F2D, $2B3D, $7B5B          ' $2f: Enter Esc BkSpc Tab Spc _- += {[
02424     00007d5d           {$30} long    $7D5D, $7C5C, $7E23, $3A3B, $2227, $7E60, $3C2C, $3E2E          ' $37: }] |\ ~# :; "' ~` <, >.
02444     00003f2f           {$38} long    $3F2F, $3939, $3A3A, $3B3B, $3C3C, $3D3D, $3E3E, $3F3F          ' $3f: ?/ CapsLock F1 F2 F3 F4 F5 F6
02464     00004040           {$40} long    $4040, $4141, $4242, $4343, $4444, $4545, $4646, $4747          ' $47: F7 F8 F9 F10 F11 F12 PrtSc, ScrLk
02484     00004848           {$48} long    $4848, $4949, $4A4A, $4B4B, $087F, $4D4D, $4E4E, $4F4F          ' $4f: Pause, Ins, Home PgUp BkSpc_Del End PgDn Right
024a4     00005050           {$50} long    $5050, $5151, $5252, $5353, $2F2F, $2A2A, $2D2D, $2B2B          ' $57: Left Down Up KpdNumLck Kp/ Kp* Kp- Kp+
024c4     00000d0d           {$58} long    $0D0D, $3131, $3232, $3333, $5034, $3535, $3636, $3737          ' $5f: KpEnter Kp1_End Kp2_Down Kp3_PgDn Kp4_Left Kp5 Kp6_Right Kp7_Home
024e4     00003838           {$60} long    $3838, $3939, $3030, $7F2E, $5C7C, $6565                        ' $65: Kp8_Up Kp9_PgUp Kp0_Ins Kp._Del Kp\_| App
024fc              kbd_end
                   ' #endregion Data loaded to LUT at startup
                   {{
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |                                                   TERMS OF USE: MIT License                                                  |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |
                   |files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
                   |modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
                   |is furnished to do so, subject to the following conditions:                                                                   |
                   |                                                                                                                              |
                   |The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
                   |                                                                                                                              |
                   |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
                   |WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
                   |COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
                   |ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   }}
